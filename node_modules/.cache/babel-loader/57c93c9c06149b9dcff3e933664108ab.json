{"ast":null,"code":"var PassThrough = require('readable-stream').PassThrough;\n\nvar Readable = require('readable-stream').Readable;\n\nvar duplexer = require('duplexer2');\n\nmodule.exports = function () {\n  var streams;\n\n  if (arguments.length == 1 && Array.isArray(arguments[0])) {\n    streams = arguments[0];\n  } else {\n    streams = [].slice.call(arguments);\n  }\n\n  return combine(streams);\n};\n\nmodule.exports.obj = function () {\n  var streams;\n\n  if (arguments.length == 1 && Array.isArray(arguments[0])) {\n    streams = arguments[0];\n  } else {\n    streams = [].slice.call(arguments);\n  }\n\n  return combine(streams, {\n    objectMode: true\n  });\n};\n\nfunction combine(streams, opts) {\n  for (var i = 0; i < streams.length; i++) {\n    streams[i] = wrap(streams[i], opts);\n  }\n\n  if (streams.length == 0) return new PassThrough(opts);else if (streams.length == 1) return streams[0];\n  var first = streams[0],\n      last = streams[streams.length - 1],\n      thepipe = duplexer(opts, first, last); //pipe all the streams together\n\n  function recurse(streams) {\n    if (streams.length < 2) return;\n    streams[0].pipe(streams[1]);\n    recurse(streams.slice(1));\n  }\n\n  recurse(streams);\n\n  function onerror() {\n    var args = [].slice.call(arguments);\n    args.unshift('error');\n    thepipe.emit.apply(thepipe, args);\n  } //es.duplex already reemits the error from the first and last stream.\n  //add a listener for the inner streams in the pipeline.\n\n\n  for (var i = 1; i < streams.length - 1; i++) {\n    streams[i].on('error', onerror);\n  }\n\n  return thepipe;\n}\n\nfunction wrap(tr, opts) {\n  if (typeof tr.read === 'function') return tr;\n  return new Readable(opts).wrap(tr);\n}","map":null,"metadata":{},"sourceType":"script"}