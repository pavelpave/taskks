{"ast":null,"code":"var async = require(\"async\");\n\nvar _ = require(\"lodash\");\n\nvar deprecatedChain = {};\n\ndeprecatedChain.chain = function (obj) {\n  var _this = this;\n\n  if (!obj) {\n    obj = {};\n  } // Update the onError callback if supplied.  The most recent .chain()\n  // invocation overrides previous onError handlers.\n\n\n  if (obj.onError) {\n    this._chainOnErrorCallback = obj.onError;\n  } else if (!this._chainOnErrorCallback) {\n    this._chainOnErrorCallback = function (err) {\n      if (err) {\n        console.error(\"a function in your .chain() failed:\", err);\n      }\n    };\n  } // Add queue if not already here\n\n\n  if (!_this._queue) {\n    _this._queue = async.queue(function (task, callback) {\n      if (task.args.length > 0 && typeof task.args[task.args.length - 1] === \"function\") {\n        //wrap the existing callback\n        //if this is queueAddAsync, we instead create a callback that will be\n        //passed through to the function provided\n        var cb_arg = task.name === 'queueAddAsync' ? 1 : task.args.length - 1;\n        var func = task.args[cb_arg];\n\n        task.args[cb_arg] = function (err) {\n          // if the chain user has their own callback, we will not invoke\n          // the onError handler, supplying your own callback suggests you\n          // handle the error on your own.\n          if (func) {\n            func.apply(null, arguments);\n          }\n\n          if (!_this._chainHalted) {\n            callback(err);\n          }\n        };\n      } else {\n        // if the .chain() does not supply a callback, we assume they\n        // expect us to catch errors.\n        task.args.push(function (err) {\n          // if there is an error, call the onError callback,\n          // and do not invoke callback() which would make the\n          // task queue continue processing\n          if (err) {\n            _this._chainOnErrorCallback(err);\n          } else {\n            callback();\n          }\n        });\n      } //call the function\n\n\n      _this[task.name].apply(_this, task.args);\n    }, 1); // add unshift method if we need to add sth to the queue\n\n    _this._queue = _.extend(_this._queue, {\n      unshift: function unshift(data, callback) {\n        var _this = this;\n\n        if (data.constructor !== Array) {\n          data = [data];\n        }\n\n        data.forEach(function (task) {\n          _this.tasks.unshift({\n            data: task,\n            callback: typeof callback === 'function' ? callback : null\n          });\n\n          if (_this.saturated && _this.tasks.length === _this.concurrency) {\n            _this.saturated();\n          }\n\n          async.nextTick(_this.process);\n        });\n      }\n    });\n  }\n\n  var chain = {}; //builds a placeHolder functions\n\n  var buildPlaceholder = function buildPlaceholder(name) {\n    return function () {\n      _this._queue.push({\n        name: name,\n        args: Array.prototype.slice.call(arguments, 0)\n      });\n\n      return chain;\n    };\n  }; //fill the chain with placeholders\n\n\n  _.each(_.functionsIn(_this), function (k) {\n    if (k !== \"chain\") {\n      chain[k] = buildPlaceholder(k);\n    }\n  });\n\n  return chain;\n}; // manually stop processing of queued chained functions\n\n\ndeprecatedChain.haltChain = function () {\n  this._chainHalted = true;\n  this._queue = null;\n};\n\ndeprecatedChain.pauseChain = function (timeoutMs, cb) {\n  setTimeout(function () {\n    cb();\n  }, timeoutMs);\n  return this.chain;\n};\n\ndeprecatedChain.next = function () {\n  this._queue.unshift({\n    name: arguments[0],\n    args: _.drop(arguments)\n  });\n};\n\ndeprecatedChain.queueAdd = function (func) {\n  func();\n  return this.chain;\n};\n\ndeprecatedChain.queueAddAsync = function (func, cb) {\n  func(cb);\n  return this.chain;\n};\n\nmodule.exports = {\n  patch: function patch(browser) {\n    var chain = _(deprecatedChain);\n\n    var functions = _.isFunction(chain.methods) ? chain.methods() : chain.functions();\n    functions.each(function (methodName) {\n      browser[methodName] = deprecatedChain[methodName].bind(browser);\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}