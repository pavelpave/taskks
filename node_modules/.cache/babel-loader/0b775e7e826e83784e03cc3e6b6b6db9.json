{"ast":null,"code":"/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n\nvar expand = require('./lib/expand');\n\nvar utils = require('./lib/utils');\n/**\n * The main function. Pass an array of filepaths,\n * and a string or array of glob patterns\n *\n * @param  {Array|String} `files`\n * @param  {Array|String} `patterns`\n * @param  {Object} `opts`\n * @return {Array} Array of matches\n */\n\n\nfunction micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n\n  var len = patterns.length,\n      i = 0;\n  var omit = [],\n      keep = [];\n\n  while (len--) {\n    var glob = patterns[i++];\n\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33\n    /* ! */\n    ) {\n        omit.push.apply(omit, match(files, glob.slice(1), opts));\n      } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n\n  return utils.diff(keep, omit);\n}\n/**\n * Return an array of files that match the given glob pattern.\n *\n * This function is called by the main `micromatch` function If you only\n * need to pass a single pattern you might get very minor speed improvements\n * using this function.\n *\n * @param  {Array} `files`\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Array}\n */\n\n\nfunction match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n\n    if (negate) {\n      pattern = pattern.slice(1);\n    } // we need to remove the character regardless,\n    // so the above logic is still needed\n\n\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n\n  var len = files.length,\n      i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) {\n      continue;\n    }\n\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  } // if `negate` was defined, diff negated files\n\n\n  if (negate) {\n    res = utils.diff(files, res);\n  } // if `ignore` was defined, diff ignored filed\n\n\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n\n  return res;\n}\n/**\n * Returns a function that takes a glob pattern or array of glob patterns\n * to be used with `Array#filter()`. (Internally this function generates\n * the matching function using the [matcher] method).\n *\n * ```js\n * var fn = mm.filter('[a-c]');\n * ['a', 'b', 'c', 'd', 'e'].filter(fn);\n * //=> ['a', 'b', 'c']\n * ```\n * @param  {String|Array} `patterns` Can be a glob or array of globs.\n * @param  {Options} `opts` Options to pass to the [matcher] method.\n * @return {Function} Filter function to be passed to `Array#filter()`.\n */\n\n\nfunction filter(patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('filter', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length,\n      i = 0;\n  var patternMatchers = Array(len);\n\n  while (i < len) {\n    patternMatchers[i] = matcher(patterns[i++], opts);\n  }\n\n  return function (fp) {\n    if (fp == null) return [];\n    var len = patternMatchers.length,\n        i = 0;\n    var res = true;\n    fp = utils.unixify(fp, opts);\n\n    while (i < len) {\n      var fn = patternMatchers[i++];\n\n      if (!fn(fp)) {\n        res = false;\n        break;\n      }\n    }\n\n    return res;\n  };\n}\n/**\n * Returns true if the filepath contains the given\n * pattern. Can also return a function for matching.\n *\n * ```js\n * isMatch('foo.md', '*.md', {});\n * //=> true\n *\n * isMatch('*.md', {})('foo.md')\n * //=> true\n * ```\n * @param  {String} `fp`\n * @param  {String} `pattern`\n * @param  {Object} `opts`\n * @return {Boolean}\n */\n\n\nfunction isMatch(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('isMatch', 'filepath', 'a string'));\n  }\n\n  fp = utils.unixify(fp, opts);\n\n  if (utils.typeOf(pattern) === 'object') {\n    return matcher(fp, pattern);\n  }\n\n  return matcher(pattern, opts)(fp);\n}\n/**\n * Returns true if the filepath matches the\n * given pattern.\n */\n\n\nfunction contains(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('contains', 'pattern', 'a string'));\n  }\n\n  opts = opts || {};\n  opts.contains = pattern !== '';\n  fp = utils.unixify(fp, opts);\n\n  if (opts.contains && !utils.isGlob(pattern)) {\n    return fp.indexOf(pattern) !== -1;\n  }\n\n  return matcher(pattern, opts)(fp);\n}\n/**\n * Returns true if a file path matches any of the\n * given patterns.\n *\n * @param  {String} `fp` The filepath to test.\n * @param  {String|Array} `patterns` Glob patterns to use.\n * @param  {Object} `opts` Options to pass to the `matcher()` function.\n * @return {String}\n */\n\n\nfunction any(fp, patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('any', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length;\n  fp = utils.unixify(fp, opts);\n\n  while (len--) {\n    var isMatch = matcher(patterns[len], opts);\n\n    if (isMatch(fp)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Filter the keys of an object with the given `glob` pattern\n * and `options`\n *\n * @param  {Object} `object`\n * @param  {Pattern} `object`\n * @return {Array}\n */\n\n\nfunction matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n\n  return res;\n}\n/**\n * Return a function for matching based on the\n * given `pattern` and `options`.\n *\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Function}\n */\n\n\nfunction matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  } // pattern is a regex\n\n\n  if (pattern instanceof RegExp) {\n    return function (fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  } // strings, all the way down...\n\n\n  pattern = utils.unixify(pattern, opts); // pattern is a non-glob string\n\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  } // pattern is a glob string\n\n\n  var re = makeRe(pattern, opts); // `matchBase` is defined\n\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  } // `matchBase` is not defined\n\n\n  return function (fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}\n/**\n * Create and cache a regular expression for matching\n * file paths.\n *\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\n\nfunction toRegex(glob, options) {\n  // clone options to prevent  mutating the original object\n  var opts = Object.create(options || {});\n  var flags = opts.flags || '';\n\n  if (opts.nocase && flags.indexOf('i') === -1) {\n    flags += 'i';\n  }\n\n  var parsed = expand(glob, opts); // pass in tokens to avoid parsing more than once\n\n  opts.negated = opts.negated || parsed.negated;\n  opts.negate = opts.negated;\n  glob = wrapGlob(parsed.pattern, opts);\n  var re;\n\n  try {\n    re = new RegExp(glob, flags);\n    return re;\n  } catch (err) {\n    err.reason = 'micromatch invalid regex: (' + re + ')';\n    if (opts.strict) throw new SyntaxError(err);\n  } // we're only here if a bad pattern was used and the user\n  // passed `options.silent`, so match nothing\n\n\n  return /$^/;\n}\n/**\n * Create the regex to do the matching. If the leading\n * character in the `glob` is `!` a negation regex is returned.\n *\n * @param {String} `glob`\n * @param {Boolean} `negate`\n */\n\n\nfunction wrapGlob(glob, opts) {\n  var prefix = opts && !opts.contains ? '^' : '';\n  var after = opts && !opts.contains ? '$' : '';\n  glob = '(?:' + glob + ')' + after;\n\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n\n  return prefix + glob;\n}\n/**\n * Create and cache a regular expression for matching file paths.\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\n\nfunction makeRe(glob, opts) {\n  if (utils.typeOf(glob) !== 'string') {\n    throw new Error(msg('makeRe', 'glob', 'a string'));\n  }\n\n  return utils.cache(toRegex, glob, opts);\n}\n/**\n * Make error messages consistent. Follows this format:\n *\n * ```js\n * msg(methodName, argNumber, nativeType);\n * // example:\n * msg('matchKeys', 'first', 'an object');\n * ```\n *\n * @param  {String} `method`\n * @param  {String} `num`\n * @param  {String} `type`\n * @return {String}\n */\n\n\nfunction msg(method, what, type) {\n  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';\n}\n/**\n * Public methods\n */\n\n/* eslint no-multi-spaces: 0 */\n\n\nmicromatch.any = any;\nmicromatch.braces = micromatch.braceExpand = utils.braces;\nmicromatch.contains = contains;\nmicromatch.expand = expand;\nmicromatch.filter = filter;\nmicromatch.isMatch = isMatch;\nmicromatch.makeRe = makeRe;\nmicromatch.match = match;\nmicromatch.matcher = matcher;\nmicromatch.matchKeys = matchKeys;\n/**\n * Expose `micromatch`\n */\n\nmodule.exports = micromatch;","map":null,"metadata":{},"sourceType":"script"}