{"ast":null,"code":"'use strict';\n\nvar SourceMapGenerator = require('source-map').SourceMapGenerator;\n\nfunction offsetMapping(mapping, offset) {\n  return {\n    line: offset.line + mapping.line,\n    column: offset.column + mapping.column\n  };\n}\n\nfunction newlinesIn(src) {\n  if (!src) return 0;\n  var newlines = src.match(/\\n/g);\n  return newlines ? newlines.length : 0;\n}\n\nfunction Generator(opts) {\n  opts = opts || {};\n  this.generator = new SourceMapGenerator({\n    file: opts.file || '',\n    sourceRoot: opts.sourceRoot || ''\n  });\n  this.sourcesContent = undefined;\n  this.opts = opts;\n}\n/**\n * Adds the given mappings to the generator and offsets them if offset is given \n *\n * @name addMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param mappings {Array{{Object}} each object has the form { original: { line: _, column: _ }, generated: { line: _, column: _ } }\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\n\n\nGenerator.prototype.addMappings = function (sourceFile, mappings, offset) {\n  var generator = this.generator;\n  offset = offset || {};\n  offset.line = offset.hasOwnProperty('line') ? offset.line : 0;\n  offset.column = offset.hasOwnProperty('column') ? offset.column : 0;\n  mappings.forEach(function (m) {\n    // only set source if we have original position to handle edgecase (see inline-source-map tests)\n    generator.addMapping({\n      source: m.original ? sourceFile : undefined,\n      original: m.original,\n      generated: offsetMapping(m.generated, offset)\n    });\n  });\n  return this;\n};\n/**\n * Generates mappings for the given source, assuming that no translation from original to generated is necessary.\n *\n * @name addGeneratedMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param source {String} source of the file\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\n\n\nGenerator.prototype.addGeneratedMappings = function (sourceFile, source, offset) {\n  var mappings = [],\n      linesToGenerate = newlinesIn(source) + 1;\n\n  for (var line = 1; line <= linesToGenerate; line++) {\n    var location = {\n      line: line,\n      column: 0\n    };\n    mappings.push({\n      original: location,\n      generated: location\n    });\n  }\n\n  return this.addMappings(sourceFile, mappings, offset);\n};\n/**\n * Adds source content for the given source file.\n * \n * @name addSourceContent\n * @function\n * @param sourceFile {String} The source file for which a mapping is included\n * @param sourcesContent {String} The content of the source file\n * @return {Object} The generator to allow chaining\n */\n\n\nGenerator.prototype.addSourceContent = function (sourceFile, sourcesContent) {\n  this.sourcesContent = this.sourcesContent || {};\n  this.sourcesContent[sourceFile] = sourcesContent;\n  return this;\n};\n/**\n * @name base64Encode\n * @function\n * @return {String} bas64 encoded representation of the added mappings\n */\n\n\nGenerator.prototype.base64Encode = function () {\n  var map = this.toString();\n  return new Buffer(map).toString('base64');\n};\n/**\n * @name inlineMappingUrl\n * @function\n * @return {String} comment with base64 encoded representation of the added mappings. Can be inlined at the end of the generated file. \n */\n\n\nGenerator.prototype.inlineMappingUrl = function () {\n  var charset = this.opts.charset || 'utf-8';\n  return '//# sourceMappingURL=data:application/json;charset=' + charset + ';base64,' + this.base64Encode();\n};\n\nGenerator.prototype.toJSON = function () {\n  var map = this.generator.toJSON();\n  if (!this.sourcesContent) return map;\n\n  var toSourcesContent = function (s) {\n    if (typeof this.sourcesContent[s] === 'string') {\n      return this.sourcesContent[s];\n    } else {\n      return null;\n    }\n  }.bind(this);\n\n  map.sourcesContent = map.sources.map(toSourcesContent);\n  return map;\n};\n\nGenerator.prototype.toString = function () {\n  return JSON.stringify(this);\n};\n\nGenerator.prototype._mappings = function () {\n  return this.generator._mappings._array;\n};\n\nGenerator.prototype.gen = function () {\n  return this.generator;\n};\n\nmodule.exports = function (opts) {\n  return new Generator(opts);\n};\n\nmodule.exports.Generator = Generator;","map":null,"metadata":{},"sourceType":"script"}