{"ast":null,"code":"'use strict';\n\nvar Parser = require('jsonparse'),\n    through = require('through');\n\nvar bufferFrom = Buffer.from && Buffer.from !== Uint8Array.from;\n/*\n\n  the value of this.stack that creationix's jsonparse has is weird.\n\n  it makes this code ugly, but his problem is way harder that mine,\n  so i'll forgive him.\n\n*/\n\nexports.parse = function (path, map) {\n  var header, footer;\n  var parser = new Parser();\n  var stream = through(function (chunk) {\n    if ('string' === typeof chunk) chunk = bufferFrom ? Buffer.from(chunk) : new Buffer(chunk);\n    parser.write(chunk);\n  }, function (data) {\n    if (data) stream.write(data);\n    if (header) stream.emit('header', header);\n    if (footer) stream.emit('footer', footer);\n    stream.queue(null);\n  });\n  if ('string' === typeof path) path = path.split('.').map(function (e) {\n    if (e === '$*') return {\n      emitKey: true\n    };else if (e === '*') return true;else if (e === '') // '..'.split('.') returns an empty string\n      return {\n        recurse: true\n      };else return e;\n  });\n\n  var count = 0,\n      _key;\n\n  if (!path || !path.length) path = null;\n\n  parser.onValue = function (value) {\n    if (!this.root) stream.root = value;\n    if (!path) return;\n    var i = 0; // iterates on path\n\n    var j = 0; // iterates on stack\n\n    var emitKey = false;\n    var emitPath = false;\n\n    while (i < path.length) {\n      var key = path[i];\n      var c;\n      j++;\n\n      if (key && !key.recurse) {\n        c = j === this.stack.length ? this : this.stack[j];\n        if (!c) return;\n\n        if (!check(key, c.key)) {\n          setHeaderFooter(c.key, value);\n          return;\n        }\n\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++;\n      } else {\n        i++;\n        var nextKey = path[i];\n        if (!nextKey) return;\n\n        while (true) {\n          c = j === this.stack.length ? this : this.stack[j];\n          if (!c) return;\n\n          if (check(nextKey, c.key)) {\n            i++;\n            if (!Object.isFrozen(this.stack[j])) this.stack[j].value = null;\n            break;\n          } else {\n            setHeaderFooter(c.key, value);\n          }\n\n          j++;\n        }\n      }\n    } // emit header\n\n\n    if (header) {\n      stream.emit('header', header);\n      header = false;\n    }\n\n    if (j !== this.stack.length) return;\n    count++;\n    var actualPath = this.stack.slice(1).map(function (element) {\n      return element.key;\n    }).concat([this.key]);\n    var data = value;\n    if (null != data) if (null != (data = map ? map(data, actualPath) : data)) {\n      if (emitKey || emitPath) {\n        data = {\n          value: data\n        };\n        if (emitKey) data[\"key\"] = this.key;\n        if (emitPath) data[\"path\"] = actualPath;\n      }\n\n      stream.queue(data);\n    }\n    if (this.value) delete this.value[this.key];\n\n    for (var k in this.stack) {\n      if (!Object.isFrozen(this.stack[k])) this.stack[k].value = null;\n    }\n  };\n\n  parser._onToken = parser.onToken;\n\n  parser.onToken = function (token, value) {\n    parser._onToken(token, value);\n\n    if (this.stack.length === 0) {\n      if (stream.root) {\n        if (!path) stream.queue(stream.root);\n        count = 0;\n        stream.root = null;\n      }\n    }\n  };\n\n  parser.onError = function (err) {\n    if (err.message.indexOf(\"at position\") > -1) err.message = \"Invalid JSON (\" + err.message + \")\";\n    stream.emit('error', err);\n  };\n\n  return stream;\n\n  function setHeaderFooter(key, value) {\n    // header has not been emitted yet\n    if (header !== false) {\n      header = header || {};\n      header[key] = value;\n    } // footer has not been emitted yet but header has\n\n\n    if (footer !== false && header === false) {\n      footer = footer || {};\n      footer[key] = value;\n    }\n  }\n};\n\nfunction check(x, y) {\n  if ('string' === typeof x) return y == x;else if (x && 'function' === typeof x.exec) return x.exec(y);else if ('boolean' === typeof x || 'object' === typeof x) return x;else if ('function' === typeof x) return x(y);\n  return false;\n}\n\nexports.stringify = function (op, sep, cl, indent) {\n  indent = indent || 0;\n\n  if (op === false) {\n    op = '';\n    sep = '\\n';\n    cl = '';\n  } else if (op == null) {\n    op = '[\\n';\n    sep = '\\n,\\n';\n    cl = '\\n]\\n';\n  } //else, what ever you like\n\n\n  var stream,\n      first = true,\n      anyData = false;\n  stream = through(function (data) {\n    anyData = true;\n\n    try {\n      var json = JSON.stringify(data, null, indent);\n    } catch (err) {\n      return stream.emit('error', err);\n    }\n\n    if (first) {\n      first = false;\n      stream.queue(op + json);\n    } else stream.queue(sep + json);\n  }, function (data) {\n    if (!anyData) stream.queue(op);\n    stream.queue(cl);\n    stream.queue(null);\n  });\n  return stream;\n};\n\nexports.stringifyObject = function (op, sep, cl, indent) {\n  indent = indent || 0;\n\n  if (op === false) {\n    op = '';\n    sep = '\\n';\n    cl = '';\n  } else if (op == null) {\n    op = '{\\n';\n    sep = '\\n,\\n';\n    cl = '\\n}\\n';\n  } //else, what ever you like\n\n\n  var first = true;\n  var anyData = false;\n  var stream = through(function (data) {\n    anyData = true;\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent);\n\n    if (first) {\n      first = false;\n      this.queue(op + json);\n    } else this.queue(sep + json);\n  }, function (data) {\n    if (!anyData) this.queue(op);\n    this.queue(cl);\n    this.queue(null);\n  });\n  return stream;\n};","map":null,"metadata":{},"sourceType":"script"}