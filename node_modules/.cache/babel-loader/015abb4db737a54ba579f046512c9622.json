{"ast":null,"code":"var request = require('request'),\n    utils = require(\"./utils\"),\n    urllib = require('url'),\n    packageDotJson = require('../package.json');\n\nexports.buildInitUrl = function (baseUrl) {\n  return utils.resolveUrl(baseUrl, 'session');\n};\n\nexports.emit = function (browser, method, url, data) {\n  if (typeof data === 'object') {\n    data = JSON.stringify(data);\n  }\n\n  if (typeof url === 'string') {\n    url = urllib.parse(url);\n  }\n\n  browser.emit('http', method, url.path.replace(browser.sessionID, ':sessionID').replace(browser.configUrl.pathname, ''), data);\n};\n\nexports.buildJsonCallUrl = function (baseUrl, sessionID, relPath, absPath) {\n  var path = ['session'];\n\n  if (sessionID) {\n    path.push('/', sessionID);\n  }\n\n  if (relPath) {\n    path.push(relPath);\n  }\n\n  if (absPath) {\n    path = [absPath];\n  }\n\n  path = path.join('');\n  return utils.resolveUrl(baseUrl, path);\n};\n\nexports.newHttpOpts = function (method, httpConfig) {\n  // this._httpConfig\n  var opts = {};\n  opts.method = method;\n  opts.headers = {};\n  opts.headers.Connection = 'keep-alive';\n  opts.headers['User-Agent'] = 'admc/wd/' + packageDotJson.version;\n  opts.timeout = httpConfig.timeout;\n  opts.rejectUnauthorized = httpConfig.rejectUnauthorized;\n\n  if (httpConfig.proxy) {\n    opts.proxy = httpConfig.proxy;\n  } // we need to check method here to cater for PUT and DELETE case\n\n\n  if (opts.method === 'GET' || opts.method === 'POST') {\n    opts.followAllRedirects = true;\n    opts.headers.Accept = 'application/json';\n  }\n\n  opts.prepareToSend = function (url, data) {\n    if (typeof data === 'object') {\n      data = JSON.stringify(data);\n    }\n\n    this.url = url;\n\n    if (opts.method === 'POST' || opts.method === 'PUT') {\n      this.headers['Content-Type'] = 'application/json; charset=UTF-8';\n      this.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n      this.body = data;\n    }\n  };\n\n  return opts;\n};\n\nvar shouldRetryOn = function shouldRetryOn(err) {\n  return err.code === 'ECONNRESET' || err.code === 'ETIMEDOUT' || err.code === 'ESOCKETTIMEDOUT' || err.code === 'EPIPE';\n};\n\nvar requestWithRetry = function requestWithRetry(httpOpts, httpConfig, emit, cb, attempts) {\n  request(httpOpts, function (err, res, data) {\n    if (!attempts) {\n      attempts = 1;\n    }\n\n    if (httpConfig.retries >= 0 && (httpConfig.retries === 0 || attempts - 1 <= httpConfig.retries) && err && shouldRetryOn(err)) {\n      emit('connection', err.code, 'Lost http connection retrying in ' + httpConfig.retryDelay + ' ms.', err);\n      setTimeout(function () {\n        requestWithRetry(httpOpts, httpConfig, emit, cb, attempts + 1);\n      }, httpConfig.retryDelay);\n    } else {\n      if (err) {\n        emit('connection', err.code, 'Unexpected error.', err);\n      }\n\n      cb(err, res, data);\n    }\n  });\n};\n\nexports.requestWithRetry = requestWithRetry;\n\nvar requestWithoutRetry = function requestWithoutRetry(httpOpts, emit, cb) {\n  request(httpOpts, function (err, res, data) {\n    if (err) {\n      emit('connection', err.code, 'Unexpected error.', err);\n    }\n\n    cb(err, res, data);\n  });\n};\n\nexports.requestWithoutRetry = requestWithoutRetry;","map":null,"metadata":{},"sourceType":"script"}