{"ast":null,"code":"var xtend = require('xtend');\n\nvar acorn = require('acorn-node');\n\nvar dash = require('dash-ast');\n\nvar getAssignedIdentifiers = require('get-assigned-identifiers');\n\nfunction visitFunction(node, state, ancestors) {\n  if (node.params.length > 0) {\n    var idents = [];\n\n    for (var i = 0; i < node.params.length; i++) {\n      var sub = getAssignedIdentifiers(node.params[i]);\n\n      for (var j = 0; j < sub.length; j++) {\n        idents.push(sub[j]);\n      }\n    }\n\n    declareNames(node, idents);\n  }\n\n  if (node.type === 'FunctionDeclaration') {\n    var parent = getScopeNode(ancestors, 'const');\n    declareNames(parent, [node.id]);\n  } else if (node.type === 'FunctionExpression' && node.id) {\n    declareNames(node, [node.id]);\n  }\n}\n\nvar scopeVisitor = {\n  VariableDeclaration: function VariableDeclaration(node, state, ancestors) {\n    var parent = getScopeNode(ancestors, node.kind);\n\n    for (var i = 0; i < node.declarations.length; i++) {\n      declareNames(parent, getAssignedIdentifiers(node.declarations[i].id));\n    }\n  },\n  FunctionExpression: visitFunction,\n  FunctionDeclaration: visitFunction,\n  ArrowFunctionExpression: visitFunction,\n  ClassDeclaration: function ClassDeclaration(node, state, ancestors) {\n    var parent = getScopeNode(ancestors, 'const');\n\n    if (node.id) {\n      declareNames(parent, [node.id]);\n    }\n  },\n  ImportDeclaration: function ImportDeclaration(node, state, ancestors) {\n    declareNames(ancestors[0]\n    /* root */\n    , getAssignedIdentifiers(node));\n  },\n  CatchClause: function CatchClause(node) {\n    if (node.param) declareNames(node, [node.param]);\n  }\n};\nvar bindingVisitor = {\n  Identifier: function Identifier(node, state, ancestors) {\n    if (!state.identifiers) return;\n    var parent = ancestors[ancestors.length - 1];\n    if (parent.type === 'MemberExpression' && parent.property === node) return;\n    if (parent.type === 'Property' && !parent.computed && parent.key === node) return;\n    if (parent.type === 'MethodDefinition' && !parent.computed && parent.key === node) return;\n    if (parent.type === 'LabeledStatement' && parent.label === node) return;\n\n    if (!has(state.undeclared, node.name)) {\n      for (var i = ancestors.length - 1; i >= 0; i--) {\n        if (ancestors[i]._names !== undefined && has(ancestors[i]._names, node.name)) {\n          return;\n        }\n      }\n\n      state.undeclared[node.name] = true;\n    }\n\n    if (state.wildcard && !(parent.type === 'MemberExpression' && parent.object === node) && !(parent.type === 'VariableDeclarator' && parent.id === node) && !(parent.type === 'AssignmentExpression' && parent.left === node)) {\n      state.undeclaredProps[node.name + '.*'] = true;\n    }\n  },\n  MemberExpression: function MemberExpression(node, state) {\n    if (!state.properties) return;\n\n    if (node.object.type === 'Identifier' && has(state.undeclared, node.object.name)) {\n      var prop = !node.computed && node.property.type === 'Identifier' ? node.property.name : node.computed && node.property.type === 'Literal' ? node.property.value : null;\n      if (prop) state.undeclaredProps[node.object.name + '.' + prop] = true;\n    }\n  }\n};\n\nmodule.exports = function findUndeclared(src, opts) {\n  opts = xtend({\n    identifiers: true,\n    properties: true,\n    wildcard: false\n  }, opts);\n  var state = {\n    undeclared: {},\n    undeclaredProps: {},\n    identifiers: opts.identifiers,\n    properties: opts.properties,\n    wildcard: opts.wildcard // Parse if `src` is not already an AST.\n\n  };\n  var ast = typeof src === 'object' && src !== null && typeof src.type === 'string' ? src : acorn.parse(src);\n  var parents = [];\n  dash(ast, {\n    enter: function enter(node, parent) {\n      if (parent) parents.push(parent);\n      var visit = scopeVisitor[node.type];\n      if (visit) visit(node, state, parents);\n    },\n    leave: function leave(node, parent) {\n      var visit = bindingVisitor[node.type];\n      if (visit) visit(node, state, parents);\n      if (parent) parents.pop();\n    }\n  });\n  return {\n    identifiers: Object.keys(state.undeclared),\n    properties: Object.keys(state.undeclaredProps)\n  };\n};\n\nfunction getScopeNode(parents, kind) {\n  for (var i = parents.length - 1; i >= 0; i--) {\n    if (parents[i].type === 'FunctionDeclaration' || parents[i].type === 'FunctionExpression' || parents[i].type === 'ArrowFunctionExpression' || parents[i].type === 'Program') {\n      return parents[i];\n    }\n\n    if (kind !== 'var' && parents[i].type === 'BlockStatement') {\n      return parents[i];\n    }\n  }\n}\n\nfunction declareNames(node, names) {\n  if (node._names === undefined) {\n    node._names = Object.create(null);\n  }\n\n  for (var i = 0; i < names.length; i++) {\n    node._names[names[i].name] = true;\n  }\n}\n\nfunction has(obj, name) {\n  return Object.prototype.hasOwnProperty.call(obj, name);\n}","map":null,"metadata":{},"sourceType":"script"}