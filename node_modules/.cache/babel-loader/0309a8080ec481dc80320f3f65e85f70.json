{"ast":null,"code":"var __slice = Array.prototype.slice,\n    Q = require('q'),\n    _ = require('lodash'),\n    EventEmitter = require('events').EventEmitter,\n    slice = Array.prototype.slice.call.bind(Array.prototype.slice),\n    utils = require('./utils'); // The method below returns no result, so we are able hijack the result to\n// preserve the element scope.\n// This alows for thing like: field.click().clear().input('hello').getValue()\n\n\nvar elementChainableMethods = ['clear', 'click', 'doubleClick', 'doubleclick', 'flick', 'tap', 'sendKeys', 'submit', 'type', 'keys', 'moveTo', 'sleep', 'noop']; // gets the list of methods to be promisified.\n\nfunction filterPromisedMethods(Obj) {\n  return _(Obj).functionsIn().filter(function (fname) {\n    return !fname.match('^newElement$|^toJSON$|^toString$|^_') && !EventEmitter.prototype[fname];\n  }).value();\n}\n\nmodule.exports = function (WebDriver, Element, chainable) {\n  // wraps element + browser call in an enriched promise.\n  // This is the same as in the first promise version, but enrichment +\n  // event logging were added.\n  function wrap(fn, fname) {\n    return function () {\n      var _this = this;\n\n      var callback;\n      var args = slice(arguments);\n      var deferred = Q.defer();\n      deferred.promise.then(function () {\n        _this.emit(\"promise\", _this, fname, args, \"finished\");\n      }); // Remove any undefined values from the end of the arguments array\n      // as these interfere with our callback detection below\n\n      for (var i = args.length - 1; i >= 0 && args[i] === undefined; i--) {\n        args.pop();\n      } // If the last argument is a function assume that it's a callback\n      // (Based on the API as of 2012/12/1 this assumption is always correct)\n\n\n      if (typeof args[args.length - 1] === 'function') {\n        // Remove to replace it with our callback and then call it\n        // appropriately when the promise is resolved or rejected\n        callback = args.pop();\n        deferred.promise.then(function (value) {\n          callback(null, value);\n        }, function (error) {\n          callback(error);\n        });\n      }\n\n      args.push(deferred.makeNodeResolver());\n\n      _this.emit(\"promise\", _this, fname, args, \"calling\");\n\n      fn.apply(this, args);\n\n      if (chainable) {\n        return this._enrich(deferred.promise);\n      } else {\n        return deferred.promise;\n      }\n    };\n  } // Element replacement.\n\n\n  var PromiseElement = function PromiseElement() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return Element.apply(this, args);\n  };\n\n  PromiseElement.prototype = Object.create(Element.prototype);\n  PromiseElement.prototype.isPromised = true; // WebDriver replacement.\n\n  var PromiseWebdriver = function PromiseWebdriver() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return WebDriver.apply(this, args);\n  };\n\n  PromiseWebdriver.prototype = Object.create(WebDriver.prototype);\n  PromiseWebdriver.prototype.isPromised = true;\n  PromiseWebdriver.prototype.defaultChainingScope = 'browser';\n\n  PromiseWebdriver.prototype.getDefaultChainingScope = function () {\n    return this.defaultChainingScope;\n  }; // wrapping browser methods with promises.\n\n\n  _(filterPromisedMethods(WebDriver.prototype)).each(function (fname) {\n    PromiseWebdriver.prototype[fname] = wrap(WebDriver.prototype[fname], fname);\n  }); // wrapping element methods with promises.\n\n\n  _(filterPromisedMethods(Element.prototype)).each(function (fname) {\n    PromiseElement.prototype[fname] = wrap(Element.prototype[fname], fname);\n  });\n\n  PromiseWebdriver.prototype.newElement = function (jsonWireElement) {\n    return new PromiseElement(jsonWireElement, this);\n  }; // enriches a promise with the browser + element methods.\n\n\n  PromiseWebdriver.prototype._enrich = function (obj, currentEl) {\n    var _this = this; // There are cases were enrich may be called on non-promise objects.\n    // It is easier and safer to check within the method.\n\n\n    if (utils.isPromise(obj) && !obj.__wd_promise_enriched) {\n      var promise = obj; // __wd_promise_enriched is there to avoid enriching twice.\n\n      promise.__wd_promise_enriched = true; // making sure all the sub-promises are also enriched.\n\n      _(promise).functionsIn() // promiseDispatch is used a lot, and we know it doesn't need to be enriched\n      .filter(function (fname) {\n        return fname !== 'promiseDispatch';\n      }).each(function (fname) {\n        var _orig = promise[fname];\n\n        promise[fname] = function () {\n          var subobj = _orig.apply(this, __slice.call(arguments, 0));\n\n          return this._enrich(subobj, currentEl);\n        };\n      }); // we get the list of methods dynamically.\n\n\n      var promisedMethods = filterPromisedMethods(Object.getPrototypeOf(_this));\n      _this.sampleElement = _this.sampleElement || _this.newElement(1);\n      var elementPromisedMethods = filterPromisedMethods(Object.getPrototypeOf(_this.sampleElement));\n\n      var allPromisedMethods = _.union(promisedMethods, elementPromisedMethods); // adding browser + element methods to the current promise.\n\n\n      _(allPromisedMethods).each(function (fname) {\n        promise[fname] = function () {\n          var args = __slice.call(arguments, 0); // This is a hint to figure out if we need to call a browser method or\n          // an element method.\n          // \"<\" --> browser method\n          // \">\" --> element method\n\n\n          var scopeHint;\n\n          if (args && args[0] && typeof args[0] === 'string' && args[0].match(/^[<>]$/)) {\n            scopeHint = args[0];\n            args = _.drop(args);\n          }\n\n          return this.then(function (res) {\n            var el; // if the result is an element it has priority\n\n            if (Element && res instanceof Element) {\n              el = res;\n            } // if we are within an element\n\n\n            el = el || currentEl; // testing the water for the next call scope\n\n            var isBrowserMethod = _.indexOf(promisedMethods, fname) >= 0;\n            var isElementMethod = el && _.indexOf(elementPromisedMethods, fname) >= 0;\n\n            if (!isBrowserMethod && !isElementMethod) {\n              // doesn't look good\n              throw new Error(\"Invalid method \" + fname);\n            }\n\n            if (isBrowserMethod && isElementMethod) {\n              // we need to resolve the conflict.\n              if (scopeHint === '<') {\n                isElementMethod = false;\n              } else if (scopeHint === '>') {\n                isBrowserMethod = false;\n              } else if (fname.match(/element/) || Element && args[0] instanceof Element) {\n                // method with element locators are browser scoped by default.\n                if (_this.defaultChainingScope === 'element') {\n                  isBrowserMethod = false;\n                } else {\n                  isElementMethod = false;\n                } // default\n\n              } else if (Element && args[0] instanceof Element) {\n                // When an element is passed, we are in the global scope.\n                isElementMethod = false;\n              } else {\n                // otherwise we stay in the element scope to allow sequential calls\n                isBrowserMethod = false;\n              }\n            }\n\n            if (isElementMethod) {\n              // element method case.\n              return el[fname].apply(el, args).then(function (res) {\n                if (_.indexOf(elementChainableMethods, fname) >= 0) {\n                  // method like click, where no result is expected, we return\n                  // the element to make it chainable\n                  return el;\n                } else {\n                  return res; // we have no choice but loosing the scope\n                }\n              });\n            } else {\n              // browser case.\n              return _this[fname].apply(_this, args);\n            }\n          });\n        };\n      }); // transfering _enrich\n\n\n      promise._enrich = function (target) {\n        return _this._enrich(target, currentEl);\n      }; // gets the element at index (starting at 0)\n\n\n      promise.at = function (i) {\n        return _this._enrich(promise.then(function (vals) {\n          return vals[i];\n        }), currentEl);\n      }; // gets the element at index (starting at 0)\n\n\n      promise.last = function () {\n        return promise.then(function (vals) {\n          return vals[vals.length - 1];\n        });\n      }; // gets nth element (starting at 1)\n\n\n      promise.nth = function (i) {\n        return promise.at(i - 1);\n      }; // gets the first element\n\n\n      promise.first = function () {\n        return promise.nth(1);\n      }; // gets the first element\n\n\n      promise.second = function () {\n        return promise.nth(2);\n      }; // gets the first element\n\n\n      promise.third = function () {\n        return promise.nth(3);\n      }; // print error\n\n\n      promise.printError = function (prepend) {\n        prepend = prepend || \"\";\n        return _this._enrich(promise.catch(function (err) {\n          console.log(prepend + err);\n          throw err;\n        }), currentEl);\n      }; // print\n\n\n      promise.print = function (prepend) {\n        prepend = prepend || \"\";\n        return _this._enrich(promise.then(function (val) {\n          console.log(prepend + val);\n        }), currentEl);\n      };\n    }\n\n    return obj;\n  };\n  /**\n   * Starts the chain (promised driver only)\n   * browser.chain()\n   * element.chain()\n   */\n\n\n  PromiseWebdriver.prototype.chain = PromiseWebdriver.prototype.noop;\n  PromiseElement.prototype.chain = PromiseElement.prototype.noop;\n  /**\n   * Resolves the promise (promised driver only)\n   * browser.resolve(promise)\n   * element.resolve(promise)\n   */\n\n  PromiseWebdriver.prototype.resolve = function (promise) {\n    var qPromise = new Q(promise);\n\n    this._enrich(qPromise);\n\n    return qPromise;\n  };\n\n  PromiseElement.prototype.resolve = function (promise) {\n    var qPromise = new Q(promise);\n\n    this._enrich(qPromise);\n\n    return qPromise;\n  }; // used to by chai-as-promised and custom methods\n\n\n  PromiseElement.prototype._enrich = function (target) {\n    if (chainable) {\n      return this.browser._enrich(target, this);\n    }\n  }; // used to wrap custom methods\n\n\n  PromiseWebdriver._wrapAsync = wrap; // helper to allow easier promise debugging.\n\n  PromiseWebdriver.prototype._debugPromise = function () {\n    this.on('promise', function (context, method, args, status) {\n      args = _.clone(args);\n\n      if (context instanceof PromiseWebdriver) {\n        context = '';\n      } else {\n        context = ' [element ' + context.value + ']';\n      }\n\n      if (typeof _.last(args) === 'function') {\n        args.pop();\n      }\n\n      args = ' ( ' + _(args).map(function (arg) {\n        if (arg instanceof Element) {\n          return arg.toString();\n        } else if (typeof arg === 'object') {\n          return JSON.stringify(arg);\n        } else {\n          return arg;\n        }\n      }).join(', ') + ' )';\n      console.log(' --> ' + status + context + \" \" + method + args);\n    });\n  };\n\n  return {\n    PromiseWebdriver: PromiseWebdriver,\n    PromiseElement: PromiseElement\n  };\n};","map":null,"metadata":{},"sourceType":"script"}