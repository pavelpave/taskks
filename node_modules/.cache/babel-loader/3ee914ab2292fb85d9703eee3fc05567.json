{"ast":null,"code":"var core = require('./core');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar caller = require('./caller.js');\n\nvar nodeModulesPaths = require('./node-modules-paths.js');\n\nvar normalizeOptions = require('./normalize-options.js');\n\nvar defaultIsFile = function isFile(file, cb) {\n  fs.stat(file, function (err, stat) {\n    if (!err) {\n      return cb(null, stat.isFile() || stat.isFIFO());\n    }\n\n    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n    return cb(err);\n  });\n};\n\nmodule.exports = function resolve(x, options, callback) {\n  var cb = callback;\n  var opts = options;\n\n  if (typeof options === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  if (typeof x !== 'string') {\n    var err = new TypeError('Path must be a string.');\n    return process.nextTick(function () {\n      cb(err);\n    });\n  }\n\n  opts = normalizeOptions(x, opts);\n  var isFile = opts.isFile || defaultIsFile;\n  var readFile = opts.readFile || fs.readFile;\n  var extensions = opts.extensions || ['.js'];\n  var basedir = opts.basedir || path.dirname(caller());\n  var parent = opts.filename || basedir;\n  opts.paths = opts.paths || []; // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n\n  var absoluteStart = path.resolve(basedir);\n\n  if (opts.preserveSymlinks === false) {\n    fs.realpath(absoluteStart, function (realPathErr, realStart) {\n      if (realPathErr && realPathErr.code !== 'ENOENT') cb(err);else init(realPathErr ? absoluteStart : realStart);\n    });\n  } else {\n    init(absoluteStart);\n  }\n\n  var res;\n\n  function init(basedir) {\n    if (/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/.test(x)) {\n      res = path.resolve(basedir, x);\n      if (x === '..' || x.slice(-1) === '/') res += '/';\n\n      if (/\\/$/.test(x) && res === basedir) {\n        loadAsDirectory(res, opts.package, onfile);\n      } else loadAsFile(res, opts.package, onfile);\n    } else loadNodeModules(x, basedir, function (err, n, pkg) {\n      if (err) cb(err);else if (n) cb(null, n, pkg);else if (core[x]) return cb(null, x);else {\n        var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n        moduleError.code = 'MODULE_NOT_FOUND';\n        cb(moduleError);\n      }\n    });\n  }\n\n  function onfile(err, m, pkg) {\n    if (err) cb(err);else if (m) cb(null, m, pkg);else loadAsDirectory(res, function (err, d, pkg) {\n      if (err) cb(err);else if (d) cb(null, d, pkg);else {\n        var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n        moduleError.code = 'MODULE_NOT_FOUND';\n        cb(moduleError);\n      }\n    });\n  }\n\n  function loadAsFile(x, thePackage, callback) {\n    var loadAsFilePackage = thePackage;\n    var cb = callback;\n\n    if (typeof loadAsFilePackage === 'function') {\n      cb = loadAsFilePackage;\n      loadAsFilePackage = undefined;\n    }\n\n    var exts = [''].concat(extensions);\n    load(exts, x, loadAsFilePackage);\n\n    function load(exts, x, loadPackage) {\n      if (exts.length === 0) return cb(null, undefined, loadPackage);\n      var file = x + exts[0];\n      var pkg = loadPackage;\n      if (pkg) onpkg(null, pkg);else loadpkg(path.dirname(file), onpkg);\n\n      function onpkg(err, pkg_, dir) {\n        pkg = pkg_;\n        if (err) return cb(err);\n\n        if (dir && pkg && opts.pathFilter) {\n          var rfile = path.relative(dir, file);\n          var rel = rfile.slice(0, rfile.length - exts[0].length);\n          var r = opts.pathFilter(pkg, x, rel);\n          if (r) return load([''].concat(extensions.slice()), path.resolve(dir, r), pkg);\n        }\n\n        isFile(file, onex);\n      }\n\n      function onex(err, ex) {\n        if (err) return cb(err);\n        if (ex) return cb(null, file, pkg);\n        load(exts.slice(1), x, pkg);\n      }\n    }\n  }\n\n  function loadpkg(dir, cb) {\n    if (dir === '' || dir === '/') return cb(null);\n\n    if (process.platform === 'win32' && /^\\w:[/\\\\]*$/.test(dir)) {\n      return cb(null);\n    }\n\n    if (/[/\\\\]node_modules[/\\\\]*$/.test(dir)) return cb(null);\n    var pkgfile = path.join(dir, 'package.json');\n    isFile(pkgfile, function (err, ex) {\n      // on err, ex is false\n      if (!ex) return loadpkg(path.dirname(dir), cb);\n      readFile(pkgfile, function (err, body) {\n        if (err) cb(err);\n\n        try {\n          var pkg = JSON.parse(body);\n        } catch (jsonErr) {}\n\n        if (pkg && opts.packageFilter) {\n          pkg = opts.packageFilter(pkg, pkgfile);\n        }\n\n        cb(null, pkg, dir);\n      });\n    });\n  }\n\n  function loadAsDirectory(x, loadAsDirectoryPackage, callback) {\n    var cb = callback;\n    var fpkg = loadAsDirectoryPackage;\n\n    if (typeof fpkg === 'function') {\n      cb = fpkg;\n      fpkg = opts.package;\n    }\n\n    var pkgfile = path.join(x, 'package.json');\n    isFile(pkgfile, function (err, ex) {\n      if (err) return cb(err);\n      if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);\n      readFile(pkgfile, function (err, body) {\n        if (err) return cb(err);\n\n        try {\n          var pkg = JSON.parse(body);\n        } catch (jsonErr) {}\n\n        if (opts.packageFilter) {\n          pkg = opts.packageFilter(pkg, pkgfile);\n        }\n\n        if (pkg.main) {\n          if (typeof pkg.main !== 'string') {\n            var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');\n            mainError.code = 'INVALID_PACKAGE_MAIN';\n            return cb(mainError);\n          }\n\n          if (pkg.main === '.' || pkg.main === './') {\n            pkg.main = 'index';\n          }\n\n          loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {\n            if (err) return cb(err);\n            if (m) return cb(null, m, pkg);\n            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);\n            var dir = path.resolve(x, pkg.main);\n            loadAsDirectory(dir, pkg, function (err, n, pkg) {\n              if (err) return cb(err);\n              if (n) return cb(null, n, pkg);\n              loadAsFile(path.join(x, 'index'), pkg, cb);\n            });\n          });\n          return;\n        }\n\n        loadAsFile(path.join(x, '/index'), pkg, cb);\n      });\n    });\n  }\n\n  function processDirs(cb, dirs) {\n    if (dirs.length === 0) return cb(null, undefined);\n    var dir = dirs[0];\n    var file = path.join(dir, x);\n    loadAsFile(file, opts.package, onfile);\n\n    function onfile(err, m, pkg) {\n      if (err) return cb(err);\n      if (m) return cb(null, m, pkg);\n      loadAsDirectory(path.join(dir, x), opts.package, ondir);\n    }\n\n    function ondir(err, n, pkg) {\n      if (err) return cb(err);\n      if (n) return cb(null, n, pkg);\n      processDirs(cb, dirs.slice(1));\n    }\n  }\n\n  function loadNodeModules(x, start, cb) {\n    processDirs(cb, nodeModulesPaths(start, opts, x));\n  }\n};","map":null,"metadata":{},"sourceType":"script"}