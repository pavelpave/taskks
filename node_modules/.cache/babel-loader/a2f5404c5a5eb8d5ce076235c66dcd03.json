{"ast":null,"code":"var mdeps = require('module-deps');\n\nvar depsSort = require('deps-sort');\n\nvar bpack = require('browser-pack');\n\nvar insertGlobals = require('insert-module-globals');\n\nvar syntaxError = require('syntax-error');\n\nvar builtins = require('./lib/builtins.js');\n\nvar splicer = require('labeled-stream-splicer');\n\nvar through = require('through2');\n\nvar concat = require('concat-stream');\n\nvar inherits = require('inherits');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar xtend = require('xtend');\n\nvar isarray = require('isarray');\n\nvar defined = require('defined');\n\nvar has = require('has');\n\nvar sanitize = require('htmlescape').sanitize;\n\nvar shasum = require('shasum');\n\nvar bresolve = require('browser-resolve');\n\nvar resolve = require('resolve');\n\nvar readonly = require('read-only-stream');\n\nmodule.exports = Browserify;\ninherits(Browserify, EventEmitter);\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar paths = {\n  empty: path.join(__dirname, 'lib/_empty.js')\n};\n\nfunction Browserify(files, opts) {\n  var self = this;\n  if (!(this instanceof Browserify)) return new Browserify(files, opts);\n  if (!opts) opts = {};\n\n  if (typeof files === 'string' || isarray(files) || isStream(files)) {\n    opts = xtend(opts, {\n      entries: [].concat(opts.entries || [], files)\n    });\n  } else opts = xtend(files, opts);\n\n  self._options = opts;\n  if (opts.noparse) opts.noParse = opts.noparse;\n\n  if (opts.basedir !== undefined && typeof opts.basedir !== 'string') {\n    throw new Error('opts.basedir must be either undefined or a string.');\n  }\n\n  self._external = [];\n  self._exclude = [];\n  self._ignore = [];\n  self._expose = {};\n  self._hashes = {};\n  self._pending = 0;\n  self._transformOrder = 0;\n  self._transformPending = 0;\n  self._transforms = [];\n  self._entryOrder = 0;\n  self._ticked = false;\n  self._bresolve = opts.browserField === false ? function (id, opts, cb) {\n    if (!opts.basedir) opts.basedir = path.dirname(opts.filename);\n    resolve(id, opts, cb);\n  } : bresolve;\n  self._syntaxCache = {};\n  var ignoreTransform = [].concat(opts.ignoreTransform).filter(Boolean);\n\n  self._filterTransform = function (tr) {\n    if (Array.isArray(tr)) {\n      return ignoreTransform.indexOf(tr[0]) === -1;\n    }\n\n    return ignoreTransform.indexOf(tr) === -1;\n  };\n\n  self.pipeline = self._createPipeline(opts);\n  [].concat(opts.transform).filter(Boolean).filter(self._filterTransform).forEach(function (tr) {\n    self.transform(tr);\n  });\n  [].concat(opts.entries).filter(Boolean).forEach(function (file) {\n    self.add(file, {\n      basedir: opts.basedir\n    });\n  });\n  [].concat(opts.require).filter(Boolean).forEach(function (file) {\n    self.require(file, {\n      basedir: opts.basedir\n    });\n  });\n  [].concat(opts.plugin).filter(Boolean).forEach(function (p) {\n    self.plugin(p, {\n      basedir: opts.basedir\n    });\n  });\n}\n\nBrowserify.prototype.require = function (file, opts) {\n  var self = this;\n\n  if (isarray(file)) {\n    file.forEach(function (x) {\n      if (typeof x === 'object') {\n        self.require(x.file, xtend(opts, x));\n      } else self.require(x, opts);\n    });\n    return this;\n  }\n\n  if (!opts) opts = {};\n  var basedir = defined(opts.basedir, self._options.basedir, process.cwd());\n  var expose = opts.expose;\n\n  if (file === expose && /^[\\.]/.test(expose)) {\n    expose = '/' + path.relative(basedir, expose);\n    expose = expose.replace(/\\\\/g, '/');\n  }\n\n  if (expose === undefined && this._options.exposeAll) {\n    expose = true;\n  }\n\n  if (expose === true) {\n    expose = '/' + path.relative(basedir, file);\n    expose = expose.replace(/\\\\/g, '/');\n  }\n\n  if (isStream(file)) {\n    self._pending++;\n    var order = self._entryOrder++;\n    file.pipe(concat(function (buf) {\n      var filename = opts.file || file.file || path.join(basedir, '_stream_' + order + '.js');\n      var id = file.id || expose || filename;\n\n      if (expose || opts.entry === false) {\n        self._expose[id] = filename;\n      }\n\n      if (!opts.entry && self._options.exports === undefined) {\n        self._bpack.hasExports = true;\n      }\n\n      var rec = {\n        source: buf.toString('utf8'),\n        entry: defined(opts.entry, false),\n        file: filename,\n        id: id\n      };\n      if (rec.entry) rec.order = order;\n      if (rec.transform === false) rec.transform = false;\n      self.pipeline.write(rec);\n      if (--self._pending === 0) self.emit('_ready');\n    }));\n    return this;\n  }\n\n  var row;\n\n  if (typeof file === 'object') {\n    row = xtend(file, opts);\n  } else if (!opts.entry && isExternalModule(file)) {\n    // external module or builtin\n    row = xtend(opts, {\n      id: expose || file,\n      file: file\n    });\n  } else {\n    row = xtend(opts, {\n      file: path.resolve(basedir, file)\n    });\n  }\n\n  if (!row.id) {\n    row.id = expose || row.file;\n  }\n\n  if (expose || !row.entry) {\n    // Make this available to mdeps so that it can assign the value when it\n    // resolves the pathname.\n    row.expose = row.id;\n  }\n\n  if (opts.external) return self.external(file, opts);\n  if (row.entry === undefined) row.entry = false;\n\n  if (!row.entry && self._options.exports === undefined) {\n    self._bpack.hasExports = true;\n  }\n\n  if (row.entry) row.order = self._entryOrder++;\n  if (opts.transform === false) row.transform = false;\n  self.pipeline.write(row);\n  return self;\n};\n\nBrowserify.prototype.add = function (file, opts) {\n  var self = this;\n  if (!opts) opts = {};\n\n  if (isarray(file)) {\n    file.forEach(function (x) {\n      self.add(x, opts);\n    });\n    return this;\n  }\n\n  return this.require(file, xtend({\n    entry: true,\n    expose: false\n  }, opts));\n};\n\nBrowserify.prototype.external = function (file, opts) {\n  var self = this;\n\n  if (isarray(file)) {\n    file.forEach(function (f) {\n      if (typeof f === 'object') {\n        self.external(f, xtend(opts, f));\n      } else self.external(f, opts);\n    });\n    return this;\n  }\n\n  if (file && typeof file === 'object' && typeof file.bundle === 'function') {\n    var b = file;\n    self._pending++;\n    var bdeps = {};\n    var blabels = {};\n    b.on('label', function (prev, id) {\n      self._external.push(id);\n\n      if (prev !== id) {\n        blabels[prev] = id;\n\n        self._external.push(prev);\n      }\n    });\n    b.pipeline.get('deps').push(through.obj(function (row, enc, next) {\n      bdeps = xtend(bdeps, row.deps);\n      this.push(row);\n      next();\n    }));\n    self.on('dep', function (row) {\n      Object.keys(row.deps).forEach(function (key) {\n        var prev = bdeps[key];\n\n        if (prev) {\n          var id = blabels[prev];\n\n          if (id) {\n            row.indexDeps[key] = id;\n          }\n        }\n      });\n    });\n    b.pipeline.get('label').once('end', function () {\n      if (--self._pending === 0) self.emit('_ready');\n    });\n    return this;\n  }\n\n  if (!opts) opts = {};\n  var basedir = defined(opts.basedir, process.cwd());\n\n  this._external.push(file);\n\n  this._external.push('/' + path.relative(basedir, file));\n\n  return this;\n};\n\nBrowserify.prototype.exclude = function (file, opts) {\n  if (!opts) opts = {};\n  var basedir = defined(opts.basedir, process.cwd());\n\n  this._exclude.push(file);\n\n  this._exclude.push('/' + path.relative(basedir, file));\n\n  return this;\n};\n\nBrowserify.prototype.ignore = function (file, opts) {\n  if (!opts) opts = {};\n  var basedir = defined(opts.basedir, process.cwd()); // Handle relative paths\n\n  if (file[0] === '.') {\n    this._ignore.push(path.resolve(basedir, file));\n  } else {\n    this._ignore.push(file);\n  }\n\n  return this;\n};\n\nBrowserify.prototype.transform = function (tr, opts) {\n  var self = this;\n\n  if (typeof opts === 'function' || typeof opts === 'string') {\n    tr = [opts, tr];\n  }\n\n  if (isarray(tr)) {\n    opts = tr[1];\n    tr = tr[0];\n  } //if the bundler is ignoring this transform\n\n\n  if (typeof tr === 'string' && !self._filterTransform(tr)) {\n    return this;\n  }\n\n  function resolved() {\n    self._transforms[order] = rec;\n    --self._pending;\n\n    if (--self._transformPending === 0) {\n      self._transforms.forEach(function (transform) {\n        self.pipeline.write(transform);\n      });\n\n      if (self._pending === 0) {\n        self.emit('_ready');\n      }\n    }\n  }\n\n  if (!opts) opts = {};\n  opts._flags = '_flags' in opts ? opts._flags : self._options;\n  var basedir = defined(opts.basedir, this._options.basedir, process.cwd());\n  var order = self._transformOrder++;\n  self._pending++;\n  self._transformPending++;\n  var rec = {\n    transform: tr,\n    options: opts,\n    global: opts.global\n  };\n\n  if (typeof tr === 'string') {\n    var topts = {\n      basedir: basedir,\n      paths: (self._options.paths || []).map(function (p) {\n        return path.resolve(basedir, p);\n      })\n    };\n    resolve(tr, topts, function (err, res) {\n      if (err) return self.emit('error', err);\n      rec.transform = res;\n      resolved();\n    });\n  } else process.nextTick(resolved);\n\n  return this;\n};\n\nBrowserify.prototype.plugin = function (p, opts) {\n  if (isarray(p)) {\n    opts = p[1];\n    p = p[0];\n  }\n\n  if (!opts) opts = {};\n  var basedir = defined(opts.basedir, this._options.basedir, process.cwd());\n\n  if (typeof p === 'function') {\n    p(this, opts);\n  } else {\n    var pfile = resolve.sync(String(p), {\n      basedir: basedir\n    });\n\n    var f = require(pfile);\n\n    if (typeof f !== 'function') {\n      throw new Error('plugin ' + p + ' should export a function');\n    }\n\n    f(this, opts);\n  }\n\n  return this;\n};\n\nBrowserify.prototype._createPipeline = function (opts) {\n  var self = this;\n  if (!opts) opts = {};\n  this._mdeps = this._createDeps(opts);\n\n  this._mdeps.on('file', function (file, id) {\n    pipeline.emit('file', file, id);\n    self.emit('file', file, id);\n  });\n\n  this._mdeps.on('package', function (pkg) {\n    pipeline.emit('package', pkg);\n    self.emit('package', pkg);\n  });\n\n  this._mdeps.on('transform', function (tr, file) {\n    pipeline.emit('transform', tr, file);\n    self.emit('transform', tr, file);\n  });\n\n  var dopts = {\n    index: !opts.fullPaths && !opts.exposeAll,\n    dedupe: true,\n    expose: this._expose\n  };\n  this._bpack = bpack(xtend(opts, {\n    raw: true\n  }));\n  var pipeline = splicer.obj(['record', [this._recorder()], 'deps', [this._mdeps], 'json', [this._json()], 'unbom', [this._unbom()], 'unshebang', [this._unshebang()], 'syntax', [this._syntax()], 'sort', [depsSort(dopts)], 'dedupe', [this._dedupe()], 'label', [this._label(opts)], 'emit-deps', [this._emitDeps()], 'debug', [this._debug(opts)], 'pack', [this._bpack], 'wrap', []]);\n\n  if (opts.exposeAll) {\n    var basedir = defined(opts.basedir, process.cwd());\n    pipeline.get('deps').push(through.obj(function (row, enc, next) {\n      if (self._external.indexOf(row.id) >= 0) return next();\n      if (self._external.indexOf(row.file) >= 0) return next();\n\n      if (isAbsolutePath(row.id)) {\n        row.id = '/' + path.relative(basedir, row.file);\n      }\n\n      Object.keys(row.deps || {}).forEach(function (key) {\n        row.deps[key] = '/' + path.relative(basedir, row.deps[key]);\n      });\n      this.push(row);\n      next();\n    }));\n  }\n\n  return pipeline;\n};\n\nBrowserify.prototype._createDeps = function (opts) {\n  var self = this;\n  var mopts = xtend(opts);\n  var basedir = defined(opts.basedir, process.cwd()); // Let mdeps populate these values since it will be resolving file paths\n  // anyway.\n\n  mopts.expose = this._expose;\n  mopts.extensions = ['.js', '.json'].concat(mopts.extensions || []);\n  self._extensions = mopts.extensions;\n  mopts.transform = [];\n  mopts.transformKey = ['browserify', 'transform'];\n\n  mopts.postFilter = function (id, file, pkg) {\n    if (opts.postFilter && !opts.postFilter(id, file, pkg)) return false;\n    if (self._external.indexOf(file) >= 0) return false;\n    if (self._exclude.indexOf(file) >= 0) return false; //filter transforms on module dependencies\n\n    if (pkg && pkg.browserify && pkg.browserify.transform) {\n      //In edge cases it may be a string\n      pkg.browserify.transform = [].concat(pkg.browserify.transform).filter(Boolean).filter(self._filterTransform);\n    }\n\n    return true;\n  };\n\n  mopts.filter = function (id) {\n    if (opts.filter && !opts.filter(id)) return false;\n    if (self._external.indexOf(id) >= 0) return false;\n    if (self._exclude.indexOf(id) >= 0) return false;\n\n    if (opts.bundleExternal === false && isExternalModule(id)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  mopts.resolve = function (id, parent, cb) {\n    if (self._ignore.indexOf(id) >= 0) return cb(null, paths.empty, {});\n\n    self._bresolve(id, parent, function (err, file, pkg) {\n      if (file && self._ignore.indexOf(file) >= 0) {\n        return cb(null, paths.empty, {});\n      }\n\n      if (file && self._ignore.length) {\n        var nm = file.split('/node_modules/')[1];\n\n        if (nm) {\n          nm = nm.split('/')[0];\n\n          if (self._ignore.indexOf(nm) >= 0) {\n            return cb(null, paths.empty, {});\n          }\n        }\n      }\n\n      if (file) {\n        var ex = '/' + path.relative(basedir, file);\n\n        if (self._external.indexOf(ex) >= 0) {\n          return cb(null, ex);\n        }\n\n        if (self._exclude.indexOf(ex) >= 0) {\n          return cb(null, ex);\n        }\n\n        if (self._ignore.indexOf(ex) >= 0) {\n          return cb(null, paths.empty, {});\n        }\n      }\n\n      if (err) cb(err, file, pkg);else if (file) fs.realpath(file, function (err, res) {\n        cb(err, res, pkg, file);\n      });else cb(err, null, pkg);\n    });\n  };\n\n  if (opts.builtins === false) {\n    mopts.modules = {};\n\n    self._exclude.push.apply(self._exclude, Object.keys(builtins));\n  } else if (opts.builtins && isarray(opts.builtins)) {\n    mopts.modules = {};\n    opts.builtins.forEach(function (key) {\n      mopts.modules[key] = builtins[key];\n    });\n  } else if (opts.builtins && typeof opts.builtins === 'object') {\n    mopts.modules = opts.builtins;\n  } else mopts.modules = xtend(builtins);\n\n  Object.keys(builtins).forEach(function (key) {\n    if (!has(mopts.modules, key)) self._exclude.push(key);\n  });\n  mopts.globalTransform = [];\n\n  if (!this._bundled) {\n    this.once('bundle', function () {\n      self.pipeline.write({\n        transform: globalTr,\n        global: true,\n        options: {}\n      });\n    });\n  }\n\n  var no = [].concat(opts.noParse).filter(Boolean);\n  var absno = no.filter(function (x) {\n    return typeof x === 'string';\n  }).map(function (x) {\n    return path.resolve(basedir, x);\n  });\n\n  function globalTr(file) {\n    if (opts.detectGlobals === false) return through();\n    if (opts.noParse === true) return through();\n    if (no.indexOf(file) >= 0) return through();\n    if (absno.indexOf(file) >= 0) return through();\n    var parts = file.split('/node_modules/');\n\n    for (var i = 0; i < no.length; i++) {\n      if (typeof no[i] === 'function' && no[i](file)) {\n        return through();\n      } else if (no[i] === parts[parts.length - 1].split('/')[0]) {\n        return through();\n      } else if (no[i] === parts[parts.length - 1]) {\n        return through();\n      }\n    }\n\n    var vars = xtend({\n      process: function process() {\n        return \"require('_process')\";\n      }\n    }, opts.insertGlobalVars);\n\n    if (opts.bundleExternal === false) {\n      vars.process = undefined;\n      vars.buffer = undefined;\n    }\n\n    return insertGlobals(file, xtend(opts, {\n      debug: opts.debug,\n      always: opts.insertGlobals,\n      basedir: opts.commondir === false ? '/' : opts.basedir || process.cwd(),\n      vars: vars\n    }));\n  }\n\n  return mdeps(mopts);\n};\n\nBrowserify.prototype._recorder = function (opts) {\n  var self = this;\n  var ended = false;\n  this._recorded = [];\n\n  if (!this._ticked) {\n    process.nextTick(function () {\n      self._ticked = true;\n\n      self._recorded.forEach(function (row) {\n        stream.push(row);\n      });\n\n      if (ended) stream.push(null);\n    });\n  }\n\n  var stream = through.obj(write, end);\n  return stream;\n\n  function write(row, enc, next) {\n    self._recorded.push(row);\n\n    if (self._ticked) this.push(row);\n    next();\n  }\n\n  function end() {\n    ended = true;\n    if (self._ticked) this.push(null);\n  }\n};\n\nBrowserify.prototype._json = function () {\n  return through.obj(function (row, enc, next) {\n    if (/\\.json$/.test(row.file)) {\n      row.source = 'module.exports=' + sanitize(row.source);\n    }\n\n    this.push(row);\n    next();\n  });\n};\n\nBrowserify.prototype._unbom = function () {\n  return through.obj(function (row, enc, next) {\n    if (/^\\ufeff/.test(row.source)) {\n      row.source = row.source.replace(/^\\ufeff/, '');\n    }\n\n    this.push(row);\n    next();\n  });\n};\n\nBrowserify.prototype._unshebang = function () {\n  return through.obj(function (row, enc, next) {\n    if (/^#!/.test(row.source)) {\n      row.source = row.source.replace(/^#![^\\n]*\\n/, '');\n    }\n\n    this.push(row);\n    next();\n  });\n};\n\nBrowserify.prototype._syntax = function () {\n  var self = this;\n  return through.obj(function (row, enc, next) {\n    var h = shasum(row.source);\n\n    if (typeof self._syntaxCache[h] === 'undefined') {\n      var err = syntaxError(row.source, row.file || row.id);\n      if (err) return this.emit('error', err);\n      self._syntaxCache[h] = true;\n    }\n\n    this.push(row);\n    next();\n  });\n};\n\nBrowserify.prototype._dedupe = function () {\n  return through.obj(function (row, enc, next) {\n    if (!row.dedupeIndex && row.dedupe) {\n      row.source = 'arguments[4][' + JSON.stringify(row.dedupe) + '][0].apply(exports,arguments)';\n      row.nomap = true;\n    } else if (row.dedupeIndex) {\n      row.source = 'arguments[4][' + JSON.stringify(row.dedupeIndex) + '][0].apply(exports,arguments)';\n      row.nomap = true;\n    }\n\n    if (row.dedupeIndex && row.indexDeps) {\n      row.indexDeps.dup = row.dedupeIndex;\n    }\n\n    this.push(row);\n    next();\n  });\n};\n\nBrowserify.prototype._label = function (opts) {\n  var self = this;\n  var basedir = defined(opts.basedir, process.cwd());\n  return through.obj(function (row, enc, next) {\n    var prev = row.id;\n    if (self._external.indexOf(row.id) >= 0) return next();\n\n    if (self._external.indexOf('/' + path.relative(basedir, row.id)) >= 0) {\n      return next();\n    }\n\n    if (self._external.indexOf(row.file) >= 0) return next();\n    if (row.index) row.id = row.index;\n    self.emit('label', prev, row.id);\n    if (row.indexDeps) row.deps = row.indexDeps || {};\n    Object.keys(row.deps).forEach(function (key) {\n      if (self._expose[key]) {\n        row.deps[key] = key;\n        return;\n      }\n\n      var afile = path.resolve(path.dirname(row.file), key);\n      var rfile = '/' + path.relative(basedir, afile);\n\n      if (self._external.indexOf(rfile) >= 0) {\n        row.deps[key] = rfile;\n      }\n\n      if (self._external.indexOf(afile) >= 0) {\n        row.deps[key] = rfile;\n      }\n\n      if (self._external.indexOf(key) >= 0) {\n        row.deps[key] = key;\n        return;\n      }\n\n      for (var i = 0; i < self._extensions.length; i++) {\n        var ex = self._extensions[i];\n\n        if (self._external.indexOf(rfile + ex) >= 0) {\n          row.deps[key] = rfile + ex;\n          break;\n        }\n      }\n    });\n\n    if (row.entry || row.expose) {\n      self._bpack.standaloneModule = row.id;\n    }\n\n    this.push(row);\n    next();\n  });\n};\n\nBrowserify.prototype._emitDeps = function () {\n  var self = this;\n  return through.obj(function (row, enc, next) {\n    self.emit('dep', row);\n    this.push(row);\n    next();\n  });\n};\n\nBrowserify.prototype._debug = function (opts) {\n  var basedir = defined(opts.basedir, process.cwd());\n  return through.obj(function (row, enc, next) {\n    if (opts.debug) {\n      row.sourceRoot = 'file://localhost';\n      row.sourceFile = path.relative(basedir, row.file).replace(/\\\\/g, '/');\n    }\n\n    this.push(row);\n    next();\n  });\n};\n\nBrowserify.prototype.reset = function (opts) {\n  if (!opts) opts = {};\n  var hadExports = this._bpack.hasExports;\n  this.pipeline = this._createPipeline(xtend(opts, this._options));\n  this._bpack.hasExports = hadExports;\n  this._entryOrder = 0;\n  this._bundled = false;\n  this.emit('reset');\n};\n\nBrowserify.prototype.bundle = function (cb) {\n  var self = this;\n\n  if (cb && typeof cb === 'object') {\n    throw new Error('bundle() no longer accepts option arguments.\\n' + 'Move all option arguments to the browserify() constructor.');\n  }\n\n  if (this._bundled) {\n    var recorded = this._recorded;\n    this.reset();\n    recorded.forEach(function (x) {\n      self.pipeline.write(x);\n    });\n  }\n\n  var output = readonly(this.pipeline);\n\n  if (cb) {\n    output.on('error', cb);\n    output.pipe(concat(function (body) {\n      cb(null, body);\n    }));\n  }\n\n  function ready() {\n    self.emit('bundle', output);\n    self.pipeline.end();\n  }\n\n  if (this._pending === 0) ready();else this.once('_ready', ready);\n  this._bundled = true;\n  return output;\n};\n\nfunction isStream(s) {\n  return s && typeof s.pipe === 'function';\n}\n\nfunction isAbsolutePath(file) {\n  var regexp = process.platform === 'win32' ? /^\\w:/ : /^\\//;\n  return regexp.test(file);\n}\n\nfunction isExternalModule(file) {\n  var regexp = process.platform === 'win32' ? /^(\\.|\\w:)/ : /^[\\/.]/;\n  return !regexp.test(file);\n}","map":null,"metadata":{},"sourceType":"script"}