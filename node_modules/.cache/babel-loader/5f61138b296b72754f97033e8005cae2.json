{"ast":null,"code":"module.exports = function popper() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$tests = _ref.tests,\n      tests = _ref$tests === void 0 ? 'browserify test.js' : _ref$tests,\n      _ref$farm = _ref.farm,\n      farm = _ref$farm === void 0 ? 'browserstack' : _ref$farm,\n      _ref$notunnel = _ref.notunnel,\n      notunnel = _ref$notunnel === void 0 ? false : _ref$notunnel,\n      _ref$runner = _ref.runner,\n      runner = _ref$runner === void 0 ? 'mocha' : _ref$runner,\n      _ref$browsers = _ref.browsers,\n      browsers = _ref$browsers === void 0 ? [] : _ref$browsers,\n      _ref$globals = _ref.globals,\n      globals = _ref$globals === void 0 ? '' : _ref$globals,\n      _ref$port = _ref.port,\n      port = _ref$port === void 0 ? 1945 : _ref$port,\n      _ref$watch = _ref.watch,\n      watch = _ref$watch === void 0 ? '.' : _ref$watch,\n      _ref$opts = _ref.opts,\n      opts = _ref$opts === void 0 ? {} : _ref$opts,\n      timeout = _ref.timeout,\n      ripple = _ref.ripple;\n\n  // defaults\n  var wait = debounce(timeout = timeout || +env.POPPER_TIMEOUT || 20000)(quit),\n      maxRetries = 3;\n  ripple = (ripple || rijs)(extend({\n    dir: dir,\n    port: port\n  })(opts));\n  resdir(ripple, dir);\n  browsers = browsers.map(canonical(farm)).filter(Boolean); // define data resources\n\n  ripple('results', {}, {\n    from: from\n  });\n  ripple('totals', {}); // watch files\n\n  if (!isCI && watch) {\n    log('watching', watch);\n    chokidar.watch(watch, {\n      ignored: [/^\\.(.*)[^\\/\\\\]/, /[\\/\\\\]\\./, /node_modules(.+)popper/],\n      ignoreInitial: true,\n      usePolling: false,\n      depth: 5\n    }).on('change', debounce(generate));\n  } // icons\n\n\n  ripple(require('browser-icons')); // limit dashboard resources\n\n  ripple.to = limit(ripple.to); // proxy errors and register agent details\n\n  ripple.server.on('connected', connected); // serve assets\n\n  ripple.server.express.use(compression()).use('/utilise.min.js', send(local('utilise', 'utilise.min.js'))).use('/utilise.js', send(local('utilise', 'utilise.js'))).use('/mocha.css', send(local('mocha', 'mocha.css'))).use('/mocha.js', send(local('mocha', 'mocha.js'))).use('/chai.js', send(local('chai', 'chai.js'))).use('/dashboard/:id', send(local(\"./client/\".concat(runner, \"/logs.html\")))).use('/dashboard', send(local('./client/dashboard.html'))).use('/', serve(local('./client'))).use('/', index());\n  return generate(), spawn(), ripple;\n\n  function index() {\n    var head = is.arr(globals) ? globals.join('\\n') : globals,\n        html = file(local(\"./client/\".concat(runner, \"/index.html\"))).replace('<!-- { extra scripts } -->', head || '');\n    return function (req, res) {\n      return res.send(html);\n    };\n  }\n\n  function generate() {\n    log('generating tests');\n    var bundle = write(local('./client/tests.js')),\n        stream = is.fn(tests) ? tests() : run('sh', ['-c', tests], {\n      stdio: 'pipe'\n    });\n    if (stream.stderr) stream.stderr.pipe(process.stderr);\n    ((stream.stdout || stream).on('end', debounce(500)(reload)).pipe(bundle).flow || noop)();\n  }\n\n  function from(req) {\n    return req.data.type == 'RERUN' ? reload(req.data.value) : req.data.type == 'SAVE' ? save(req.socket.platform, req.data.value) : false;\n  }\n\n  function save(platform, result) {\n    var uid = platform.uid,\n        results = ripple('results'),\n        retries = uid in results ? results[uid].retries : 0;\n    log('received result from', uid);\n    result.platform = platform;\n    result.retries = retries;\n    update(uid, result)(ripple('results'));\n    totals();\n    ci(result);\n  }\n\n  function ci(r) {\n    if (!isCI || r.stats.running) return;\n    var browser = browsers.filter(function (d) {\n      if (d._name && d._name !== r.platform.name) return false;\n      if (d._version && d._version !== r.platform.version) return false;\n      if (d._os && d._os !== r.platform.os.name) return false;\n      if (d._os_version && d._os_version !== r.platform.os.version) return false;\n      return true;\n    }).pop();\n    if (!browser) return log('result not in matrix'.red, r.platform.uid);\n    browser.passed_by = r.platform.uid;\n    browser.passed = !r.stats.failures;\n    browser.passed ? log('browser passed:', r.platform.uid.green.bold) : err('browser failed:', r.platform.uid.red.bold);\n    if (!browser.passed && r.retries < maxRetries) return log('retrying'.yellow, r.platform.uid, ++r.retries, '/', str(maxRetries).grey), reload(r.platform.uid);\n    if (farms[farm].status) farms[farm].status(browser, r.platform);\n    var target = browsers.length,\n        passed = browsers.filter(by('passed')).length,\n        finished = browsers.filter(by('passed_by')).length;\n    log('ci targets', str(passed).green.bold, '/', str(target).grey);\n    target === passed ? time(3000, function (d) {\n      return process.exit(0);\n    }) : target === finished ? time(3000, function (d) {\n      return !env.POPPER_TIMEOUT && process.exit(1);\n    }) : wait();\n  }\n\n  function connected(socket) {\n    socket.platform = parse(socket);\n    socket.type = socket.handshake.url == '/dashboard' ? 'dashboard' : 'agent';\n    log('connected', socket.platform.uid.green, socket.type.grey);\n    socket.on('global err', function (message, url, linenumber) {\n      return err('Global error: ', socket.platform.uid.bold, message, url, linenumber);\n    });\n    if (debug) socket.on('console', function () {\n      log(socket.platform.uid.bold, 'says:', '', arguments[0], to.arr(arguments[1]).map(str).join(' '));\n    });\n  }\n\n  function quit() {\n    log('no updates received for', timeout / 1000, 'seconds. timing out..');\n    process.exit(1);\n  }\n\n  function reload(uid) {\n    var uids = uid ? [uid] : ripple.server.ws.sockets.map(function (d) {\n      return d.platform.uid;\n    });\n    uids.map(function (uid) {\n      return update(\"\".concat(uid, \".stats.running\"), true)(ripple('results'));\n    });\n    var agents = ripple.server.ws.sockets.filter(not(by('handshake.url', '/dashboard'))).filter(by('platform.uid', is.in(uids))).map(emitReload).length;\n    log('reloading', str(agents).cyan, 'agents', uid || '');\n  }\n\n  function totals() {\n    var res = values(ripple('results'));\n    return ripple('totals', {\n      tests: str(res.map(key('stats.tests')).filter(Boolean).pop() || '?'),\n      browsers: str(res.length),\n      passing: str(res.map(key('stats.failures')).filter(is(0)).length || '0')\n    });\n  }\n\n  function spawn() {\n    ripple.server.once('listening').then(function () {\n      log('running on port', ripple.server.http.address().port);\n      !notunnel && require('ngrok').connect(ripple.server.http.address().port, function (e, url) {\n        log('tunnelling', url && url.magenta);\n        return e ? err('error setting up reverse tunnel', e.stack) : browsers.map(boot(farm)(url));\n      });\n    });\n  }\n};\n\nvar _require = require('utilise/pure'),\n    values = _require.values,\n    key = _require.key,\n    str = _require.str,\n    not = _require.not,\n    by = _require.by,\n    grep = _require.grep,\n    lo = _require.lo,\n    is = _require.is,\n    debounce = _require.debounce,\n    extend = _require.extend,\n    falsy = _require.falsy,\n    send = _require.send,\n    file = _require.file,\n    noop = _require.noop,\n    update = _require.update,\n    identity = _require.identity,\n    time = _require.time,\n    includes = _require.includes,\n    write = require('fs').createWriteStream,\n    run = require('child_process').spawn,\n    _require2 = require('cryonic'),\n    stringify = _require2.stringify,\n    _require3 = require('path'),\n    resolve = _require3.resolve,\n    compression = require('compression'),\n    browserify = require('browserify'),\n    platform = require('platform'),\n    chokidar = require('chokidar'),\n    express = require('express'),\n    resdir = require('rijs.resdir'),\n    serve = require('serve-static'),\n    farms = require('./farms'),\n    wd = require('wd'),\n    rijs = function rijs(opts) {\n  return require('rijs.npm')(require('rijs')(opts));\n};\n\nvar log = require('utilise/log')('[popper]'),\n    err = require('utilise/err')('[popper]'),\n    old = grep(console, 'log', /^(?!.*\\[ri\\/)/),\n    env = process.env,\n    dir = __dirname,\n    isCI = env.CI === 'true',\n    debug = lo(env.NODE_ENV) == 'debug';\n\nvar heartbeat = function heartbeat(vm) {\n  return setInterval(function (d) {\n    return vm.eval('', function (e) {\n      if (e) console.error(e);\n    });\n  }, 30000);\n};\n\nvar canonical = function canonical(farm) {\n  return function (browser) {\n    return is.str(browser) ? farms[farm].browsers[browser] : browser;\n  };\n};\n\nvar local = function local(module, file) {\n  var base = !file ? __dirname : require.resolve(module),\n      read = !file ? module : '../' + file;\n  return resolve(base, read);\n};\n\nvar emitReload = function emitReload(socket) {\n  return socket.send(stringify({\n    data: {\n      exec: function exec() {\n        return location.reload();\n      }\n    }\n  }));\n};\n\nvar parse = function parse(socket) {\n  var ua = socket.handshake.headers['user-agent'],\n      p = platform.parse(ua),\n      o = {\n    name: lo(p.name),\n    version: major(p.version),\n    os: {\n      name: lo(p.os.family.split(' ').shift()),\n      version: major(p.os.version, p.os.family)\n    }\n  };\n  if (o.os.name == 'os') o.os.name = 'osx';\n  if (o.name == 'chrome mobile') o.name = 'chrome';\n  if (o.name == 'microsoft edge') o.name = 'ie';\n  var uid = o.name + '-' + o.version + '-' + o.os.name + '-' + o.os.version;\n  o.uid = uid;\n  return o;\n};\n\nvar major = function major(v, f) {\n  return v ? v.split('.').shift() : includes('xp')(lo(f)) ? 'xp' : '?';\n};\n\nvar limit = function limit(next) {\n  return function (req, socket) {\n    return socket.handshake.url == '/dashboard' ? next(req, socket) : false;\n  };\n};\n\nvar boot = function boot(farm) {\n  return function (url) {\n    return function (opts) {\n      var _opts$_name = opts._name,\n          _name = _opts$_name === void 0 ? '?' : _opts$_name,\n          _opts$_version = opts._version,\n          _version = _opts$_version === void 0 ? '?' : _opts$_version,\n          _opts$_os = opts._os,\n          _os = _opts$_os === void 0 ? '?' : _opts$_os,\n          _farms$farm = farms[farm],\n          connect = _farms$farm.connect,\n          _farms$farm$parse = _farms$farm.parse,\n          parse = _farms$farm$parse === void 0 ? identity : _farms$farm$parse,\n          id = \"\".concat(_name.cyan, \" \").concat(_version.cyan, \" on \").concat(_os),\n          vm = opts.vm = connect(wd);\n\n      if (!vm) err('failed to connect to ' + farm), process.exit(1);\n      log(\"booting up \".concat(id));\n      vm.init(parse(opts), function (e) {\n        if (e) return err(e, id);\n        log('initialised', id);\n        vm.get(url, function (e) {\n          if (e) return err(e, id);\n          log('opened to test page', id.cyan);\n          heartbeat(vm);\n        });\n      });\n    };\n  };\n};","map":null,"metadata":{},"sourceType":"script"}