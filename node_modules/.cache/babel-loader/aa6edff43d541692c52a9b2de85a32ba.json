{"ast":null,"code":"var Args = require(\"vargs\").Constructor,\n    _ = require('lodash'),\n    url = require('url'),\n    JSONWIRE_ERRORS = require('./jsonwire-errors.js');\n\nvar varargs = exports.varargs = function (args) {\n  var fargs = new Args(args); // returning undefined instead of empty callback\n\n  fargs.callback = fargs.callbackGiven() ? fargs.callback : undefined;\n  return fargs;\n}; // small helper to make sure we don't loose exceptions\n// use this instead of looking  the last argument manually\n\n\nexports.findCallback = function (_arguments) {\n  var fargs = varargs(_arguments);\n  return fargs.callback;\n}; // convert to type to something like ById, ByCssSelector, etc...\n\n\nvar STRAT_MAPPING = {\n  '-ios uiautomation': 'ByIosUIAutomation',\n  '-android uiautomator': 'ByAndroidUIAutomator',\n  '-android datamatcher': 'ByAndroidDataMatcher',\n  '-ios class chain': 'ByIosClassChain',\n  '-ios predicate string': 'ByIosPredicateString',\n  '-image': 'ByImage',\n  '-custom': 'ByCustom'\n};\n\nexports.elFuncSuffix = function (type) {\n  var suffix = STRAT_MAPPING[type];\n\n  if (!suffix) {\n    suffix = (' by ' + type).replace(/(\\s[a-z])/g, function ($1) {\n      return $1.toUpperCase().replace(' ', '');\n    }).replace('Xpath', 'XPath');\n  }\n\n  return suffix;\n}; // return correct jsonwire type\n\n\nexports.elFuncFullType = function (type) {\n  if (type === 'css') {\n    return 'css selector';\n  } // shortcut for css\n\n\n  return type;\n}; // from JsonWire spec + shortcuts + mobile JsonWire spec\n\n\nexports.elementFuncTypes = ['class name', 'css selector', 'id', 'name', 'link text', 'partial link text', 'tag name', 'xpath', 'css', '-ios uiautomation', '-android uiautomator', 'accessibility id', '-ios class chain', '-ios predicate string', '-image', '-custom', '-android datamatcher']; // chai-as-promised promisifier\n// just adding the core method for the sake of safety.\\\n// if you need more than that, build your custom promisifier\n\nvar Q_CORE_METHODS = [// core methods:\n\"then\", \"catch\", \"fail\", \"progress\", \"finally\", \"fin\", \"done\", \"thenResolve\", \"thenReject\", \"nodeify\"];\n\nexports.transferPromiseness = function (assertion, promise) {\n  _(Q_CORE_METHODS).each(function (methodName) {\n    if (promise[methodName]) {\n      if (assertion._obj) {\n        assertion._obj[methodName] = promise[methodName].bind(promise);\n      }\n\n      assertion[methodName] = promise[methodName].bind(promise);\n    }\n  });\n\n  if (promise._enrich) {\n    if (assertion._obj) {\n      promise._enrich(assertion._obj);\n    }\n\n    promise._enrich(assertion);\n  }\n}; // promise detection\n\n\nexports.isPromise = function (x) {\n  return (typeof x === \"object\" || typeof x === \"function\") && x !== null && typeof x.then === \"function\";\n};\n\nexports.deprecator = {\n  deprecationMessageShown: {},\n  warnDeprecated: true,\n  showHideDeprecation: function showHideDeprecation(status) {\n    if (status !== undefined) {\n      this.warnDeprecated = status;\n    } else {\n      this.warnDeprecated = !this.warnDeprecated;\n    }\n  },\n  warn: function warn(cat, message) {\n    if (this.warnDeprecated && !this.deprecationMessageShown[cat]) {\n      this.deprecationMessageShown[cat] = 1;\n      console.warn(message);\n    }\n  }\n}; // Android doesn't like cariage return\n\nexports.inlineJs = function (script) {\n  return script.replace(/[\\r\\n]/g, '').trim();\n};\n\nexports.resolveUrl = function (from, to) {\n  if (typeof from === 'object') {\n    from = url.format(from);\n  } // making sure the last part of the path doesn't get stripped\n\n\n  if (!from.match(/\\/$/)) {\n    from += '/';\n  }\n\n  return url.parse(url.resolve(from, to));\n};\n\nexports.strip = function strip(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n\n  var x = [];\n\n  _(str.length).times(function (i) {\n    if (str.charCodeAt(i)) {\n      x.push(str.charAt(i));\n    }\n  });\n\n  return x.join('');\n};\n\nvar trimToLength = function trimToLength(str, length) {\n  return str && str.length > length ? str.substring(0, length) + '...' : str;\n};\n\nexports.trimToLength = trimToLength;\n\nexports.niceArgs = function (args) {\n  return JSON.stringify(args).replace(/^\\[/, '(').replace(/\\]$/, ')');\n};\n\nexports.niceResp = function (args) {\n  return JSON.stringify(args).replace(/^\\[/, '').replace(/\\]$/, '');\n}; // convert code to string before execution\n\n\nexports.codeToString = function (code) {\n  if (typeof code === 'function') {\n    code = 'return (' + code + ').apply(null, arguments);';\n  }\n\n  return code;\n};\n\nvar MAX_ERROR_LENGTH = 500;\n\nexports.newError = function (opts) {\n  var err = new Error();\n\n  _.each(opts, function (opt, k) {\n    err[k] = opt;\n  }); // nicer error output\n\n\n  err.inspect = function () {\n    var jsonStr = JSON.stringify(err);\n    return trimToLength(jsonStr, MAX_ERROR_LENGTH);\n  };\n\n  return err;\n};\n\nexports.isWebDriverException = function (res) {\n  return res && res.class && res.class.indexOf('WebDriverException') > 0;\n};\n\nexports.getJsonwireError = function (status) {\n  var jsonwireError = JSONWIRE_ERRORS.filter(function (err) {\n    return err.status === status;\n  });\n  return jsonwireError.length > 0 ? jsonwireError[0] : null;\n};\n/**\n * Prefix all unofficial capabilities. Prefix with `wd` by default\n * or with whatever is provided in `caps.w3cPrefix`\n */\n\n\nexports.prefixCapabilities = function (caps) {\n  var pairs = _.toPairs(caps);\n\n  var prefixedCaps = {};\n  var w3cCapabilities = ['browserName', 'browserVersion', 'platformName', 'acceptInsecureCerts', 'pageLoadStrategy', 'proxy', 'setWindowRect', 'timeouts', 'unhandledPromptBehavior'];\n  var prefix = caps.w3cPrefix || 'wd';\n\n  for (var i = 0; i < pairs.length; i++) {\n    var key = pairs[i][0];\n    var value = pairs[i][1]; // If an unsupported cap has no prefix, add one.\n\n    if (key.indexOf(':') < 0 && w3cCapabilities.indexOf(key) < 0) {\n      prefixedCaps[prefix + ':' + key] = value;\n    } else {\n      prefixedCaps[key] = value;\n    }\n  }\n\n  return prefixedCaps;\n};\n\nvar w3cElementKeyId = exports.w3cElementKeyId = \"element-6066-11e4-a52e-4f735466cecf\";\n\nexports.getElementId = function (obj) {\n  return _.isObject(obj) ? obj.ELEMENT || obj[w3cElementKeyId] : undefined;\n};","map":null,"metadata":{},"sourceType":"script"}