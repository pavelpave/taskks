{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar asyncEach = require('async-each');\n\nvar anymatch = require('anymatch');\n\nvar globParent = require('glob-parent');\n\nvar isGlob = require('is-glob');\n\nvar isAbsolute = require('path-is-absolute');\n\nvar inherits = require('inherits');\n\nvar braces = require('braces');\n\nvar normalizePath = require('normalize-path');\n\nvar upath = require('upath');\n\nvar NodeFsHandler = require('./lib/nodefs-handler');\n\nvar FsEventsHandler = require('./lib/fsevents-handler');\n\nvar arrify = function arrify(value) {\n  if (value == null) return [];\n  return Array.isArray(value) ? value : [value];\n};\n\nvar flatten = function flatten(list, result) {\n  if (result == null) result = [];\n  list.forEach(function (item) {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n}; // Little isString util for use in Array#every.\n\n\nvar isString = function isString(thing) {\n  return typeof thing === 'string';\n}; // Public: Main class.\n// Watches files & directories for changes.\n//\n// * _opts - object, chokidar options hash\n//\n// Emitted events:\n// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n//\n// Examples\n//\n//  var watcher = new FSWatcher()\n//    .add(directories)\n//    .on('add', path => console.log('File', path, 'was added'))\n//    .on('change', path => console.log('File', path, 'was changed'))\n//    .on('unlink', path => console.log('File', path, 'was removed'))\n//    .on('all', (event, path) => console.log(path, ' emitted ', event))\n//\n\n\nfunction FSWatcher(_opts) {\n  EventEmitter.call(this);\n  var opts = {}; // in case _opts that is passed in is a frozen object\n\n  if (_opts) for (var opt in _opts) {\n    opts[opt] = _opts[opt];\n  }\n  this._watched = Object.create(null);\n  this._closers = Object.create(null);\n  this._ignoredPaths = Object.create(null);\n  Object.defineProperty(this, '_globIgnored', {\n    get: function get() {\n      return Object.keys(this._ignoredPaths);\n    }\n  });\n  this.closed = false;\n  this._throttled = Object.create(null);\n  this._symlinkPaths = Object.create(null);\n\n  function undef(key) {\n    return opts[key] === undefined;\n  } // Set up default options.\n\n\n  if (undef('persistent')) opts.persistent = true;\n  if (undef('ignoreInitial')) opts.ignoreInitial = false;\n  if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef('interval')) opts.interval = 100;\n  if (undef('binaryInterval')) opts.binaryInterval = 300;\n  if (undef('disableGlobbing')) opts.disableGlobbing = false;\n  this.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n  if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n  if (!FsEventsHandler.canUse()) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs.watch.\n\n  if (undef('usePolling') && !opts.useFsEvents) {\n    opts.usePolling = process.platform === 'darwin';\n  } // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n\n\n  var envPoll = process.env.CHOKIDAR_USEPOLLING;\n\n  if (envPoll !== undefined) {\n    var envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n\n  var envInterval = process.env.CHOKIDAR_INTERVAL;\n\n  if (envInterval) {\n    opts.interval = parseInt(envInterval);\n  } // Editor atomic write normalization enabled by default with fs.watch\n\n\n  if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = Object.create(null);\n  if (undef('followSymlinks')) opts.followSymlinks = true;\n  if (undef('awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  var awf = opts.awaitWriteFinish;\n\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = Object.create(null);\n  }\n\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  this._isntIgnored = function (path, stat) {\n    return !this._isIgnored(path, stat);\n  }.bind(this);\n\n  var readyCalls = 0;\n\n  this._emitReady = function () {\n    if (++readyCalls >= this._readyCount) {\n      this._emitReady = Function.prototype;\n      this._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n      process.nextTick(this.emit.bind(this, 'ready'));\n    }\n  }.bind(this);\n\n  this.options = opts; // You’re frozen when your heart’s not open.\n\n  Object.freeze(opts);\n}\n\ninherits(FSWatcher, EventEmitter); // Common helpers\n// --------------\n// Private method: Normalize and emit events\n//\n// * event     - string, type of event\n// * path      - string, file or directory path\n// * val[1..3] - arguments to be passed with event\n//\n// Returns the error if defined, otherwise the value of the\n// FSWatcher instance's `closed` flag\n\nFSWatcher.prototype._emit = function (event, path, val1, val2, val3) {\n  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);\n  var args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n  var awf = this.options.awaitWriteFinish;\n\n  if (awf && this._pendingWrites[path]) {\n    this._pendingWrites[path].lastChange = new Date();\n    return this;\n  }\n\n  if (this.options.atomic) {\n    if (event === 'unlink') {\n      this._pendingUnlinks[path] = args;\n      setTimeout(function () {\n        Object.keys(this._pendingUnlinks).forEach(function (path) {\n          this.emit.apply(this, this._pendingUnlinks[path]);\n          this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));\n          delete this._pendingUnlinks[path];\n        }.bind(this));\n      }.bind(this), typeof this.options.atomic === \"number\" ? this.options.atomic : 100);\n      return this;\n    } else if (event === 'add' && this._pendingUnlinks[path]) {\n      event = args[0] = 'change';\n      delete this._pendingUnlinks[path];\n    }\n  }\n\n  var emitEvent = function () {\n    this.emit.apply(this, args);\n    if (event !== 'error') this.emit.apply(this, ['all'].concat(args));\n  }.bind(this);\n\n  if (awf && (event === 'add' || event === 'change') && this._readyEmitted) {\n    var awfEmit = function awfEmit(err, stats) {\n      if (err) {\n        event = args[0] = 'error';\n        args[1] = err;\n        emitEvent();\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n\n        emitEvent();\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n    return this;\n  }\n\n  if (event === 'change') {\n    if (!this._throttle('change', path, 50)) return this;\n  }\n\n  if (this.options.alwaysStat && val1 === undefined && (event === 'add' || event === 'addDir' || event === 'change')) {\n    var fullPath = this.options.cwd ? sysPath.join(this.options.cwd, path) : path;\n    fs.stat(fullPath, function (error, stats) {\n      // Suppress event when fs.stat fails, to avoid sending undefined 'stat'\n      if (error || !stats) return;\n      args.push(stats);\n      emitEvent();\n    });\n  } else {\n    emitEvent();\n  }\n\n  return this;\n}; // Private method: Common handler for errors\n//\n// * error  - object, Error instance\n//\n// Returns the error if defined, otherwise the value of the\n// FSWatcher instance's `closed` flag\n\n\nFSWatcher.prototype._handleError = function (error) {\n  var code = error && error.code;\n  var ipe = this.options.ignorePermissionErrors;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!ipe || code !== 'EPERM' && code !== 'EACCES')) this.emit('error', error);\n  return error || this.closed;\n}; // Private method: Helper utility for throttling\n//\n// * action  - string, type of action being throttled\n// * path    - string, path being acted upon\n// * timeout - int, duration of time to suppress duplicate actions\n//\n// Returns throttle tracking object or false if action should be suppressed\n\n\nFSWatcher.prototype._throttle = function (action, path, timeout) {\n  if (!(action in this._throttled)) {\n    this._throttled[action] = Object.create(null);\n  }\n\n  var throttled = this._throttled[action];\n\n  if (path in throttled) {\n    throttled[path].count++;\n    return false;\n  }\n\n  function clear() {\n    var count = throttled[path] ? throttled[path].count : 0;\n    delete throttled[path];\n    clearTimeout(timeoutObject);\n    return count;\n  }\n\n  var timeoutObject = setTimeout(clear, timeout);\n  throttled[path] = {\n    timeoutObject: timeoutObject,\n    clear: clear,\n    count: 0\n  };\n  return throttled[path];\n}; // Private method: Awaits write operation to finish\n//\n// * path    - string, path being acted upon\n// * threshold - int, time in milliseconds a file size must be fixed before\n//                    acknowledging write operation is finished\n// * awfEmit - function, to be called when ready for event to be emitted\n// Polls a newly created file for size variations. When files size does not\n// change for 'threshold' milliseconds calls callback.\n\n\nFSWatcher.prototype._awaitWriteFinish = function (path, threshold, event, awfEmit) {\n  var timeoutHandler;\n  var fullPath = path;\n\n  if (this.options.cwd && !isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  var now = new Date();\n\n  var awaitWriteFinish = function (prevStat) {\n    fs.stat(fullPath, function (err, curStat) {\n      if (err || !(path in this._pendingWrites)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      var now = new Date();\n\n      if (prevStat && curStat.size != prevStat.size) {\n        this._pendingWrites[path].lastChange = now;\n      }\n\n      if (now - this._pendingWrites[path].lastChange >= threshold) {\n        delete this._pendingWrites[path];\n        awfEmit(null, curStat);\n      } else {\n        timeoutHandler = setTimeout(awaitWriteFinish.bind(this, curStat), this.options.awaitWriteFinish.pollInterval);\n      }\n    }.bind(this));\n  }.bind(this);\n\n  if (!(path in this._pendingWrites)) {\n    this._pendingWrites[path] = {\n      lastChange: now,\n      cancelWait: function () {\n        delete this._pendingWrites[path];\n        clearTimeout(timeoutHandler);\n        return event;\n      }.bind(this)\n    };\n    timeoutHandler = setTimeout(awaitWriteFinish.bind(this), this.options.awaitWriteFinish.pollInterval);\n  }\n}; // Private method: Determines whether user has asked to ignore this path\n//\n// * path  - string, path to file or directory\n// * stats - object, result of fs.stat\n//\n// Returns boolean\n\n\nvar dotRe = /\\..*\\.(sw[px])$|\\~$|\\.subl.*\\.tmp/;\n\nFSWatcher.prototype._isIgnored = function (path, stats) {\n  if (this.options.atomic && dotRe.test(path)) return true;\n\n  if (!this._userIgnored) {\n    var cwd = this.options.cwd;\n    var ignored = this.options.ignored;\n\n    if (cwd && ignored) {\n      ignored = ignored.map(function (path) {\n        if (typeof path !== 'string') return path;\n        return upath.normalize(isAbsolute(path) ? path : sysPath.join(cwd, path));\n      });\n    }\n\n    var paths = arrify(ignored).filter(function (path) {\n      return typeof path === 'string' && !isGlob(path);\n    }).map(function (path) {\n      return path + '/**';\n    });\n    this._userIgnored = anymatch(this._globIgnored.concat(ignored).concat(paths));\n  }\n\n  return this._userIgnored([path, stats]);\n}; // Private method: Provides a set of common helpers and properties relating to\n// symlink and glob handling\n//\n// * path - string, file, directory, or glob pattern being watched\n// * depth - int, at any depth > 0, this isn't a glob\n//\n// Returns object containing helpers for this path\n\n\nvar replacerRe = /^\\.[\\/\\\\]/;\n\nFSWatcher.prototype._getWatchHelpers = function (path, depth) {\n  path = path.replace(replacerRe, '');\n  var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  var fullWatchPath = sysPath.resolve(watchPath);\n  var hasGlob = watchPath !== path;\n  var globFilter = hasGlob ? anymatch(path) : false;\n  var follow = this.options.followSymlinks;\n  var globSymlink = hasGlob && follow ? null : false;\n\n  var checkGlobSymlink = function checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === ''\n    if (globSymlink == null) {\n      globSymlink = entry.fullParentDir === fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: fullWatchPath\n      };\n    }\n\n    if (globSymlink) {\n      return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  };\n\n  var entryPath = function entryPath(entry) {\n    return sysPath.join(watchPath, sysPath.relative(watchPath, checkGlobSymlink(entry)));\n  };\n\n  var filterPath = function (entry) {\n    if (entry.stat && entry.stat.isSymbolicLink()) return filterDir(entry);\n    var resolvedPath = entryPath(entry);\n    return (!hasGlob || globFilter(resolvedPath)) && this._isntIgnored(resolvedPath, entry.stat) && (this.options.ignorePermissionErrors || this._hasReadPermissions(entry.stat));\n  }.bind(this);\n\n  var getDirParts = function getDirParts(path) {\n    if (!hasGlob) return false;\n    var parts = [];\n    var expandedPath = braces.expand(path);\n    expandedPath.forEach(function (path) {\n      parts.push(sysPath.relative(watchPath, path).split(/[\\/\\\\]/));\n    });\n    return parts;\n  };\n\n  var dirParts = getDirParts(path);\n\n  if (dirParts) {\n    dirParts.forEach(function (parts) {\n      if (parts.length > 1) parts.pop();\n    });\n  }\n\n  var unmatchedGlob;\n\n  var filterDir = function (entry) {\n    if (hasGlob) {\n      var entryParts = getDirParts(checkGlobSymlink(entry));\n      var globstar = false;\n      unmatchedGlob = !dirParts.some(function (parts) {\n        return parts.every(function (part, i) {\n          if (part === '**') globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i]);\n        });\n      });\n    }\n\n    return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);\n  }.bind(this);\n\n  return {\n    followSymlinks: follow,\n    statMethod: follow ? 'stat' : 'lstat',\n    path: path,\n    watchPath: watchPath,\n    entryPath: entryPath,\n    hasGlob: hasGlob,\n    globFilter: globFilter,\n    filterPath: filterPath,\n    filterDir: filterDir\n  };\n}; // Directory helpers\n// -----------------\n// Private method: Provides directory tracking objects\n//\n// * directory - string, path of the directory\n//\n// Returns the directory's tracking object\n\n\nFSWatcher.prototype._getWatchedDir = function (directory) {\n  var dir = sysPath.resolve(directory);\n\n  var watcherRemove = this._remove.bind(this);\n\n  if (!(dir in this._watched)) this._watched[dir] = {\n    _items: Object.create(null),\n    add: function add(item) {\n      if (item !== '.' && item !== '..') this._items[item] = true;\n    },\n    remove: function remove(item) {\n      delete this._items[item];\n\n      if (!this.children().length) {\n        fs.readdir(dir, function (err) {\n          if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));\n        });\n      }\n    },\n    has: function has(item) {\n      return item in this._items;\n    },\n    children: function children() {\n      return Object.keys(this._items);\n    }\n  };\n  return this._watched[dir];\n}; // File helpers\n// ------------\n// Private method: Check for read permissions\n// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405\n//\n// * stats - object, result of fs.stat\n//\n// Returns boolean\n\n\nFSWatcher.prototype._hasReadPermissions = function (stats) {\n  return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));\n}; // Private method: Handles emitting unlink events for\n// files and directories, and via recursion, for\n// files and directories within directories that are unlinked\n//\n// * directory - string, directory within which the following item is located\n// * item      - string, base path of item/directory\n//\n// Returns nothing\n\n\nFSWatcher.prototype._remove = function (directory, item) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  var path = sysPath.join(directory, item);\n  var fullPath = sysPath.resolve(path);\n  var isDirectory = this._watched[path] || this._watched[fullPath]; // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n\n  if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n  var watchedDirs = Object.keys(this._watched);\n\n  if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {\n    this.add(directory, item, true);\n  } // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n\n\n  var nestedDirectoryChildren = this._getWatchedDir(path).children(); // Recursively remove children directories / files.\n\n\n  nestedDirectoryChildren.forEach(function (nestedItem) {\n    this._remove(path, nestedItem);\n  }, this); // Check if item was on the watched list and remove it\n\n  var parent = this._getWatchedDir(directory);\n\n  var wasTracked = parent.has(item);\n  parent.remove(item); // If we wait for this file to be fully written, cancel the wait.\n\n  var relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\n  if (this.options.awaitWriteFinish && this._pendingWrites[relPath]) {\n    var event = this._pendingWrites[relPath].cancelWait();\n\n    if (event === 'add') return;\n  } // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n\n\n  delete this._watched[path];\n  delete this._watched[fullPath];\n  var eventName = isDirectory ? 'unlinkDir' : 'unlink';\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n};\n\nFSWatcher.prototype._closePath = function (path) {\n  if (!this._closers[path]) return;\n\n  this._closers[path]();\n\n  delete this._closers[path];\n\n  this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));\n}; // Public method: Adds paths to be watched on an existing FSWatcher instance\n// * paths     - string or array of strings, file/directory paths and/or globs\n// * _origAdd  - private boolean, for handling non-existent paths to be watched\n// * _internal - private boolean, indicates a non-user add\n// Returns an instance of FSWatcher for chaining.\n\n\nFSWatcher.prototype.add = function (paths, _origAdd, _internal) {\n  var disableGlobbing = this.options.disableGlobbing;\n  var cwd = this.options.cwd;\n  this.closed = false;\n  paths = flatten(arrify(paths));\n\n  if (!paths.every(isString)) {\n    throw new TypeError('Non-string provided as watch path: ' + paths);\n  }\n\n  if (cwd) paths = paths.map(function (path) {\n    var absPath;\n\n    if (isAbsolute(path)) {\n      absPath = path;\n    } else if (path[0] === '!') {\n      absPath = '!' + sysPath.join(cwd, path.substring(1));\n    } else {\n      absPath = sysPath.join(cwd, path);\n    } // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n\n    if (disableGlobbing || !isGlob(path)) {\n      return absPath;\n    } else {\n      return normalizePath(absPath);\n    }\n  }); // set aside negated glob strings\n\n  paths = paths.filter(function (path) {\n    if (path[0] === '!') {\n      this._ignoredPaths[path.substring(1)] = true;\n    } else {\n      // if a path is being added that was previously ignored, stop ignoring it\n      delete this._ignoredPaths[path];\n      delete this._ignoredPaths[path + '/**']; // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n      this._userIgnored = null;\n      return true;\n    }\n  }, this);\n\n  if (this.options.useFsEvents && FsEventsHandler.canUse()) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach(this._addToFsEvents, this);\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    asyncEach(paths, function (path, next) {\n      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function (err, res) {\n        if (res) this._emitReady();\n        next(err, res);\n      }.bind(this));\n    }.bind(this), function (error, results) {\n      results.forEach(function (item) {\n        if (!item || this.closed) return;\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      }, this);\n    }.bind(this));\n  }\n\n  return this;\n}; // Public method: Close watchers or start ignoring events from specified paths.\n// * paths     - string or array of strings, file/directory paths and/or globs\n// Returns instance of FSWatcher for chaining.\n\n\nFSWatcher.prototype.unwatch = function (paths) {\n  if (this.closed) return this;\n  paths = flatten(arrify(paths));\n  paths.forEach(function (path) {\n    // convert to absolute path unless relative path already matches\n    if (!isAbsolute(path) && !this._closers[path]) {\n      if (this.options.cwd) path = sysPath.join(this.options.cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths[path] = true;\n\n    if (path in this._watched) {\n      this._ignoredPaths[path + '/**'] = true;\n    } // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n\n\n    this._userIgnored = null;\n  }, this);\n  return this;\n}; // Public method: Close watchers and remove all listeners from watched paths.\n// Returns instance of FSWatcher for chaining.\n\n\nFSWatcher.prototype.close = function () {\n  if (this.closed) return this;\n  this.closed = true;\n  Object.keys(this._closers).forEach(function (watchPath) {\n    this._closers[watchPath]();\n\n    delete this._closers[watchPath];\n  }, this);\n  this._watched = Object.create(null);\n  this.removeAllListeners();\n  return this;\n}; // Public method: Expose list of watched paths\n// Returns object w/ dir paths as keys and arrays of contained paths as values.\n\n\nFSWatcher.prototype.getWatched = function () {\n  var watchList = {};\n  Object.keys(this._watched).forEach(function (dir) {\n    var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || '.'] = Object.keys(this._watched[dir]._items).sort();\n  }.bind(this));\n  return watchList;\n}; // Attach watch handler prototype methods\n\n\nfunction importHandler(handler) {\n  Object.keys(handler.prototype).forEach(function (method) {\n    FSWatcher.prototype[method] = handler.prototype[method];\n  });\n}\n\nimportHandler(NodeFsHandler);\nif (FsEventsHandler.canUse()) importHandler(FsEventsHandler); // Export FSWatcher class\n\nexports.FSWatcher = FSWatcher; // Public function: Instantiates watcher with paths to be tracked.\n// * paths     - string or array of strings, file/directory paths and/or globs\n// * options   - object, chokidar options\n// Returns an instance of FSWatcher for chaining.\n\nexports.watch = function (paths, options) {\n  return new FSWatcher(options).add(paths);\n};","map":null,"metadata":{},"sourceType":"script"}