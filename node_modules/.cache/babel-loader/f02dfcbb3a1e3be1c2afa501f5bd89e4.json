{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/garpix/task_react_App/myapp/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/garpix/task_react_App/myapp/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\n// -------------------------------------------\n// Loads resources from the /resources folder\n// -------------------------------------------\n// TODO: rename loader\nmodule.exports = function loader(ripple) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$dir = _ref.dir,\n      dir = _ref$dir === void 0 ? '.' : _ref$dir,\n      _ref$watch = _ref.watch,\n      watch = _ref$watch === void 0 ? isNonProd() : _ref$watch,\n      _ref$pattern = _ref.pattern,\n      pattern = _ref$pattern === void 0 ? '/**/!(*test).{css,js}' : _ref$pattern,\n      _ref$autoload = _ref.autoload,\n      autoload = _ref$autoload === void 0 ? 'resources' : _ref$autoload,\n      _ref$autolink = _ref.autolink,\n      autolink = _ref$autolink === void 0 ? '/resources/components/**/!(*test).{css,js}' : _ref$autolink,\n      _ref$aliases = _ref.aliases,\n      aliases = _ref$aliases === void 0 ? {} : _ref$aliases;\n\n  log('creating', {\n    watch: watch\n  });\n  glob(autolink, {\n    root: dir\n  }).map(function (path) {\n    return ripple.link(rel(dir, path), rtype(ripple, path).shortname(path));\n  });\n\n  var _require = require('minimist')(process.argv.slice(2)),\n      _require$r = _require.r,\n      r = _require$r === void 0 ? '' : _require$r,\n      _require$resdirs = _require.resdirs,\n      resdirs = _require$resdirs === void 0 ? r : _require$resdirs,\n      load = register(ripple, dir),\n      folders = resdirs.split(',').concat(resolve(dir, autoload)).filter(Boolean).map(function (d) {\n    return resolve(d);\n  }).map(append(pattern));\n\n  ripple.watcher = chokidar.watch(folders, {\n    ignored: /\\b_/\n  }).on('error', err).on('add', load).on('change', load).on('ready',\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!watch) ripple.watcher.close();\n            _context.next = 3;\n            return Promise.all(values(ripple.resources).map(function (res) {\n              return res.headers.loading;\n            })).catch(err);\n\n          case 3:\n            def(ripple, 'ready', true);\n            ripple.emit('ready');\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n\n  ripple.load = function (name, alias) {\n    if (ripple.resources[name]) return ripple.resources[name];\n    var path = bresolve(ripple.aliases.dst[name] || name, resolve(dir, 'foo')),\n        canonical = rel(dir, path);\n\n    if (alias) {\n      ripple.link(canonical, alias);\n    } else if (!ripple.aliases.dst[name] && name != canonical) {\n      ripple.link(name, canonical);\n    }\n\n    return load(path);\n  }; // TODO: move back to core as chainable \n\n\n  ripple.resource = function (name, body, headers) {\n    // is.str(body)\n    //   ? ripple.load(body, name)\n    ripple(name, body, headers);\n    return ripple;\n  };\n\n  return ripple;\n};\n\nvar register = function register(ripple, dir) {\n  return function (path) {\n    var type = rtype(ripple, path);\n    if (!exists(path)) throw new Error(\"no such resource at \".concat(path));\n    if (!type) throw new Error(\"could not understand how to load resource at \".concat(path)); // TODO: should probably let loaders do this\n\n    delete require.cache[path];\n    return type.load({\n      name: rel(dir, path),\n      headers: {\n        path: path\n      }\n    });\n  };\n};\n\nvar rtype = function rtype(ripple, path) {\n  return values(ripple.types).filter(function (d) {\n    return d.ext;\n  }).sort(za('ext.length')).find(function (_ref3) {\n    var ext = _ref3.ext;\n    return minimatch(basename(path), ext);\n  });\n};\n\nvar rel = function rel(dir, path) {\n  return './' + relative(dir, path).replace(/\\\\/g, '/');\n};\n\nvar bresolve = function bresolve(module, parent) {\n  return require('browser-resolve').sync(module, {\n    filename: parent\n  });\n};\n\nfunction isNonProd() {\n  return lo(process.env.NODE_ENV) != 'prod' && lo(process.env.NODE_ENV) != 'production';\n}\n\nvar _require2 = require('path'),\n    resolve = _require2.resolve,\n    relative = _require2.relative,\n    basename = _require2.basename,\n    exists = require('fs').existsSync,\n    glob = require('glob').sync,\n    chokidar = require('chokidar'),\n    append = require('utilise/append'),\n    values = require('utilise/values'),\n    keys = require('utilise/keys'),\n    def = require('utilise/def'),\n    key = require('utilise/key'),\n    is = require('utilise/is'),\n    lo = require('utilise/lo'),\n    by = require('utilise/by'),\n    za = require('utilise/za'),\n    log = require('utilise/log')('[ri/resdir]'),\n    err = require('utilise/err')('[ri/resdir]'),\n    minimatch = require('minimatch'),\n    extname = function extname(path) {\n  return [''].concat(path.split('.').slice(1)).join('.');\n};","map":null,"metadata":{},"sourceType":"script"}