{"ast":null,"code":"/*!\n * compression\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module dependencies.\n * @private\n */\n\nvar accepts = require('accepts');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar bytes = require('bytes');\n\nvar compressible = require('compressible');\n\nvar debug = require('debug')('compression');\n\nvar onHeaders = require('on-headers');\n\nvar vary = require('vary');\n\nvar zlib = require('zlib');\n/**\n * Module exports.\n */\n\n\nmodule.exports = compression;\nmodule.exports.filter = shouldCompress;\n/**\n * Module variables.\n * @private\n */\n\nvar cacheControlNoTransformRegExp = /(?:^|,)\\s*?no-transform\\s*?(?:,|$)/;\n/**\n * Compress response data with gzip / deflate.\n *\n * @param {Object} [options]\n * @return {Function} middleware\n * @public\n */\n\nfunction compression(options) {\n  var opts = options || {}; // options\n\n  var filter = opts.filter || shouldCompress;\n  var threshold = bytes.parse(opts.threshold);\n\n  if (threshold == null) {\n    threshold = 1024;\n  }\n\n  return function compression(req, res, next) {\n    var ended = false;\n    var length;\n    var listeners = [];\n    var stream;\n    var _end = res.end;\n    var _on = res.on;\n    var _write = res.write; // flush\n\n    res.flush = function flush() {\n      if (stream) {\n        stream.flush();\n      }\n    }; // proxy\n\n\n    res.write = function write(chunk, encoding) {\n      if (ended) {\n        return false;\n      }\n\n      if (!this._header) {\n        this._implicitHeader();\n      }\n\n      return stream ? stream.write(toBuffer(chunk, encoding)) : _write.call(this, chunk, encoding);\n    };\n\n    res.end = function end(chunk, encoding) {\n      if (ended) {\n        return false;\n      }\n\n      if (!this._header) {\n        // estimate the length\n        if (!this.getHeader('Content-Length')) {\n          length = chunkLength(chunk, encoding);\n        }\n\n        this._implicitHeader();\n      }\n\n      if (!stream) {\n        return _end.call(this, chunk, encoding);\n      } // mark ended\n\n\n      ended = true; // write Buffer for Node.js 0.8\n\n      return chunk ? stream.end(toBuffer(chunk, encoding)) : stream.end();\n    };\n\n    res.on = function on(type, listener) {\n      if (!listeners || type !== 'drain') {\n        return _on.call(this, type, listener);\n      }\n\n      if (stream) {\n        return stream.on(type, listener);\n      } // buffer listeners for future stream\n\n\n      listeners.push([type, listener]);\n      return this;\n    };\n\n    function nocompress(msg) {\n      debug('no compression: %s', msg);\n      addListeners(res, _on, listeners);\n      listeners = null;\n    }\n\n    onHeaders(res, function onResponseHeaders() {\n      // determine if request is filtered\n      if (!filter(req, res)) {\n        nocompress('filtered');\n        return;\n      } // determine if the entity should be transformed\n\n\n      if (!shouldTransform(req, res)) {\n        nocompress('no transform');\n        return;\n      } // vary\n\n\n      vary(res, 'Accept-Encoding'); // content-length below threshold\n\n      if (Number(res.getHeader('Content-Length')) < threshold || length < threshold) {\n        nocompress('size below threshold');\n        return;\n      }\n\n      var encoding = res.getHeader('Content-Encoding') || 'identity'; // already encoded\n\n      if (encoding !== 'identity') {\n        nocompress('already encoded');\n        return;\n      } // head\n\n\n      if (req.method === 'HEAD') {\n        nocompress('HEAD request');\n        return;\n      } // compression method\n\n\n      var accept = accepts(req);\n      var method = accept.encoding(['gzip', 'deflate', 'identity']); // we really don't prefer deflate\n\n      if (method === 'deflate' && accept.encoding(['gzip'])) {\n        method = accept.encoding(['gzip', 'identity']);\n      } // negotiation failed\n\n\n      if (!method || method === 'identity') {\n        nocompress('not acceptable');\n        return;\n      } // compression stream\n\n\n      debug('%s compression', method);\n      stream = method === 'gzip' ? zlib.createGzip(opts) : zlib.createDeflate(opts); // add buffered listeners to stream\n\n      addListeners(stream, stream.on, listeners); // header fields\n\n      res.setHeader('Content-Encoding', method);\n      res.removeHeader('Content-Length'); // compression\n\n      stream.on('data', function onStreamData(chunk) {\n        if (_write.call(res, chunk) === false) {\n          stream.pause();\n        }\n      });\n      stream.on('end', function onStreamEnd() {\n        _end.call(res);\n      });\n\n      _on.call(res, 'drain', function onResponseDrain() {\n        stream.resume();\n      });\n    });\n    next();\n  };\n}\n/**\n * Add bufferred listeners to stream\n * @private\n */\n\n\nfunction addListeners(stream, on, listeners) {\n  for (var i = 0; i < listeners.length; i++) {\n    on.apply(stream, listeners[i]);\n  }\n}\n/**\n * Get the length of a given chunk\n */\n\n\nfunction chunkLength(chunk, encoding) {\n  if (!chunk) {\n    return 0;\n  }\n\n  return !Buffer.isBuffer(chunk) ? Buffer.byteLength(chunk, encoding) : chunk.length;\n}\n/**\n * Default filter function.\n * @private\n */\n\n\nfunction shouldCompress(req, res) {\n  var type = res.getHeader('Content-Type');\n\n  if (type === undefined || !compressible(type)) {\n    debug('%s not compressible', type);\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determine if the entity should be transformed.\n * @private\n */\n\n\nfunction shouldTransform(req, res) {\n  var cacheControl = res.getHeader('Cache-Control'); // Don't compress for Cache-Control: no-transform\n  // https://tools.ietf.org/html/rfc7234#section-5.2.2.4\n\n  return !cacheControl || !cacheControlNoTransformRegExp.test(cacheControl);\n}\n/**\n * Coerce arguments to Buffer\n * @private\n */\n\n\nfunction toBuffer(chunk, encoding) {\n  return !Buffer.isBuffer(chunk) ? Buffer.from(chunk, encoding) : chunk;\n}","map":null,"metadata":{},"sourceType":"script"}