{"ast":null,"code":"/*global Buffer*/\n// Named constants with unique integer values\nvar C = {}; // Tokens\n\nvar LEFT_BRACE = C.LEFT_BRACE = 0x1;\nvar RIGHT_BRACE = C.RIGHT_BRACE = 0x2;\nvar LEFT_BRACKET = C.LEFT_BRACKET = 0x3;\nvar RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;\nvar COLON = C.COLON = 0x5;\nvar COMMA = C.COMMA = 0x6;\nvar TRUE = C.TRUE = 0x7;\nvar FALSE = C.FALSE = 0x8;\nvar NULL = C.NULL = 0x9;\nvar STRING = C.STRING = 0xa;\nvar NUMBER = C.NUMBER = 0xb; // Tokenizer States\n\nvar START = C.START = 0x11;\nvar STOP = C.STOP = 0x12;\nvar TRUE1 = C.TRUE1 = 0x21;\nvar TRUE2 = C.TRUE2 = 0x22;\nvar TRUE3 = C.TRUE3 = 0x23;\nvar FALSE1 = C.FALSE1 = 0x31;\nvar FALSE2 = C.FALSE2 = 0x32;\nvar FALSE3 = C.FALSE3 = 0x33;\nvar FALSE4 = C.FALSE4 = 0x34;\nvar NULL1 = C.NULL1 = 0x41;\nvar NULL2 = C.NULL2 = 0x42;\nvar NULL3 = C.NULL3 = 0x43;\nvar NUMBER1 = C.NUMBER1 = 0x51;\nvar NUMBER3 = C.NUMBER3 = 0x53;\nvar STRING1 = C.STRING1 = 0x61;\nvar STRING2 = C.STRING2 = 0x62;\nvar STRING3 = C.STRING3 = 0x63;\nvar STRING4 = C.STRING4 = 0x64;\nvar STRING5 = C.STRING5 = 0x65;\nvar STRING6 = C.STRING6 = 0x66; // Parser States\n\nvar VALUE = C.VALUE = 0x71;\nvar KEY = C.KEY = 0x72; // Parser Modes\n\nvar OBJECT = C.OBJECT = 0x81;\nvar ARRAY = C.ARRAY = 0x82; // Character constants\n\nvar BACK_SLASH = \"\\\\\".charCodeAt(0);\nvar FORWARD_SLASH = \"\\/\".charCodeAt(0);\nvar BACKSPACE = \"\\b\".charCodeAt(0);\nvar FORM_FEED = \"\\f\".charCodeAt(0);\nvar NEWLINE = \"\\n\".charCodeAt(0);\nvar CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nvar TAB = \"\\t\".charCodeAt(0);\nvar STRING_BUFFER_SIZE = 64 * 1024;\n\nfunction Parser() {\n  this.tState = START;\n  this.value = undefined;\n  this.string = undefined; // string data\n\n  this.stringBuffer = Buffer.alloc ? Buffer.alloc(STRING_BUFFER_SIZE) : new Buffer(STRING_BUFFER_SIZE);\n  this.stringBufferOffset = 0;\n  this.unicode = undefined; // unicode escapes\n\n  this.highSurrogate = undefined;\n  this.key = undefined;\n  this.mode = undefined;\n  this.stack = [];\n  this.state = VALUE;\n  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n\n  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n\n  this.temp_buffs = {\n    \"2\": new Buffer(2),\n    \"3\": new Buffer(3),\n    \"4\": new Buffer(4)\n  }; // for rebuilding chars split before boundary is reached\n  // Stream offset\n\n  this.offset = -1;\n} // Slow code to string converter (only used when throwing syntax errors)\n\n\nParser.toknam = function (code) {\n  var keys = Object.keys(C);\n\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n\n    if (C[key] === code) {\n      return key;\n    }\n  }\n\n  return code && \"0x\" + code.toString(16);\n};\n\nvar proto = Parser.prototype;\n\nproto.onError = function (err) {\n  throw err;\n};\n\nproto.charError = function (buffer, i) {\n  this.tState = STOP;\n  this.onError(new Error(\"Unexpected \" + JSON.stringify(String.fromCharCode(buffer[i])) + \" at position \" + i + \" in state \" + Parser.toknam(this.tState)));\n};\n\nproto.appendStringChar = function (char) {\n  if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {\n    this.string += this.stringBuffer.toString('utf8');\n    this.stringBufferOffset = 0;\n  }\n\n  this.stringBuffer[this.stringBufferOffset++] = char;\n};\n\nproto.appendStringBuf = function (buf, start, end) {\n  var size = buf.length;\n\n  if (typeof start === 'number') {\n    if (typeof end === 'number') {\n      if (end < 0) {\n        // adding a negative end decreeses the size\n        size = buf.length - start + end;\n      } else {\n        size = end - start;\n      }\n    } else {\n      size = buf.length - start;\n    }\n  }\n\n  if (size < 0) {\n    size = 0;\n  }\n\n  if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {\n    this.string += this.stringBuffer.toString('utf8', 0, this.stringBufferOffset);\n    this.stringBufferOffset = 0;\n  }\n\n  buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);\n  this.stringBufferOffset += size;\n};\n\nproto.write = function (buffer) {\n  if (typeof buffer === \"string\") buffer = new Buffer(buffer);\n  var n;\n\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    if (this.tState === START) {\n      n = buffer[i];\n      this.offset++;\n\n      if (n === 0x7b) {\n        this.onToken(LEFT_BRACE, \"{\"); // {\n      } else if (n === 0x7d) {\n        this.onToken(RIGHT_BRACE, \"}\"); // }\n      } else if (n === 0x5b) {\n        this.onToken(LEFT_BRACKET, \"[\"); // [\n      } else if (n === 0x5d) {\n        this.onToken(RIGHT_BRACKET, \"]\"); // ]\n      } else if (n === 0x3a) {\n        this.onToken(COLON, \":\"); // :\n      } else if (n === 0x2c) {\n        this.onToken(COMMA, \",\"); // ,\n      } else if (n === 0x74) {\n        this.tState = TRUE1; // t\n      } else if (n === 0x66) {\n        this.tState = FALSE1; // f\n      } else if (n === 0x6e) {\n        this.tState = NULL1; // n\n      } else if (n === 0x22) {\n        // \"\n        this.string = \"\";\n        this.stringBufferOffset = 0;\n        this.tState = STRING1;\n      } else if (n === 0x2d) {\n        this.string = \"-\";\n        this.tState = NUMBER1; // -\n      } else {\n        if (n >= 0x30 && n < 0x40) {\n          // 1-9\n          this.string = String.fromCharCode(n);\n          this.tState = NUMBER3;\n        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {// whitespace\n        } else {\n          return this.charError(buffer, i);\n        }\n      }\n    } else if (this.tState === STRING1) {\n      // After open quote\n      n = buffer[i]; // get current byte from buffer\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];\n        }\n\n        this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n        i = i + j - 1;\n      } else if (this.bytes_remaining === 0 && n >= 128) {\n        // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n        if (n <= 193 || n > 244) {\n          return this.onError(new Error(\"Invalid UTF-8 character at position \" + i + \" in state \" + Parser.toknam(this.tState)));\n        }\n\n        if (n >= 194 && n <= 223) this.bytes_in_sequence = 2;\n        if (n >= 224 && n <= 239) this.bytes_in_sequence = 3;\n        if (n >= 240 && n <= 244) this.bytes_in_sequence = 4;\n\n        if (this.bytes_in_sequence + i > buffer.length) {\n          // if bytes needed to complete char fall outside buffer length, we have a boundary split\n          for (var k = 0; k <= buffer.length - 1 - i; k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk\n          }\n\n          this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;\n          i = buffer.length - 1;\n        } else {\n          this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);\n          i = i + this.bytes_in_sequence - 1;\n        }\n      } else if (n === 0x22) {\n        this.tState = START;\n        this.string += this.stringBuffer.toString('utf8', 0, this.stringBufferOffset);\n        this.stringBufferOffset = 0;\n        this.onToken(STRING, this.string);\n        this.offset += Buffer.byteLength(this.string, 'utf8') + 1;\n        this.string = undefined;\n      } else if (n === 0x5c) {\n        this.tState = STRING2;\n      } else if (n >= 0x20) {\n        this.appendStringChar(n);\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === STRING2) {\n      // After backslash\n      n = buffer[i];\n\n      if (n === 0x22) {\n        this.appendStringChar(n);\n        this.tState = STRING1;\n      } else if (n === 0x5c) {\n        this.appendStringChar(BACK_SLASH);\n        this.tState = STRING1;\n      } else if (n === 0x2f) {\n        this.appendStringChar(FORWARD_SLASH);\n        this.tState = STRING1;\n      } else if (n === 0x62) {\n        this.appendStringChar(BACKSPACE);\n        this.tState = STRING1;\n      } else if (n === 0x66) {\n        this.appendStringChar(FORM_FEED);\n        this.tState = STRING1;\n      } else if (n === 0x6e) {\n        this.appendStringChar(NEWLINE);\n        this.tState = STRING1;\n      } else if (n === 0x72) {\n        this.appendStringChar(CARRIAGE_RETURN);\n        this.tState = STRING1;\n      } else if (n === 0x74) {\n        this.appendStringChar(TAB);\n        this.tState = STRING1;\n      } else if (n === 0x75) {\n        this.unicode = \"\";\n        this.tState = STRING3;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {\n      // unicode hex codes\n      n = buffer[i]; // 0-9 A-F a-f\n\n      if (n >= 0x30 && n < 0x40 || n > 0x40 && n <= 0x46 || n > 0x60 && n <= 0x66) {\n        this.unicode += String.fromCharCode(n);\n\n        if (this.tState++ === STRING6) {\n          var intVal = parseInt(this.unicode, 16);\n          this.unicode = undefined;\n\n          if (this.highSurrogate !== undefined && intVal >= 0xDC00 && intVal < 0xDFFF + 1) {\n            //<56320,57343> - lowSurrogate\n            this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate, intVal)));\n            this.highSurrogate = undefined;\n          } else if (this.highSurrogate === undefined && intVal >= 0xD800 && intVal < 0xDBFF + 1) {\n            //<55296,56319> - highSurrogate\n            this.highSurrogate = intVal;\n          } else {\n            if (this.highSurrogate !== undefined) {\n              this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate)));\n              this.highSurrogate = undefined;\n            }\n\n            this.appendStringBuf(new Buffer(String.fromCharCode(intVal)));\n          }\n\n          this.tState = STRING1;\n        }\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {\n      n = buffer[i];\n\n      switch (n) {\n        case 0x30: // 0\n\n        case 0x31: // 1\n\n        case 0x32: // 2\n\n        case 0x33: // 3\n\n        case 0x34: // 4\n\n        case 0x35: // 5\n\n        case 0x36: // 6\n\n        case 0x37: // 7\n\n        case 0x38: // 8\n\n        case 0x39: // 9\n\n        case 0x2e: // .\n\n        case 0x65: // e\n\n        case 0x45: // E\n\n        case 0x2b: // +\n\n        case 0x2d:\n          // -\n          this.string += String.fromCharCode(n);\n          this.tState = NUMBER3;\n          break;\n\n        default:\n          this.tState = START;\n          var result = Number(this.string);\n\n          if (isNaN(result)) {\n            return this.charError(buffer, i);\n          }\n\n          if (this.string.match(/[0-9]+/) == this.string && result.toString() != this.string) {\n            // Long string of digits which is an ID string and not valid and/or safe JavaScript integer Number\n            this.onToken(STRING, this.string);\n          } else {\n            this.onToken(NUMBER, result);\n          }\n\n          this.offset += this.string.length - 1;\n          this.string = undefined;\n          i--;\n          break;\n      }\n    } else if (this.tState === TRUE1) {\n      // r\n      if (buffer[i] === 0x72) {\n        this.tState = TRUE2;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === TRUE2) {\n      // u\n      if (buffer[i] === 0x75) {\n        this.tState = TRUE3;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === TRUE3) {\n      // e\n      if (buffer[i] === 0x65) {\n        this.tState = START;\n        this.onToken(TRUE, true);\n        this.offset += 3;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === FALSE1) {\n      // a\n      if (buffer[i] === 0x61) {\n        this.tState = FALSE2;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === FALSE2) {\n      // l\n      if (buffer[i] === 0x6c) {\n        this.tState = FALSE3;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === FALSE3) {\n      // s\n      if (buffer[i] === 0x73) {\n        this.tState = FALSE4;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === FALSE4) {\n      // e\n      if (buffer[i] === 0x65) {\n        this.tState = START;\n        this.onToken(FALSE, false);\n        this.offset += 4;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === NULL1) {\n      // u\n      if (buffer[i] === 0x75) {\n        this.tState = NULL2;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === NULL2) {\n      // l\n      if (buffer[i] === 0x6c) {\n        this.tState = NULL3;\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === NULL3) {\n      // l\n      if (buffer[i] === 0x6c) {\n        this.tState = START;\n        this.onToken(NULL, null);\n        this.offset += 3;\n      } else {\n        return this.charError(buffer, i);\n      }\n    }\n  }\n};\n\nproto.onToken = function (token, value) {// Override this to get events\n};\n\nproto.parseError = function (token, value) {\n  this.tState = STOP;\n  this.onError(new Error(\"Unexpected \" + Parser.toknam(token) + (value ? \"(\" + JSON.stringify(value) + \")\" : \"\") + \" in state \" + Parser.toknam(this.state)));\n};\n\nproto.push = function () {\n  this.stack.push({\n    value: this.value,\n    key: this.key,\n    mode: this.mode\n  });\n};\n\nproto.pop = function () {\n  var value = this.value;\n  var parent = this.stack.pop();\n  this.value = parent.value;\n  this.key = parent.key;\n  this.mode = parent.mode;\n  this.emit(value);\n\n  if (!this.mode) {\n    this.state = VALUE;\n  }\n};\n\nproto.emit = function (value) {\n  if (this.mode) {\n    this.state = COMMA;\n  }\n\n  this.onValue(value);\n};\n\nproto.onValue = function (value) {// Override me\n};\n\nproto.onToken = function (token, value) {\n  if (this.state === VALUE) {\n    if (token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL) {\n      if (this.value) {\n        this.value[this.key] = value;\n      }\n\n      this.emit(value);\n    } else if (token === LEFT_BRACE) {\n      this.push();\n\n      if (this.value) {\n        this.value = this.value[this.key] = {};\n      } else {\n        this.value = {};\n      }\n\n      this.key = undefined;\n      this.state = KEY;\n      this.mode = OBJECT;\n    } else if (token === LEFT_BRACKET) {\n      this.push();\n\n      if (this.value) {\n        this.value = this.value[this.key] = [];\n      } else {\n        this.value = [];\n      }\n\n      this.key = 0;\n      this.mode = ARRAY;\n      this.state = VALUE;\n    } else if (token === RIGHT_BRACE) {\n      if (this.mode === OBJECT) {\n        this.pop();\n      } else {\n        return this.parseError(token, value);\n      }\n    } else if (token === RIGHT_BRACKET) {\n      if (this.mode === ARRAY) {\n        this.pop();\n      } else {\n        return this.parseError(token, value);\n      }\n    } else {\n      return this.parseError(token, value);\n    }\n  } else if (this.state === KEY) {\n    if (token === STRING) {\n      this.key = value;\n      this.state = COLON;\n    } else if (token === RIGHT_BRACE) {\n      this.pop();\n    } else {\n      return this.parseError(token, value);\n    }\n  } else if (this.state === COLON) {\n    if (token === COLON) {\n      this.state = VALUE;\n    } else {\n      return this.parseError(token, value);\n    }\n  } else if (this.state === COMMA) {\n    if (token === COMMA) {\n      if (this.mode === ARRAY) {\n        this.key++;\n        this.state = VALUE;\n      } else if (this.mode === OBJECT) {\n        this.state = KEY;\n      }\n    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {\n      this.pop();\n    } else {\n      return this.parseError(token, value);\n    }\n  } else {\n    return this.parseError(token, value);\n  }\n};\n\nParser.C = C;\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script"}