{"ast":null,"code":"'use strict';\n\nvar fs = require('graceful-fs'),\n    path = require('path'),\n    micromatch = require('micromatch').isMatch,\n    toString = Object.prototype.toString; // Standard helpers\n\n\nfunction isFunction(obj) {\n  return toString.call(obj) === '[object Function]';\n}\n\nfunction isString(obj) {\n  return toString.call(obj) === '[object String]';\n}\n\nfunction isUndefined(obj) {\n  return obj === void 0;\n}\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth\n * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },\n *                                when callback2 is not given, it behaves like explained in callback2\n * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos\n *                                function (err, fileInfos) { ... }\n */\n\n\nfunction readdir(opts, callback1, callback2) {\n  var stream,\n      handleError,\n      handleFatalError,\n      errors = [],\n      readdirResult = {\n    directories: [],\n    files: []\n  },\n      fileProcessed,\n      allProcessed,\n      realRoot,\n      aborted = false,\n      paused = false; // If no callbacks were given we will use a streaming interface\n\n  if (isUndefined(callback1)) {\n    var api = require('./stream-api')();\n\n    stream = api.stream;\n    callback1 = api.processEntry;\n    callback2 = api.done;\n    handleError = api.handleError;\n    handleFatalError = api.handleFatalError;\n    stream.on('close', function () {\n      aborted = true;\n    });\n    stream.on('pause', function () {\n      paused = true;\n    });\n    stream.on('resume', function () {\n      paused = false;\n    });\n  } else {\n    handleError = function handleError(err) {\n      errors.push(err);\n    };\n\n    handleFatalError = function handleFatalError(err) {\n      handleError(err);\n      allProcessed(errors, null);\n    };\n  }\n\n  if (isUndefined(opts)) {\n    handleFatalError(new Error('Need to pass at least one argument: opts! \\n' + 'https://github.com/paulmillr/readdirp#options'));\n    return stream;\n  }\n\n  opts.root = opts.root || '.';\n\n  opts.fileFilter = opts.fileFilter || function () {\n    return true;\n  };\n\n  opts.directoryFilter = opts.directoryFilter || function () {\n    return true;\n  };\n\n  opts.depth = typeof opts.depth === 'undefined' ? 999999999 : opts.depth;\n  opts.entryType = opts.entryType || 'files';\n  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);\n\n  if (isUndefined(callback2)) {\n    fileProcessed = function fileProcessed() {};\n\n    allProcessed = callback1;\n  } else {\n    fileProcessed = callback1;\n    allProcessed = callback2;\n  }\n\n  function normalizeFilter(filter) {\n    if (isUndefined(filter)) return undefined;\n\n    function isNegated(filters) {\n      function negated(f) {\n        return f.indexOf('!') === 0;\n      }\n\n      var some = filters.some(negated);\n\n      if (!some) {\n        return false;\n      } else {\n        if (filters.every(negated)) {\n          return true;\n        } else {\n          // if we detect illegal filters, bail out immediately\n          throw new Error('Cannot mix negated with non negated glob filters: ' + filters + '\\n' + 'https://github.com/paulmillr/readdirp#filters');\n        }\n      }\n    } // Turn all filters into a function\n\n\n    if (isFunction(filter)) {\n      return filter;\n    } else if (isString(filter)) {\n      return function (entryInfo) {\n        return micromatch(entryInfo.name, filter.trim());\n      };\n    } else if (filter && Array.isArray(filter)) {\n      if (filter) filter = filter.map(function (f) {\n        return f.trim();\n      });\n      return isNegated(filter) ? // use AND to concat multiple negated filters\n      function (entryInfo) {\n        return filter.every(function (f) {\n          return micromatch(entryInfo.name, f);\n        });\n      } : // use OR to concat multiple inclusive filters\n      function (entryInfo) {\n        return filter.some(function (f) {\n          return micromatch(entryInfo.name, f);\n        });\n      };\n    }\n  }\n\n  function processDir(currentDir, entries, callProcessed) {\n    if (aborted) return;\n    var total = entries.length,\n        processed = 0,\n        entryInfos = [];\n    fs.realpath(currentDir, function (err, realCurrentDir) {\n      if (aborted) return;\n\n      if (err) {\n        handleError(err);\n        callProcessed(entryInfos);\n        return;\n      }\n\n      var relDir = path.relative(realRoot, realCurrentDir);\n\n      if (entries.length === 0) {\n        callProcessed([]);\n      } else {\n        entries.forEach(function (entry) {\n          var fullPath = path.join(realCurrentDir, entry),\n              relPath = path.join(relDir, entry);\n          statfn(fullPath, function (err, stat) {\n            if (err) {\n              handleError(err);\n            } else {\n              entryInfos.push({\n                name: entry,\n                path: relPath // relative to root\n                ,\n                fullPath: fullPath,\n                parentDir: relDir // relative to root\n                ,\n                fullParentDir: realCurrentDir,\n                stat: stat\n              });\n            }\n\n            processed++;\n            if (processed === total) callProcessed(entryInfos);\n          });\n        });\n      }\n    });\n  }\n\n  function readdirRec(currentDir, depth, callCurrentDirProcessed) {\n    var args = arguments;\n    if (aborted) return;\n\n    if (paused) {\n      setImmediate(function () {\n        readdirRec.apply(null, args);\n      });\n      return;\n    }\n\n    fs.readdir(currentDir, function (err, entries) {\n      if (err) {\n        handleError(err);\n        callCurrentDirProcessed();\n        return;\n      }\n\n      processDir(currentDir, entries, function (entryInfos) {\n        var subdirs = entryInfos.filter(function (ei) {\n          return ei.stat.isDirectory() && opts.directoryFilter(ei);\n        });\n        subdirs.forEach(function (di) {\n          if (opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {\n            fileProcessed(di);\n          }\n\n          readdirResult.directories.push(di);\n        });\n        entryInfos.filter(function (ei) {\n          var isCorrectType = opts.entryType === 'all' ? !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();\n          return isCorrectType && opts.fileFilter(ei);\n        }).forEach(function (fi) {\n          if (opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {\n            fileProcessed(fi);\n          }\n\n          readdirResult.files.push(fi);\n        });\n        var pendingSubdirs = subdirs.length; // Be done if no more subfolders exist or we reached the maximum desired depth\n\n        if (pendingSubdirs === 0 || depth === opts.depth) {\n          callCurrentDirProcessed();\n        } else {\n          // recurse into subdirs, keeping track of which ones are done\n          // and call back once all are processed\n          subdirs.forEach(function (subdir) {\n            readdirRec(subdir.fullPath, depth + 1, function () {\n              pendingSubdirs = pendingSubdirs - 1;\n\n              if (pendingSubdirs === 0) {\n                callCurrentDirProcessed();\n              }\n            });\n          });\n        }\n      });\n    });\n  } // Validate and normalize filters\n\n\n  try {\n    opts.fileFilter = normalizeFilter(opts.fileFilter);\n    opts.directoryFilter = normalizeFilter(opts.directoryFilter);\n  } catch (err) {\n    // if we detect illegal filters, bail out immediately\n    handleFatalError(err);\n    return stream;\n  } // If filters were valid get on with the show\n\n\n  fs.realpath(opts.root, function (err, res) {\n    if (err) {\n      handleFatalError(err);\n      return stream;\n    }\n\n    realRoot = res;\n    readdirRec(opts.root, 0, function () {\n      // All errors are collected into the errors array\n      if (errors.length > 0) {\n        allProcessed(errors, readdirResult);\n      } else {\n        allProcessed(null, readdirResult);\n      }\n    });\n  });\n  return stream;\n}\n\nmodule.exports = readdir;","map":null,"metadata":{},"sourceType":"script"}