{"ast":null,"code":"var msg = require('pako/lib/zlib/messages');\n\nvar zstream = require('pako/lib/zlib/zstream');\n\nvar zlib_deflate = require('pako/lib/zlib/deflate.js');\n\nvar zlib_inflate = require('pako/lib/zlib/inflate.js');\n\nvar constants = require('pako/lib/zlib/constants');\n\nfor (var key in constants) {\n  exports[key] = constants[key];\n} // zlib modes\n\n\nexports.NONE = 0;\nexports.DEFLATE = 1;\nexports.INFLATE = 2;\nexports.GZIP = 3;\nexports.GUNZIP = 4;\nexports.DEFLATERAW = 5;\nexports.INFLATERAW = 6;\nexports.UNZIP = 7;\n/**\n * Emulate Node's zlib C++ layer for use by the JS layer in index.js\n */\n\nfunction Zlib(mode) {\n  if (mode < exports.DEFLATE || mode > exports.UNZIP) throw new TypeError(\"Bad argument\");\n  this.mode = mode;\n  this.init_done = false;\n  this.write_in_progress = false;\n  this.pending_close = false;\n  this.windowBits = 0;\n  this.level = 0;\n  this.memLevel = 0;\n  this.strategy = 0;\n  this.dictionary = null;\n}\n\nZlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\n  this.windowBits = windowBits;\n  this.level = level;\n  this.memLevel = memLevel;\n  this.strategy = strategy; // dictionary not supported.\n\n  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) this.windowBits += 16;\n  if (this.mode === exports.UNZIP) this.windowBits += 32;\n  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) this.windowBits = -this.windowBits;\n  this.strm = new zstream();\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      var status = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\n      break;\n\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n    case exports.UNZIP:\n      var status = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n      break;\n\n    default:\n      throw new Error(\"Unknown mode \" + this.mode);\n  }\n\n  if (status !== exports.Z_OK) {\n    this._error(status);\n\n    return;\n  }\n\n  this.write_in_progress = false;\n  this.init_done = true;\n};\n\nZlib.prototype.params = function () {\n  throw new Error(\"deflateParams Not supported\");\n};\n\nZlib.prototype._writeCheck = function () {\n  if (!this.init_done) throw new Error(\"write before init\");\n  if (this.mode === exports.NONE) throw new Error(\"already finalized\");\n  if (this.write_in_progress) throw new Error(\"write already in progress\");\n  if (this.pending_close) throw new Error(\"close is pending\");\n};\n\nZlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  this._writeCheck();\n\n  this.write_in_progress = true;\n  var self = this;\n  process.nextTick(function () {\n    self.write_in_progress = false;\n\n    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);\n\n    self.callback(res[0], res[1]);\n    if (self.pending_close) self.close();\n  });\n  return this;\n}; // set method for Node buffers, used by pako\n\n\nfunction bufferSet(data, offset) {\n  for (var i = 0; i < data.length; i++) {\n    this[offset + i] = data[i];\n  }\n}\n\nZlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  this._writeCheck();\n\n  return this._write(flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype._write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  this.write_in_progress = true;\n\n  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {\n    throw new Error(\"Invalid flush value\");\n  }\n\n  if (input == null) {\n    input = new Buffer(0);\n    in_len = 0;\n    in_off = 0;\n  }\n\n  if (out._set) out.set = out._set;else out.set = bufferSet;\n  var strm = this.strm;\n  strm.avail_in = in_len;\n  strm.input = input;\n  strm.next_in = in_off;\n  strm.avail_out = out_len;\n  strm.output = out;\n  strm.next_out = out_off;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      var status = zlib_deflate.deflate(strm, flush);\n      break;\n\n    case exports.UNZIP:\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n      var status = zlib_inflate.inflate(strm, flush);\n      break;\n\n    default:\n      throw new Error(\"Unknown mode \" + this.mode);\n  }\n\n  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {\n    this._error(status);\n  }\n\n  this.write_in_progress = false;\n  return [strm.avail_in, strm.avail_out];\n};\n\nZlib.prototype.close = function () {\n  if (this.write_in_progress) {\n    this.pending_close = true;\n    return;\n  }\n\n  this.pending_close = false;\n\n  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n    zlib_deflate.deflateEnd(this.strm);\n  } else {\n    zlib_inflate.inflateEnd(this.strm);\n  }\n\n  this.mode = exports.NONE;\n};\n\nZlib.prototype.reset = function () {\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n      var status = zlib_deflate.deflateReset(this.strm);\n      break;\n\n    case exports.INFLATE:\n    case exports.INFLATERAW:\n      var status = zlib_inflate.inflateReset(this.strm);\n      break;\n  }\n\n  if (status !== exports.Z_OK) {\n    this._error(status);\n  }\n};\n\nZlib.prototype._error = function (status) {\n  this.onerror(msg[status] + ': ' + this.strm.msg, status);\n  this.write_in_progress = false;\n  if (this.pending_close) this.close();\n};\n\nexports.Zlib = Zlib;","map":null,"metadata":{},"sourceType":"script"}