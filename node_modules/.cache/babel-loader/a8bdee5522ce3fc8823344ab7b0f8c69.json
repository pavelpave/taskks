{"ast":null,"code":"'use strict';\n\nvar chars = require('./chars');\n\nvar utils = require('./utils');\n/**\n * Expose `Glob`\n */\n\n\nvar Glob = module.exports = function Glob(pattern, options) {\n  if (!(this instanceof Glob)) {\n    return new Glob(pattern, options);\n  }\n\n  this.options = options || {};\n  this.pattern = pattern;\n  this.history = [];\n  this.tokens = {};\n  this.init(pattern);\n};\n/**\n * Initialize defaults\n */\n\n\nGlob.prototype.init = function (pattern) {\n  this.orig = pattern;\n  this.negated = this.isNegated();\n  this.options.track = this.options.track || false;\n  this.options.makeRe = true;\n};\n/**\n * Push a change into `glob.history`. Useful\n * for debugging.\n */\n\n\nGlob.prototype.track = function (msg) {\n  if (this.options.track) {\n    this.history.push({\n      msg: msg,\n      pattern: this.pattern\n    });\n  }\n};\n/**\n * Return true if `glob.pattern` was negated\n * with `!`, also remove the `!` from the pattern.\n *\n * @return {Boolean}\n */\n\n\nGlob.prototype.isNegated = function () {\n  if (this.pattern.charCodeAt(0) === 33\n  /* '!' */\n  ) {\n      this.pattern = this.pattern.slice(1);\n      return true;\n    }\n\n  return false;\n};\n/**\n * Expand braces in the given glob pattern.\n *\n * We only need to use the [braces] lib when\n * patterns are nested.\n */\n\n\nGlob.prototype.braces = function () {\n  if (this.options.nobraces !== true && this.options.nobrace !== true) {\n    // naive/fast check for imbalanced characters\n    var a = this.pattern.match(/[\\{\\(\\[]/g);\n    var b = this.pattern.match(/[\\}\\)\\]]/g); // if imbalanced, don't optimize the pattern\n\n    if (a && b && a.length !== b.length) {\n      this.options.makeRe = false;\n    } // expand brace patterns and join the resulting array\n\n\n    var expanded = utils.braces(this.pattern, this.options);\n    this.pattern = expanded.join('|');\n  }\n};\n/**\n * Expand bracket expressions in `glob.pattern`\n */\n\n\nGlob.prototype.brackets = function () {\n  if (this.options.nobrackets !== true) {\n    this.pattern = utils.brackets(this.pattern);\n  }\n};\n/**\n * Expand bracket expressions in `glob.pattern`\n */\n\n\nGlob.prototype.extglob = function () {\n  if (this.options.noextglob === true) return;\n\n  if (utils.isExtglob(this.pattern)) {\n    this.pattern = utils.extglob(this.pattern, {\n      escape: true\n    });\n  }\n};\n/**\n * Parse the given pattern\n */\n\n\nGlob.prototype.parse = function (pattern) {\n  this.tokens = utils.parseGlob(pattern || this.pattern, true);\n  return this.tokens;\n};\n/**\n * Replace `a` with `b`. Also tracks the change before and\n * after each replacement. This is disabled by default, but\n * can be enabled by setting `options.track` to true.\n *\n * Also, when the pattern is a string, `.split()` is used,\n * because it's much faster than replace.\n *\n * @param  {RegExp|String} `a`\n * @param  {String} `b`\n * @param  {Boolean} `escape` When `true`, escapes `*` and `?` in the replacement.\n * @return {String}\n */\n\n\nGlob.prototype._replace = function (a, b, escape) {\n  this.track('before (find): \"' + a + '\" (replace with): \"' + b + '\"');\n  if (escape) b = esc(b);\n\n  if (a && b && typeof a === 'string') {\n    this.pattern = this.pattern.split(a).join(b);\n  } else {\n    this.pattern = this.pattern.replace(a, b);\n  }\n\n  this.track('after');\n};\n/**\n * Escape special characters in the given string.\n *\n * @param  {String} `str` Glob pattern\n * @return {String}\n */\n\n\nGlob.prototype.escape = function (str) {\n  this.track('before escape: ');\n  var re = /[\"\\\\](['\"]?[^\"'\\\\]['\"]?)/g;\n  this.pattern = str.replace(re, function ($0, $1) {\n    var o = chars.ESC;\n    var ch = o && o[$1];\n\n    if (ch) {\n      return ch;\n    }\n\n    if (/[a-z]/i.test($0)) {\n      return $0.split('\\\\').join('');\n    }\n\n    return $0;\n  });\n  this.track('after escape: ');\n};\n/**\n * Unescape special characters in the given string.\n *\n * @param  {String} `str`\n * @return {String}\n */\n\n\nGlob.prototype.unescape = function (str) {\n  var re = /__([A-Z]+)_([A-Z]+)__/g;\n  this.pattern = str.replace(re, function ($0, $1) {\n    return chars[$1][$0];\n  });\n  this.pattern = unesc(this.pattern);\n};\n/**\n * Escape/unescape utils\n */\n\n\nfunction esc(str) {\n  str = str.split('?').join('%~');\n  str = str.split('*').join('%%');\n  return str;\n}\n\nfunction unesc(str) {\n  str = str.split('%~').join('?');\n  str = str.split('%%').join('*');\n  return str;\n}","map":null,"metadata":{},"sourceType":"script"}