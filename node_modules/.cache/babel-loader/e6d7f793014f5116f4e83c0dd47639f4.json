{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar relativePath = require('cached-path-relative');\n\nvar browserResolve = require('browser-resolve');\n\nvar nodeResolve = require('resolve');\n\nvar detective = require('detective');\n\nvar through = require('through2');\n\nvar concat = require('concat-stream');\n\nvar parents = require('parents');\n\nvar combine = require('stream-combiner2');\n\nvar duplexer = require('duplexer2');\n\nvar xtend = require('xtend');\n\nvar defined = require('defined');\n\nvar inherits = require('inherits');\n\nvar Transform = require('readable-stream').Transform;\n\nmodule.exports = Deps;\ninherits(Deps, Transform);\n\nfunction Deps(opts) {\n  var self = this;\n  if (!(this instanceof Deps)) return new Deps(opts);\n  Transform.call(this, {\n    objectMode: true\n  });\n  if (!opts) opts = {};\n  this.basedir = opts.basedir || process.cwd();\n\n  this.persistentCache = opts.persistentCache || function (file, id, pkg, fallback, cb) {\n    process.nextTick(function () {\n      fallback(null, cb);\n    });\n  };\n\n  this.cache = opts.cache;\n  this.fileCache = opts.fileCache;\n  this.pkgCache = opts.packageCache || {};\n  this.pkgFileCache = {};\n  this.pkgFileCachePending = {};\n  this._emittedPkg = {};\n  this.visited = {};\n  this.walking = {};\n  this.entries = [];\n  this._input = [];\n  this.paths = opts.paths || process.env.NODE_PATH || '';\n\n  if (typeof this.paths === 'string') {\n    var delimiter = path.delimiter || (process.platform === 'win32' ? ';' : ':');\n    this.paths = this.paths.split(delimiter);\n  }\n\n  this.paths = this.paths.filter(Boolean).map(function (p) {\n    return path.resolve(self.basedir, p);\n  });\n  this.transforms = [].concat(opts.transform).filter(Boolean);\n  this.globalTransforms = [].concat(opts.globalTransform).filter(Boolean);\n  this.resolver = opts.resolve || browserResolve;\n  this.options = xtend(opts);\n  if (!this.options.modules) this.options.modules = {}; // If the caller passes options.expose, store resolved pathnames for exposed\n  // modules in it. If not, set it anyway so it's defined later.\n\n  if (!this.options.expose) this.options.expose = {};\n  this.pending = 0;\n  this.inputPending = 0;\n  var topfile = path.join(this.basedir, '__fake.js');\n  this.top = {\n    id: topfile,\n    filename: topfile,\n    paths: this.paths,\n    basedir: this.basedir\n  };\n}\n\nDeps.prototype._isTopLevel = function (file) {\n  var isTopLevel = this.entries.some(function (main) {\n    var m = relativePath(path.dirname(main), file);\n    return m.split(/[\\\\\\/]/).indexOf('node_modules') < 0;\n  });\n\n  if (!isTopLevel) {\n    var m = relativePath(this.basedir, file);\n    isTopLevel = m.split(/[\\\\\\/]/).indexOf('node_modules') < 0;\n  }\n\n  return isTopLevel;\n};\n\nDeps.prototype._transform = function (row, enc, next) {\n  var self = this;\n\n  if (typeof row === 'string') {\n    row = {\n      file: row\n    };\n  }\n\n  if (row.transform && row.global) {\n    this.globalTransforms.push([row.transform, row.options]);\n    return next();\n  } else if (row.transform) {\n    this.transforms.push([row.transform, row.options]);\n    return next();\n  }\n\n  self.pending++;\n  var basedir = defined(row.basedir, self.basedir);\n\n  if (row.entry !== false) {\n    self.entries.push(path.resolve(basedir, row.file || row.id));\n  }\n\n  self.lookupPackage(row.file, function (err, pkg) {\n    if (err && self.options.ignoreMissing) {\n      self.emit('missing', row.file, self.top);\n      self.pending--;\n      return next();\n    }\n\n    if (err) return self.emit('error', err);\n    self.pending--;\n\n    self._input.push({\n      row: row,\n      pkg: pkg\n    });\n\n    next();\n  });\n};\n\nDeps.prototype._flush = function () {\n  var self = this;\n  var files = {};\n\n  self._input.forEach(function (r) {\n    var w = r.row,\n        f = files[w.file || w.id];\n\n    if (f) {\n      f.row.entry = f.row.entry || w.entry;\n      var ex = f.row.expose || w.expose;\n      f.row.expose = ex;\n\n      if (ex && f.row.file === f.row.id && w.file !== w.id) {\n        f.row.id = w.id;\n      }\n    } else files[w.file || w.id] = r;\n  });\n\n  Object.keys(files).forEach(function (key) {\n    var r = files[key];\n    var pkg = r.pkg || {};\n    var dir = r.row.file ? path.dirname(r.row.file) : self.basedir;\n    if (!pkg.__dirname) pkg.__dirname = dir;\n    self.walk(r.row, xtend(self.top, {\n      filename: path.join(dir, '_fake.js')\n    }));\n  });\n  if (this.pending === 0) this.push(null);\n  this._ended = true;\n};\n\nDeps.prototype.resolve = function (id, parent, cb) {\n  var self = this;\n  var opts = self.options;\n\n  if (xhas(self.cache, parent.id, 'deps', id) && self.cache[parent.id].deps[id]) {\n    var file = self.cache[parent.id].deps[id];\n    var pkg = self.pkgCache[file];\n    if (pkg) return cb(null, file, pkg);\n    return self.lookupPackage(file, function (err, pkg) {\n      cb(null, file, pkg);\n    });\n  }\n\n  parent.packageFilter = function (p, x) {\n    var pkgdir = path.dirname(x);\n    if (opts.packageFilter) p = opts.packageFilter(p, x);\n    p.__dirname = pkgdir;\n    return p;\n  };\n\n  if (opts.extensions) parent.extensions = opts.extensions;\n  if (opts.modules) parent.modules = opts.modules;\n  self.resolver(id, parent, function onresolve(err, file, pkg, fakePath) {\n    if (err) return cb(err);\n    if (!file) return cb(new Error('module not found: \"' + id + '\" from file ' + parent.filename));\n\n    if (!pkg || !pkg.__dirname) {\n      self.lookupPackage(file, function (err, p) {\n        if (err) return cb(err);\n        if (!p) p = {};\n        if (!p.__dirname) p.__dirname = path.dirname(file);\n        self.pkgCache[file] = p;\n        onresolve(err, file, opts.packageFilter ? opts.packageFilter(p, p.__dirname) : p, fakePath);\n      });\n    } else cb(err, file, pkg, fakePath);\n  });\n};\n\nDeps.prototype.readFile = function (file, id, pkg) {\n  var self = this;\n\n  if (xhas(this.fileCache, file)) {\n    return toStream(this.fileCache[file]);\n  }\n\n  var rs = fs.createReadStream(file, {\n    encoding: 'utf8'\n  });\n  rs.on('error', function (err) {\n    self.emit('error', err);\n  });\n  this.emit('file', file, id);\n  return rs;\n};\n\nDeps.prototype.getTransforms = function (file, pkg, opts) {\n  if (!opts) opts = {};\n  var self = this;\n  var isTopLevel;\n  if (opts.builtin || opts.inNodeModules) isTopLevel = false;else isTopLevel = this._isTopLevel(file);\n  var transforms = [].concat(isTopLevel ? this.transforms : []).concat(getTransforms(pkg, {\n    globalTransform: this.globalTransforms,\n    transformKey: this.options.transformKey\n  }));\n  if (transforms.length === 0) return through();\n  var pending = transforms.length;\n  var streams = [];\n  var input = through();\n  var output = through();\n  var dup = duplexer(input, output);\n\n  for (var i = 0; i < transforms.length; i++) {\n    (function (i) {\n      makeTransform(transforms[i], function (err, trs) {\n        if (err) return self.emit('error', err);\n        streams[i] = trs;\n        if (--pending === 0) done();\n      });\n    })(i);\n  }\n\n  return dup;\n\n  function done() {\n    var middle = combine.apply(null, streams);\n    middle.on('error', function (err) {\n      err.message += ' while parsing file: ' + file;\n      if (!err.filename) err.filename = file;\n      self.emit('error', err);\n    });\n    input.pipe(middle).pipe(output);\n  }\n\n  function makeTransform(tr, cb) {\n    var trOpts = {};\n\n    if (Array.isArray(tr)) {\n      trOpts = tr[1] || {};\n      tr = tr[0];\n    }\n\n    trOpts._flags = trOpts.hasOwnProperty('_flags') ? trOpts._flags : self.options;\n\n    if (typeof tr === 'function') {\n      var t = tr(file, trOpts);\n      self.emit('transform', t, file);\n      nextTick(cb, null, wrapTransform(t));\n    } else {\n      loadTransform(tr, trOpts, function (err, trs) {\n        if (err) return cb(err);\n        cb(null, wrapTransform(trs));\n      });\n    }\n  }\n\n  function loadTransform(id, trOpts, cb) {\n    var params = {\n      basedir: path.dirname(file)\n    };\n    nodeResolve(id, params, function nr(err, res, again) {\n      if (err && again) return cb && cb(err);\n\n      if (err) {\n        params.basedir = pkg.__dirname;\n        return nodeResolve(id, params, function (e, r) {\n          nr(e, r, true);\n        });\n      }\n\n      if (!res) return cb(new Error('cannot find transform module ' + tr + ' while transforming ' + file));\n\n      var r = require(res);\n\n      if (typeof r !== 'function') {\n        return cb(new Error('Unexpected ' + typeof r + ' exported by the ' + JSON.stringify(res) + ' package. ' + 'Expected a transform function.'));\n      }\n\n      var trs = r(file, trOpts);\n      self.emit('transform', trs, file);\n      cb(null, trs);\n    });\n  }\n};\n\nDeps.prototype.walk = function (id, parent, cb) {\n  var self = this;\n  var opts = self.options;\n  this.pending++;\n  var rec = {};\n  var input;\n\n  if (typeof id === 'object') {\n    rec = xtend(id);\n    if (rec.entry === false) delete rec.entry;\n    id = rec.file || rec.id;\n    input = true;\n    this.inputPending++;\n  }\n\n  self.resolve(id, parent, function (err, file, pkg, fakePath) {\n    // this is checked early because parent.modules is also modified\n    // by this function.\n    var builtin = has(parent.modules, id);\n\n    if (rec.expose) {\n      // Set options.expose to make the resolved pathname available to the\n      // caller. They may or may not have requested it, but it's harmless\n      // to set this if they didn't.\n      self.options.expose[rec.expose] = self.options.modules[rec.expose] = file;\n    }\n\n    if (pkg && !self._emittedPkg[pkg.__dirname]) {\n      self._emittedPkg[pkg.__dirname] = true;\n      self.emit('package', pkg);\n    }\n\n    if (opts.postFilter && !opts.postFilter(id, file, pkg)) {\n      if (--self.pending === 0) self.push(null);\n      if (input) --self.inputPending;\n      return cb && cb(null, undefined);\n    }\n\n    if (err && rec.source) {\n      file = rec.file;\n      var ts = self.getTransforms(file, pkg);\n      ts.pipe(concat(function (body) {\n        rec.source = body.toString('utf8');\n        fromSource(file, rec.source, pkg);\n      }));\n      return ts.end(rec.source);\n    }\n\n    if (err && self.options.ignoreMissing) {\n      if (--self.pending === 0) self.push(null);\n      if (input) --self.inputPending;\n      self.emit('missing', id, parent);\n      return cb && cb(null, undefined);\n    }\n\n    if (err) return self.emit('error', err);\n\n    if (self.visited[file]) {\n      if (--self.pending === 0) self.push(null);\n      if (input) --self.inputPending;\n      return cb && cb(null, file);\n    }\n\n    self.visited[file] = true;\n\n    if (rec.source) {\n      var ts = self.getTransforms(file, pkg);\n      ts.pipe(concat(function (body) {\n        rec.source = body.toString('utf8');\n        fromSource(file, rec.source, pkg);\n      }));\n      return ts.end(rec.source);\n    }\n\n    var c = self.cache && self.cache[file];\n    if (c) return fromDeps(file, c.source, c.package, fakePath, Object.keys(c.deps));\n    self.persistentCache(file, id, pkg, persistentCacheFallback, function (err, c) {\n      if (err) {\n        self.emit('error', err);\n        return;\n      }\n\n      fromDeps(file, c.source, c.package, fakePath, Object.keys(c.deps));\n    });\n\n    function persistentCacheFallback(dataAsString, cb) {\n      var stream = dataAsString ? toStream(dataAsString) : self.readFile(file, id, pkg);\n      stream.pipe(self.getTransforms(fakePath || file, pkg, {\n        builtin: builtin,\n        inNodeModules: parent.inNodeModules\n      })).pipe(concat(function (body) {\n        var src = body.toString('utf8');\n        var deps = getDeps(file, src);\n\n        if (deps) {\n          cb(null, {\n            source: src,\n            package: pkg,\n            deps: deps.reduce(function (deps, dep) {\n              deps[dep] = true;\n              return deps;\n            }, {})\n          });\n        }\n      }));\n    }\n  });\n\n  function getDeps(file, src) {\n    return rec.noparse ? [] : self.parseDeps(file, src);\n  }\n\n  function fromSource(file, src, pkg, fakePath) {\n    var deps = getDeps(file, src);\n    if (deps) fromDeps(file, src, pkg, fakePath, deps);\n  }\n\n  function fromDeps(file, src, pkg, fakePath, deps) {\n    var p = deps.length;\n    var resolved = {};\n    if (input) --self.inputPending;\n\n    (function resolve() {\n      if (self.inputPending > 0) return setTimeout(resolve);\n      deps.forEach(function (id) {\n        if (opts.filter && !opts.filter(id)) {\n          resolved[id] = false;\n          if (--p === 0) done();\n          return;\n        }\n\n        var isTopLevel = self._isTopLevel(fakePath || file);\n\n        var current = {\n          id: file,\n          filename: file,\n          paths: self.paths,\n          package: pkg,\n          inNodeModules: parent.inNodeModules || !isTopLevel\n        };\n        self.walk(id, current, function (err, r) {\n          resolved[id] = r;\n          if (--p === 0) done();\n        });\n      });\n      if (deps.length === 0) done();\n    })();\n\n    function done() {\n      if (!rec.id) rec.id = file;\n      if (!rec.source) rec.source = src;\n      if (!rec.deps) rec.deps = resolved;\n      if (!rec.file) rec.file = file;\n\n      if (self.entries.indexOf(file) >= 0) {\n        rec.entry = true;\n      }\n\n      self.push(rec);\n      if (cb) cb(null, file);\n      if (--self.pending === 0) self.push(null);\n    }\n  }\n};\n\nDeps.prototype.parseDeps = function (file, src, cb) {\n  if (this.options.noParse === true) return [];\n  if (/\\.json$/.test(file)) return [];\n\n  if (Array.isArray(this.options.noParse) && this.options.noParse.indexOf(file) >= 0) {\n    return [];\n  }\n\n  try {\n    var deps = detective(src);\n  } catch (ex) {\n    var message = ex && ex.message ? ex.message : ex;\n    this.emit('error', new Error('Parsing file ' + file + ': ' + message));\n    return;\n  }\n\n  return deps;\n};\n\nDeps.prototype.lookupPackage = function (file, cb) {\n  var self = this;\n  var cached = this.pkgCache[file];\n  if (cached) return nextTick(cb, null, cached);\n  if (cached === false) return nextTick(cb, null, undefined);\n  var dirs = parents(file ? path.dirname(file) : self.basedir);\n\n  (function next() {\n    if (dirs.length === 0) {\n      self.pkgCache[file] = false;\n      return cb(null, undefined);\n    }\n\n    var dir = dirs.shift();\n\n    if (dir.split(/[\\\\\\/]/).slice(-1)[0] === 'node_modules') {\n      return cb(null, undefined);\n    }\n\n    var pkgfile = path.join(dir, 'package.json');\n    var cached = self.pkgCache[pkgfile];\n    if (cached) return nextTick(cb, null, cached);else if (cached === false) return next();\n    var pcached = self.pkgFileCachePending[pkgfile];\n    if (pcached) return pcached.push(onpkg);\n    pcached = self.pkgFileCachePending[pkgfile] = [];\n    fs.readFile(pkgfile, function (err, src) {\n      if (err) return onpkg();\n\n      try {\n        var pkg = JSON.parse(src);\n      } catch (err) {\n        return onpkg(new Error([err + ' while parsing json file ' + pkgfile].join('')));\n      }\n\n      pkg.__dirname = dir;\n      self.pkgCache[pkgfile] = pkg;\n      self.pkgCache[file] = pkg;\n      onpkg(null, pkg);\n    });\n\n    function onpkg(err, pkg) {\n      if (self.pkgFileCachePending[pkgfile]) {\n        var fns = self.pkgFileCachePending[pkgfile];\n        delete self.pkgFileCachePending[pkgfile];\n        fns.forEach(function (f) {\n          f(err, pkg);\n        });\n      }\n\n      if (err) cb(err);else if (pkg) cb(null, pkg);else {\n        self.pkgCache[pkgfile] = false;\n        next();\n      }\n    }\n  })();\n};\n\nfunction getTransforms(pkg, opts) {\n  var trx = [];\n\n  if (opts.transformKey) {\n    var n = pkg;\n    var keys = opts.transformKey;\n\n    for (var i = 0; i < keys.length; i++) {\n      if (n && typeof n === 'object') n = n[keys[i]];else break;\n    }\n\n    if (i === keys.length) {\n      trx = [].concat(n).filter(Boolean);\n    }\n  }\n\n  return trx.concat(opts.globalTransform || []);\n}\n\nfunction nextTick(cb) {\n  var args = [].slice.call(arguments, 1);\n  process.nextTick(function () {\n    cb.apply(null, args);\n  });\n}\n\nfunction xhas(obj) {\n  if (!obj) return false;\n\n  for (var i = 1; i < arguments.length; i++) {\n    var key = arguments[i];\n    if (!has(obj, key)) return false;\n    obj = obj[key];\n  }\n\n  return true;\n}\n\nfunction toStream(dataAsString) {\n  var tr = through();\n  tr.push(dataAsString);\n  tr.push(null);\n  return tr;\n}\n\nfunction has(obj, key) {\n  return obj && Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction wrapTransform(tr) {\n  if (typeof tr.read === 'function') return tr;\n  var input = through(),\n      output = through();\n  input.pipe(tr).pipe(output);\n  var wrapper = duplexer(input, output);\n  tr.on('error', function (err) {\n    wrapper.emit('error', err);\n  });\n  return wrapper;\n}","map":null,"metadata":{},"sourceType":"script"}