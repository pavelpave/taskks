{"ast":null,"code":"/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n'use strict';\n\nvar isObject = require('isobject');\n\nvar isNumber = require('is-number');\n\nvar randomize = require('randomatic');\n\nvar repeatStr = require('repeat-string');\n\nvar repeat = require('repeat-element');\n/**\n * Expose `fillRange`\n */\n\n\nmodule.exports = fillRange;\n/**\n * Return a range of numbers or letters.\n *\n * @param  {String} `a` Start of the range\n * @param  {String} `b` End of the range\n * @param  {String} `step` Increment or decrement to use.\n * @param  {Function} `fn` Custom function to modify each element in the range.\n * @return {Array}\n */\n\nfunction fillRange(a, b, step, options, fn) {\n  if (a == null || b == null) {\n    throw new Error('fill-range expects the first and second args to be strings.');\n  }\n\n  if (typeof step === 'function') {\n    fn = step;\n    options = {};\n    step = null;\n  }\n\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  }\n\n  if (isObject(step)) {\n    options = step;\n    step = '';\n  }\n\n  var expand,\n      regex = false,\n      sep = '';\n  var opts = options || {};\n\n  if (typeof opts.silent === 'undefined') {\n    opts.silent = true;\n  }\n\n  step = step || opts.step; // store a ref to unmodified arg\n\n  var origA = a,\n      origB = b;\n  b = b.toString() === '-0' ? 0 : b;\n\n  if (opts.optimize || opts.makeRe) {\n    step = step ? step += '~' : step;\n    expand = true;\n    regex = true;\n    sep = '~';\n  } // handle special step characters\n\n\n  if (typeof step === 'string') {\n    var match = stepRe().exec(step);\n\n    if (match) {\n      var i = match.index;\n      var m = match[0]; // repeat string\n\n      if (m === '+') {\n        return repeat(a, b); // randomize a, `b` times\n      } else if (m === '?') {\n        return [randomize(a, b)]; // expand right, no regex reduction\n      } else if (m === '>') {\n        step = step.substr(0, i) + step.substr(i + 1);\n        expand = true; // expand to an array, or if valid create a reduced\n        // string for a regex logic `or`\n      } else if (m === '|') {\n        step = step.substr(0, i) + step.substr(i + 1);\n        expand = true;\n        regex = true;\n        sep = m; // expand to an array, or if valid create a reduced\n        // string for a regex range\n      } else if (m === '~') {\n        step = step.substr(0, i) + step.substr(i + 1);\n        expand = true;\n        regex = true;\n        sep = m;\n      }\n    } else if (!isNumber(step)) {\n      if (!opts.silent) {\n        throw new TypeError('fill-range: invalid step.');\n      }\n\n      return null;\n    }\n  }\n\n  if (/[.&*()[\\]^%$#@!]/.test(a) || /[.&*()[\\]^%$#@!]/.test(b)) {\n    if (!opts.silent) {\n      throw new RangeError('fill-range: invalid range arguments.');\n    }\n\n    return null;\n  } // has neither a letter nor number, or has both letters and numbers\n  // this needs to be after the step logic\n\n\n  if (!noAlphaNum(a) || !noAlphaNum(b) || hasBoth(a) || hasBoth(b)) {\n    if (!opts.silent) {\n      throw new RangeError('fill-range: invalid range arguments.');\n    }\n\n    return null;\n  } // validate arguments\n\n\n  var isNumA = isNumber(zeros(a));\n  var isNumB = isNumber(zeros(b));\n\n  if (!isNumA && isNumB || isNumA && !isNumB) {\n    if (!opts.silent) {\n      throw new TypeError('fill-range: first range argument is incompatible with second.');\n    }\n\n    return null;\n  } // by this point both are the same, so we\n  // can use A to check going forward.\n\n\n  var isNum = isNumA;\n  var num = formatStep(step); // is the range alphabetical? or numeric?\n\n  if (isNum) {\n    // if numeric, coerce to an integer\n    a = +a;\n    b = +b;\n  } else {\n    // otherwise, get the charCode to expand alpha ranges\n    a = a.charCodeAt(0);\n    b = b.charCodeAt(0);\n  } // is the pattern descending?\n\n\n  var isDescending = a > b; // don't create a character class if the args are < 0\n\n  if (a < 0 || b < 0) {\n    expand = false;\n    regex = false;\n  } // detect padding\n\n\n  var padding = isPadded(origA, origB);\n  var res,\n      pad,\n      arr = [];\n  var ii = 0; // character classes, ranges and logical `or`\n\n  if (regex) {\n    if (shouldExpand(a, b, num, isNum, padding, opts)) {\n      // make sure the correct separator is used\n      if (sep === '|' || sep === '~') {\n        sep = detectSeparator(a, b, num, isNum, isDescending);\n      }\n\n      return wrap([origA, origB], sep, opts);\n    }\n  }\n\n  while (isDescending ? a >= b : a <= b) {\n    if (padding && isNum) {\n      pad = padding(a);\n    } // custom function\n\n\n    if (typeof fn === 'function') {\n      res = fn(a, isNum, pad, ii++); // letters\n    } else if (!isNum) {\n      if (regex && isInvalidChar(a)) {\n        res = null;\n      } else {\n        res = String.fromCharCode(a);\n      } // numbers\n\n    } else {\n      res = formatPadding(a, pad);\n    } // add result to the array, filtering any nulled values\n\n\n    if (res !== null) arr.push(res); // increment or decrement\n\n    if (isDescending) {\n      a -= num;\n    } else {\n      a += num;\n    }\n  } // now that the array is expanded, we need to handle regex\n  // character classes, ranges or logical `or` that wasn't\n  // already handled before the loop\n\n\n  if ((regex || expand) && !opts.noexpand) {\n    // make sure the correct separator is used\n    if (sep === '|' || sep === '~') {\n      sep = detectSeparator(a, b, num, isNum, isDescending);\n    }\n\n    if (arr.length === 1 || a < 0 || b < 0) {\n      return arr;\n    }\n\n    return wrap(arr, sep, opts);\n  }\n\n  return arr;\n}\n/**\n * Wrap the string with the correct regex\n * syntax.\n */\n\n\nfunction wrap(arr, sep, opts) {\n  if (sep === '~') {\n    sep = '-';\n  }\n\n  var str = arr.join(sep);\n  var pre = opts && opts.regexPrefix; // regex logical `or`\n\n  if (sep === '|') {\n    str = pre ? pre + str : str;\n    str = '(' + str + ')';\n  } // regex character class\n\n\n  if (sep === '-') {\n    str = pre && pre === '^' ? pre + str : str;\n    str = '[' + str + ']';\n  }\n\n  return [str];\n}\n/**\n * Check for invalid characters\n */\n\n\nfunction isCharClass(a, b, step, isNum, isDescending) {\n  if (isDescending) {\n    return false;\n  }\n\n  if (isNum) {\n    return a <= 9 && b <= 9;\n  }\n\n  if (a < b) {\n    return step === 1;\n  }\n\n  return false;\n}\n/**\n * Detect the correct separator to use\n */\n\n\nfunction shouldExpand(a, b, num, isNum, padding, opts) {\n  if (isNum && (a > 9 || b > 9)) {\n    return false;\n  }\n\n  return !padding && num === 1 && a < b;\n}\n/**\n * Detect the correct separator to use\n */\n\n\nfunction detectSeparator(a, b, step, isNum, isDescending) {\n  var isChar = isCharClass(a, b, step, isNum, isDescending);\n\n  if (!isChar) {\n    return '|';\n  }\n\n  return '~';\n}\n/**\n * Correctly format the step based on type\n */\n\n\nfunction formatStep(step) {\n  return Math.abs(step >> 0) || 1;\n}\n/**\n * Format padding, taking leading `-` into account\n */\n\n\nfunction formatPadding(ch, pad) {\n  var res = pad ? pad + ch : ch;\n\n  if (pad && ch.toString().charAt(0) === '-') {\n    res = '-' + pad + ch.toString().substr(1);\n  }\n\n  return res.toString();\n}\n/**\n * Check for invalid characters\n */\n\n\nfunction isInvalidChar(str) {\n  var ch = toStr(str);\n  return ch === '\\\\' || ch === '[' || ch === ']' || ch === '^' || ch === '(' || ch === ')' || ch === '`';\n}\n/**\n * Convert to a string from a charCode\n */\n\n\nfunction toStr(ch) {\n  return String.fromCharCode(ch);\n}\n/**\n * Step regex\n */\n\n\nfunction stepRe() {\n  return /\\?|>|\\||\\+|\\~/g;\n}\n/**\n * Return true if `val` has either a letter\n * or a number\n */\n\n\nfunction noAlphaNum(val) {\n  return /[a-z0-9]/i.test(val);\n}\n/**\n * Return true if `val` has both a letter and\n * a number (invalid)\n */\n\n\nfunction hasBoth(val) {\n  return /[a-z][0-9]|[0-9][a-z]/i.test(val);\n}\n/**\n * Normalize zeros for checks\n */\n\n\nfunction zeros(val) {\n  if (/^-*0+$/.test(val.toString())) {\n    return '0';\n  }\n\n  return val;\n}\n/**\n * Return true if `val` has leading zeros,\n * or a similar valid pattern.\n */\n\n\nfunction hasZeros(val) {\n  return /[^.]\\.|^-*0+[0-9]/.test(val);\n}\n/**\n * If the string is padded, returns a curried function with\n * the a cached padding string, or `false` if no padding.\n *\n * @param  {*} `origA` String or number.\n * @return {String|Boolean}\n */\n\n\nfunction isPadded(origA, origB) {\n  if (hasZeros(origA) || hasZeros(origB)) {\n    var alen = length(origA);\n    var blen = length(origB);\n    var len = alen >= blen ? alen : blen;\n    return function (a) {\n      return repeatStr('0', len - length(a));\n    };\n  }\n\n  return false;\n}\n/**\n * Get the string length of `val`\n */\n\n\nfunction length(val) {\n  return val.toString().length;\n}","map":null,"metadata":{},"sourceType":"script"}