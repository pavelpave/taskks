{"ast":null,"code":"var Duplex = require('readable-stream').Duplex;\n\nvar PassThrough = require('readable-stream').PassThrough;\n\nvar Readable = require('readable-stream').Readable;\n\nvar inherits = require('inherits');\n\nvar nextTick = typeof setImmediate !== 'undefined' ? setImmediate : process.nextTick;\nmodule.exports = Pipeline;\ninherits(Pipeline, Duplex);\n\nmodule.exports.obj = function (streams, opts) {\n  if (!opts && !Array.isArray(streams)) {\n    opts = streams;\n    streams = [];\n  }\n\n  if (!streams) streams = [];\n  if (!opts) opts = {};\n  opts.objectMode = true;\n  return new Pipeline(streams, opts);\n};\n\nfunction Pipeline(streams, opts) {\n  if (!(this instanceof Pipeline)) return new Pipeline(streams, opts);\n\n  if (!opts && !Array.isArray(streams)) {\n    opts = streams;\n    streams = [];\n  }\n\n  if (!streams) streams = [];\n  if (!opts) opts = {};\n  Duplex.call(this, opts);\n  var self = this;\n  this._options = opts;\n  this._wrapOptions = {\n    objectMode: opts.objectMode !== false\n  };\n  this._streams = [];\n  this.splice.apply(this, [0, 0].concat(streams));\n  this.once('finish', function () {\n    self._notEmpty();\n\n    self._streams[0].end();\n  });\n}\n\nPipeline.prototype._read = function () {\n  var self = this;\n\n  this._notEmpty();\n\n  var r = this._streams[this._streams.length - 1];\n  var buf,\n      reads = 0;\n\n  while ((buf = r.read()) !== null) {\n    Duplex.prototype.push.call(this, buf);\n    reads++;\n  }\n\n  if (reads === 0) {\n    var onreadable = function onreadable() {\n      r.removeListener('readable', onreadable);\n      self.removeListener('_mutate', onreadable);\n\n      self._read();\n    };\n\n    r.once('readable', onreadable);\n    self.once('_mutate', onreadable);\n  }\n};\n\nPipeline.prototype._write = function (buf, enc, next) {\n  this._notEmpty();\n\n  this._streams[0]._write(buf, enc, next);\n};\n\nPipeline.prototype._notEmpty = function () {\n  var self = this;\n  if (this._streams.length > 0) return;\n  var stream = new PassThrough(this._options);\n  stream.once('end', function () {\n    var ix = self._streams.indexOf(stream);\n\n    if (ix >= 0 && ix === self._streams.length - 1) {\n      Duplex.prototype.push.call(self, null);\n    }\n  });\n\n  this._streams.push(stream);\n\n  this.length = this._streams.length;\n};\n\nPipeline.prototype.push = function (stream) {\n  var args = [this._streams.length, 0].concat([].slice.call(arguments));\n  this.splice.apply(this, args);\n  return this._streams.length;\n};\n\nPipeline.prototype.pop = function () {\n  return this.splice(this._streams.length - 1, 1)[0];\n};\n\nPipeline.prototype.shift = function () {\n  return this.splice(0, 1)[0];\n};\n\nPipeline.prototype.unshift = function () {\n  this.splice.apply(this, [0, 0].concat([].slice.call(arguments)));\n  return this._streams.length;\n};\n\nPipeline.prototype.splice = function (start, removeLen) {\n  var self = this;\n  var len = this._streams.length;\n  start = start < 0 ? len - start : start;\n  if (removeLen === undefined) removeLen = len - start;\n  removeLen = Math.max(0, Math.min(len - start, removeLen));\n\n  for (var i = start; i < start + removeLen; i++) {\n    if (self._streams[i - 1]) {\n      self._streams[i - 1].unpipe(self._streams[i]);\n    }\n  }\n\n  if (self._streams[i - 1] && self._streams[i]) {\n    self._streams[i - 1].unpipe(self._streams[i]);\n  }\n\n  var end = i;\n  var reps = [],\n      args = arguments;\n\n  for (var j = 2; j < args.length; j++) {\n    (function (stream) {\n      if (Array.isArray(stream)) {\n        stream = new Pipeline(stream, self._options);\n      }\n\n      stream.on('error', function (err) {\n        err.stream = this;\n        self.emit('error', err);\n      });\n      stream = self._wrapStream(stream);\n      stream.once('end', function () {\n        var ix = self._streams.indexOf(stream);\n\n        if (ix >= 0 && ix === self._streams.length - 1) {\n          Duplex.prototype.push.call(self, null);\n        }\n      });\n      reps.push(stream);\n    })(arguments[j]);\n  }\n\n  for (var i = 0; i < reps.length - 1; i++) {\n    reps[i].pipe(reps[i + 1]);\n  }\n\n  if (reps.length && self._streams[end]) {\n    reps[reps.length - 1].pipe(self._streams[end]);\n  }\n\n  if (reps[0] && self._streams[start - 1]) {\n    self._streams[start - 1].pipe(reps[0]);\n  }\n\n  var sargs = [start, removeLen].concat(reps);\n\n  var removed = self._streams.splice.apply(self._streams, sargs);\n\n  for (var i = 0; i < reps.length; i++) {\n    reps[i].read(0);\n  }\n\n  this.emit('_mutate');\n  this.length = this._streams.length;\n  return removed;\n};\n\nPipeline.prototype.get = function () {\n  if (arguments.length === 0) return undefined;\n  var base = this;\n\n  for (var i = 0; i < arguments.length; i++) {\n    var index = arguments[i];\n\n    if (index < 0) {\n      base = base._streams[base._streams.length + index];\n    } else {\n      base = base._streams[index];\n    }\n\n    if (!base) return undefined;\n  }\n\n  return base;\n};\n\nPipeline.prototype.indexOf = function (stream) {\n  return this._streams.indexOf(stream);\n};\n\nPipeline.prototype._wrapStream = function (stream) {\n  if (typeof stream.read === 'function') return stream;\n  var w = new Readable(this._wrapOptions).wrap(stream);\n\n  w._write = function (buf, enc, next) {\n    if (stream.write(buf) === false) {\n      stream.once('drain', next);\n    } else nextTick(next);\n  };\n\n  return w;\n};","map":null,"metadata":{},"sourceType":"script"}