{"ast":null,"code":"/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2015 Chris Talkington.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE\r\n */\nvar fs = require('graceful-fs');\n\nvar path = require('path');\n\nvar nutil = require('util');\n\nvar lazystream = require('lazystream');\n\nvar normalizePath = require('normalize-path');\n\nvar _ = require('lodash');\n\nvar Stream = require('stream').Stream;\n\nvar PassThrough = require('readable-stream').PassThrough;\n\nvar utils = module.exports = {};\nutils.file = require('./file.js');\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + nutils.inspect(path));\n  }\n}\n\nutils.collectStream = function (source, callback) {\n  var collection = [];\n  var size = 0;\n  source.on('error', callback);\n  source.on('data', function (chunk) {\n    collection.push(chunk);\n    size += chunk.length;\n  });\n  source.on('end', function () {\n    var buf = new Buffer(size);\n    var offset = 0;\n    collection.forEach(function (data) {\n      data.copy(buf, offset);\n      offset += data.length;\n    });\n    callback(null, buf);\n  });\n};\n\nutils.dateify = function (dateish) {\n  dateish = dateish || new Date();\n\n  if (dateish instanceof Date) {\n    dateish = dateish;\n  } else if (typeof dateish === 'string') {\n    dateish = new Date(dateish);\n  } else {\n    dateish = new Date();\n  }\n\n  return dateish;\n}; // this is slightly different from lodash version\n\n\nutils.defaults = function (object, source, guard) {\n  var args = arguments;\n  args[0] = args[0] || {};\n  return _.defaults.apply(_, args);\n};\n\nutils.isStream = function (source) {\n  return source instanceof Stream;\n};\n\nutils.lazyReadStream = function (filepath) {\n  return new lazystream.Readable(function () {\n    return fs.createReadStream(filepath);\n  });\n};\n\nutils.normalizeInputSource = function (source) {\n  if (source === null) {\n    return new Buffer(0);\n  } else if (typeof source === 'string') {\n    return new Buffer(source);\n  } else if (utils.isStream(source) && !source._readableState) {\n    var normalized = new PassThrough();\n    source.pipe(normalized);\n    return normalized;\n  }\n\n  return source;\n};\n\nutils.sanitizePath = function (filepath) {\n  return normalizePath(filepath, false).replace(/^\\w+:/, '').replace(/^(\\.\\.\\/|\\/)+/, '');\n};\n\nutils.trailingSlashIt = function (str) {\n  return str.slice(-1) !== '/' ? str + '/' : str;\n};\n\nutils.unixifyPath = function (filepath) {\n  return normalizePath(filepath, false).replace(/^\\w+:/, '');\n};\n\nutils.walkdir = function (dirpath, base, callback) {\n  var results = [];\n\n  if (typeof base === 'function') {\n    callback = base;\n    base = dirpath;\n  }\n\n  fs.readdir(dirpath, function (err, list) {\n    var i = 0;\n    var file;\n    var filepath;\n\n    if (err) {\n      return callback(err);\n    }\n\n    (function next() {\n      file = list[i++];\n\n      if (!file) {\n        return callback(null, results);\n      }\n\n      filepath = path.join(dirpath, file);\n      fs.stat(filepath, function (err, stats) {\n        results.push({\n          path: filepath,\n          relative: path.relative(base, filepath).replace(/\\\\/g, '/'),\n          stats: stats\n        });\n\n        if (stats && stats.isDirectory()) {\n          utils.walkdir(filepath, base, function (err, res) {\n            res.forEach(function (dirEntry) {\n              results.push(dirEntry);\n            });\n            next();\n          });\n        } else {\n          next();\n        }\n      });\n    })();\n  });\n};","map":null,"metadata":{},"sourceType":"script"}