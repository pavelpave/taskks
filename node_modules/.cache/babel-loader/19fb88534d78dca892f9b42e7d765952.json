{"ast":null,"code":"var __slice = Array.prototype.slice,\n    url = require('url'),\n    SPECIAL_KEYS = require('./special-keys'),\n    Webdriver = require('./webdriver'),\n    Element = require('./element'),\n    utils = require('./utils'),\n    deprecator = utils.deprecator,\n    config = require('./config'),\n    _ = require(\"lodash\"),\n    Q = require('q'),\n    actions = require('./actions');\n\nfunction buildConfigUrl(remoteWdConfig) {\n  var configUrl = _(remoteWdConfig).clone(); // for backward compatibility\n\n\n  if (configUrl.host && configUrl.host.indexOf(':') < 0 && configUrl.port) {\n    configUrl.hostname = configUrl.host;\n    delete configUrl.host;\n  } // for backward compatibility\n\n\n  if (configUrl.username) {\n    configUrl.user = configUrl.username;\n    delete configUrl.username;\n  } // for backward compatibility\n\n\n  if (configUrl.accessKey) {\n    configUrl.pwd = configUrl.accessKey;\n    delete configUrl.accessKey;\n  } // for backward compatibility\n\n\n  if (configUrl.https) {\n    configUrl.protocol = 'https:';\n    delete configUrl.https;\n  } // for backward compatibility\n\n\n  if (configUrl.path) {\n    configUrl.pathname = configUrl.path;\n    delete configUrl.path;\n  } // setting auth from user/password\n\n\n  if (configUrl.user && configUrl.pwd) {\n    configUrl.auth = configUrl.user + ':' + configUrl.pwd;\n    delete configUrl.user;\n    delete configUrl.pwd;\n  }\n\n  _.defaults(configUrl, {\n    protocol: 'http:',\n    hostname: '127.0.0.1',\n    port: '4444',\n    pathname: '/wd/hub'\n  }); // strip any trailing slashes from pathname\n\n\n  var parsed = url.parse(url.format(configUrl), true);\n\n  if (parsed.pathname[parsed.pathname.length - 1] === '/') {\n    parsed.pathname = parsed.pathname.slice(0, parsed.pathname.length - 1);\n  }\n\n  return parsed;\n} // parses server parameters\n\n\nvar parseRemoteWdConfig = function parseRemoteWdConfig(args) {\n  var config;\n\n  if (typeof args[0] === 'object') {\n    if (args[0].href && args[0].format) {\n      // was constructed with url.parse, so we don't modify it\n      config = args[0];\n    } else {\n      config = buildConfigUrl(args[0]);\n    }\n  } else if (typeof args[0] === 'string' && args[0].match(/^https?:\\/\\//)) {\n    config = url.parse(args[0]);\n  } else {\n    config = buildConfigUrl({\n      hostname: args[0],\n      port: args[1],\n      user: args[2],\n      pwd: args[3]\n    });\n  } // saucelabs automatic config\n\n\n  if (/saucelabs\\.com/.exec(config.hostname)) {\n    if (!config.auth && process.env.SAUCE_USERNAME && process.env.SAUCE_ACCESS_KEY) {\n      config.auth = process.env.SAUCE_USERNAME + ':' + process.env.SAUCE_ACCESS_KEY;\n    }\n  }\n\n  return config;\n};\n\nvar PromiseWebdriver, PromiseElement, PromiseChainWebdriver, PromiseChainElement; // Creates the Webdriver object\n// server parameters can be passed in 4 ways\n//   - as a url string\n//   - as a url object, constructed via url.parse\n//   - as a list of arguments host,port, user, pwd\n//   - as an option object containing the fields above\n// A `driverType` string may be passed at the end of the argument list.\n// If it is a valid type it will be detected even if the other arguments\n// are ommited. Valide types are: `remote`, `promise` and `promiseChain`.\n\nfunction remote() {\n  var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  var driverProtos = {\n    'async': Webdriver,\n    'promise': PromiseWebdriver,\n    'promiseChain': PromiseChainWebdriver\n  };\n\n  var driverTypes = _(driverProtos).keys();\n\n  var driverType = driverTypes.indexOf(_(args).last()) > 0 ? args.pop() : 'async';\n  var rwc = parseRemoteWdConfig(args);\n  return new driverProtos[driverType](rwc);\n}\n\nfunction wrap() {\n  var promiseProtos = require('./promise-webdriver')(Webdriver, Element, false);\n\n  PromiseWebdriver = promiseProtos.PromiseWebdriver;\n  PromiseElement = promiseProtos.PromiseElement;\n\n  var promiseChainProtos = require('./promise-webdriver')(Webdriver, Element, true);\n\n  PromiseChainWebdriver = promiseChainProtos.PromiseWebdriver;\n  PromiseChainElement = promiseChainProtos.PromiseElement;\n} // todo: allow adding element methods\n\n\nfunction addPromiseChainMethod(name, method) {\n  var wrappedMethod = function wrappedMethod() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    var promise = new Q(method.apply(this, args));\n\n    this._enrich(promise);\n\n    return promise;\n  };\n\n  PromiseChainWebdriver.prototype[name] = wrappedMethod;\n}\n\nfunction addElementPromiseChainMethod(name, method) {\n  var wrappedMethod = function wrappedMethod() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    var promise = new Q(method.apply(this, args));\n\n    this._enrich(promise);\n\n    return promise;\n  };\n\n  PromiseChainElement.prototype[name] = wrappedMethod;\n}\n\nfunction addPromiseMethod(name, method) {\n  var wrappedMethod = function wrappedMethod() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return new Q(method.apply(this, args));\n  };\n\n  PromiseWebdriver.prototype[name] = wrappedMethod;\n  addPromiseChainMethod(name, method);\n}\n\nfunction addElementPromiseMethod(name, method) {\n  var wrappedMethod = function wrappedMethod() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return new Q(method.apply(this, args));\n  };\n\n  PromiseElement.prototype[name] = wrappedMethod;\n  addElementPromiseChainMethod(name, method);\n}\n\nfunction addAsyncMethod(name, method) {\n  Webdriver.prototype[name] = method;\n  PromiseWebdriver.prototype[name] = PromiseWebdriver._wrapAsync(method);\n  PromiseChainWebdriver.prototype[name] = PromiseChainWebdriver._wrapAsync(method);\n}\n\nfunction addElementAsyncMethod(name, method) {\n  Element.prototype[name] = method;\n  PromiseElement.prototype[name] = PromiseWebdriver._wrapAsync(method);\n  PromiseChainElement.prototype[name] = PromiseChainWebdriver._wrapAsync(method);\n}\n\nfunction removeMethod(name) {\n  delete Webdriver.prototype[name];\n  delete PromiseWebdriver.prototype[name];\n  delete PromiseChainWebdriver.prototype[name];\n} // creates a webdriver object using the Q promise wrap not chained\n\n\nfunction asyncRemote() {\n  var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  var rwc = parseRemoteWdConfig(args);\n  return new Webdriver(rwc);\n} // creates a webdriver object using the Q promise wrap not chained\n\n\nfunction promiseRemote() {\n  var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  var rwc = parseRemoteWdConfig(args);\n  return new PromiseWebdriver(rwc);\n} // creates a webdriver object using the Q promise wrap chained\n\n\nfunction promiseChainRemote() {\n  var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  var rwc = parseRemoteWdConfig(args);\n  return new PromiseChainWebdriver(rwc);\n} // initial wrapping\n\n\nwrap();\nmodule.exports = {\n  // Retrieves browser\n  remote: remote,\n  asyncRemote: asyncRemote,\n  // Retrieves wrap browser\n  promiseRemote: promiseRemote,\n  promiseChainRemote: promiseChainRemote,\n  // Webdriver and Wrapper base classes\n  Webdriver: Webdriver,\n  webdriver: Webdriver,\n  // for backward compatibility\n  Element: Element,\n  PromiseChainWebdriver: PromiseChainWebdriver,\n  PromiseWebdriver: PromiseWebdriver,\n  TouchAction: actions.TouchAction,\n  MultiAction: actions.MultiAction,\n  InputDevice: actions.InputDevice,\n  W3CActions: actions.W3CActions,\n  // Actualizes promise wrappers\n  rewrap: function rewrap() {\n    deprecator.warn('rewrap', 'rewrap has been deprecated, use addAsyncMethod instead.');\n    wrap();\n  },\n  // config\n\n  /**\n   * wd.configureHttp(opts)\n   *\n   * opts example:\n   * {timeout:60000, retries: 3, 'retryDelay': 15, baseUrl='http://example.com/'}\n   * more info in README.\n   *\n   * @wd\n   */\n  configureHttp: config.configureHttp,\n  getHttpConfig: function getHttpConfig() {\n    return _(config.httpConfig).clone();\n  },\n  // deprecation\n\n  /**\n   * wd.showHideDeprecation(boolean)\n   *\n   * @wd\n   */\n  showHideDeprecation: deprecator.showHideDeprecation.bind(deprecator),\n  // add/remove methods\n\n  /**\n   * wd.addAsyncMethod(name, func)\n   *\n   * @wd\n   */\n  addAsyncMethod: addAsyncMethod,\n\n  /**\n   * wd.addElementAsyncMethod(name, func)\n   *\n   * @wd\n   */\n  addElementAsyncMethod: addElementAsyncMethod,\n\n  /**\n   * wd.addPromiseMethod(name, func)\n   *\n   * @wd\n   */\n  addPromiseMethod: addPromiseMethod,\n\n  /**\n   * wd.addElementPromiseMethod(name, func)\n   *\n   * @wd\n   */\n  addElementPromiseMethod: addElementPromiseMethod,\n\n  /**\n   * wd.addPromiseChainMethod(name, func)\n   *\n   * @wd\n   */\n  addPromiseChainMethod: addPromiseChainMethod,\n\n  /**\n   * wd.addElementPromiseChainMethod(name, func)\n   *\n   * @wd\n   */\n  addElementPromiseChainMethod: addElementPromiseChainMethod,\n\n  /**\n   * wd.removeMethod(name, func)\n   *\n   * @wd\n   */\n  removeMethod: removeMethod,\n  // Useful stuff\n  Asserter: require('./asserters').Asserter,\n  asserters: require('./asserters'),\n  SPECIAL_KEYS: SPECIAL_KEYS,\n  Q: Q,\n  findCallback: utils.findCallback,\n  varargs: utils.varargs,\n  transferPromiseness: utils.transferPromiseness,\n  // This is for people who write wrapper\n  // todo: That should not be needed.\n  utils: utils,\n  setBaseClasses: function setBaseClasses(_Webdriver, _Element) {\n    Webdriver = _Webdriver;\n    Element = _Element;\n    wrap();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}