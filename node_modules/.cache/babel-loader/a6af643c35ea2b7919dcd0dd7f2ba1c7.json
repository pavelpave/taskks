{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/garpix/task_react_App/myapp/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/garpix/task_react_App/myapp/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar request = require('request-promise-native');\n\nvar uuid = require('uuid');\n\nvar _require = require('./process'),\n    getProcess = _require.getProcess,\n    killProcess = _require.killProcess,\n    setAuthtoken = _require.setAuthtoken;\n\nvar internalApi;\nvar tunnels = {};\n\nfunction connect(_x) {\n  return _connect.apply(this, arguments);\n}\n\nfunction _connect() {\n  _connect = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(opts) {\n    var url;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            opts = defaults(opts);\n            validate(opts);\n\n            if (!opts.authtoken) {\n              _context.next = 5;\n              break;\n            }\n\n            _context.next = 5;\n            return setAuthtoken(opts);\n\n          case 5:\n            _context.next = 7;\n            return getProcess(opts);\n\n          case 7:\n            url = _context.sent;\n            internalApi = request.defaults({\n              baseUrl: url\n            });\n            return _context.abrupt(\"return\", connectRetry(opts));\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _connect.apply(this, arguments);\n}\n\nfunction defaults(opts) {\n  opts = opts || {\n    proto: 'http',\n    addr: 80\n  };\n  if (typeof opts === 'function') opts = {\n    proto: 'http',\n    addr: 80\n  };\n  if (typeof opts !== 'object') opts = {\n    proto: 'http',\n    addr: opts\n  };\n  if (!opts.proto) opts.proto = 'http';\n  if (!opts.addr) opts.addr = opts.port || opts.host || 80;\n  if (opts.httpauth) opts.auth = opts.httpauth;\n  return opts;\n}\n\nfunction validate(opts) {\n  if (opts.web_addr === false || opts.web_addr === 'false') {\n    throw new Error('web_addr:false is not supported, module depends on internal ngrok api');\n  }\n}\n\nfunction connectRetry(_x2) {\n  return _connectRetry.apply(this, arguments);\n}\n\nfunction _connectRetry() {\n  _connectRetry = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(opts) {\n    var retryCount,\n        response,\n        publicUrl,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            retryCount = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;\n            opts.name = String(opts.name || uuid.v4());\n            _context2.prev = 2;\n            _context2.next = 5;\n            return internalApi.post({\n              url: 'api/tunnels',\n              json: opts\n            });\n\n          case 5:\n            response = _context2.sent;\n            publicUrl = response.public_url;\n\n            if (publicUrl) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new Error('failed to start tunnel');\n\n          case 9:\n            tunnels[publicUrl] = response.uri;\n\n            if (opts.proto === 'http' && opts.bind_tls !== false) {\n              tunnels[publicUrl.replace('https', 'http')] = response.uri + ' (http)';\n            }\n\n            return _context2.abrupt(\"return\", publicUrl);\n\n          case 14:\n            _context2.prev = 14;\n            _context2.t0 = _context2[\"catch\"](2);\n\n            if (!(!isRetriable(_context2.t0) || retryCount >= 100)) {\n              _context2.next = 18;\n              break;\n            }\n\n            throw _context2.t0.error || _context2.t0.response;\n\n          case 18:\n            _context2.next = 20;\n            return new Promise(function (resolve) {\n              return setTimeout(resolve, 200);\n            });\n\n          case 20:\n            return _context2.abrupt(\"return\", connectRetry(opts, ++retryCount));\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[2, 14]]);\n  }));\n  return _connectRetry.apply(this, arguments);\n}\n\nfunction isRetriable(err) {\n  if (!err.response) return false;\n  var body = err.response.body;\n  var notReady500 = err.statusCode === 500 && /panic/.test(body);\n  var notReady502 = err.statusCode === 502 && body.details && body.details.err === 'tunnel session not ready yet';\n  return notReady500 || notReady502;\n}\n\nfunction disconnect(_x3) {\n  return _disconnect.apply(this, arguments);\n}\n\nfunction _disconnect() {\n  _disconnect = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(publicUrl) {\n    var disconnectAll, tunnelUrl;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (internalApi) {\n              _context3.next = 2;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 2:\n            if (publicUrl) {\n              _context3.next = 5;\n              break;\n            }\n\n            disconnectAll = Object.keys(tunnels).map(disconnect);\n            return _context3.abrupt(\"return\", Promise.all(disconnectAll));\n\n          case 5:\n            tunnelUrl = tunnels[publicUrl];\n\n            if (tunnelUrl) {\n              _context3.next = 8;\n              break;\n            }\n\n            throw new Error(\"there is no tunnel with url: \".concat(publicUrl));\n\n          case 8:\n            _context3.next = 10;\n            return internalApi.del(tunnelUrl);\n\n          case 10:\n            delete tunnels[publicUrl];\n\n          case 11:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _disconnect.apply(this, arguments);\n}\n\nfunction kill() {\n  return _kill.apply(this, arguments);\n}\n\nfunction _kill() {\n  _kill = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4() {\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (internalApi) {\n              _context4.next = 2;\n              break;\n            }\n\n            return _context4.abrupt(\"return\");\n\n          case 2:\n            _context4.next = 4;\n            return killProcess();\n\n          case 4:\n            internalApi = null;\n            tunnels = {};\n\n          case 6:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _kill.apply(this, arguments);\n}\n\nfunction getApi() {\n  return internalApi;\n}\n\nmodule.exports = {\n  connect: connect,\n  disconnect: disconnect,\n  authtoken: setAuthtoken,\n  kill: kill,\n  getApi: getApi\n};","map":null,"metadata":{},"sourceType":"script"}