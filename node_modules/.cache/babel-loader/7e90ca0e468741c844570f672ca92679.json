{"ast":null,"code":"var fs = require(\"fs\"),\n    url = require('url'),\n    path = require('path'),\n    tmp = require('./tmp'),\n    _ = require(\"lodash\"),\n    async = require('async'),\n    __slice = Array.prototype.slice,\n    config = require('./config'),\n    callbacks = require(\"./callbacks\"),\n    callbackWithData = callbacks.callbackWithData,\n    simpleCallback = callbacks.simpleCallback,\n    elementCallback = callbacks.elementCallback,\n    elementsCallback = callbacks.elementsCallback,\n    elementOrElementsCallback = callbacks.elementOrElementsCallback,\n    utils = require(\"./utils\"),\n    findCallback = utils.findCallback,\n    codeToString = utils.codeToString,\n    deprecator = utils.deprecator,\n    asserters = require(\"./asserters\"),\n    Asserter = asserters.Asserter,\n    safeExecuteJsScript = require('../build/safe-execute'),\n    safeExecuteAsyncJsScript = require('../build/safe-execute-async'),\n    _waitForConditionInBrowserJsScript = require('../build/wait-for-cond-in-browser');\n\nvar commands = {};\n/**\n * init(desired, cb) -> cb(err, sessionID, capabilities)\n * Initialize the browser. capabilities return may be\n * absent, depending on driver.\n *\n * @jsonWire POST /session\n */\n\ncommands.init = function () {\n  var args = __slice.call(arguments, 0);\n\n  this._init.apply(this, args);\n};\n/**\n * status(cb) -> cb(err, status)\n *\n * @jsonWire GET /status\n */\n\n\ncommands.status = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    absPath: 'status',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * sessions(cb) -> cb(err, sessions)\n *\n * @jsonWire GET /sessions\n */\n\n\ncommands.sessions = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    absPath: 'sessions',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * Retrieves the current session id.\n * getSessionId(cb) -> cb(err, sessionId)\n * getSessionId()\n */\n\n\ncommands.getSessionId = function () {\n  var cb = findCallback(arguments);\n\n  if (cb) {\n    cb(null, this.sessionID);\n  }\n\n  return this.sessionID;\n};\n\ncommands.getSessionID = commands.getSessionId;\n/**\n * execute(code, args, cb) -> cb(err, result)\n * execute(code, cb) -> cb(err, result)\n * args: script argument array (optional)\n *\n * @jsonWire POST /session/:sessionId/execute\n * @docOrder 1\n */\n\ncommands.execute = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      code = fargs.all[0],\n      args = fargs.all[1] || [];\n  code = codeToString(code);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/execute',\n    cb: callbackWithData(cb, this),\n    data: {\n      script: code,\n      args: args\n    }\n  });\n};\n/**\n * Safely execute script within an eval block, always returning:\n * safeExecute(code, args, cb) -> cb(err, result)\n * safeExecute(code, cb) -> cb(err, result)\n * args: script argument array (optional)\n *\n * @jsonWire POST /session/:sessionId/execute\n * @docOrder 2\n */\n\n\ncommands.safeExecute = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      code = fargs.all[0],\n      args = fargs.all[1] || [];\n  code = codeToString(code);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/execute',\n    cb: callbackWithData(cb, this),\n    data: {\n      script: safeExecuteJsScript,\n      args: [code, args]\n    }\n  });\n};\n/**\n * Evaluate expression (using execute):\n * eval(code, cb) -> cb(err, value)\n *\n * @jsonWire POST /session/:sessionId/execute\n */\n\n\n(function () {\n  // jshint evil: true\n  commands.eval = function (code) {\n    var cb = findCallback(arguments);\n    code = codeToString(code);\n    code = \"return \" + code + \";\";\n    commands.execute.apply(this, [code, function (err, res) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, res);\n    }]);\n  };\n})();\n/**\n * Safely evaluate expression, always returning  (using safeExecute):\n * safeEval(code, cb) -> cb(err, value)\n *\n * @jsonWire POST /session/:sessionId/execute\n */\n\n\ncommands.safeEval = function (code) {\n  var cb = findCallback(arguments);\n  code = codeToString(code);\n  commands.safeExecute.apply(this, [code, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res);\n  }]);\n};\n/**\n * executeAsync(code, args, cb) -> cb(err, result)\n * executeAsync(code, cb) -> cb(err, result)\n * args: script argument array (optional)\n *\n * @jsonWire POST /session/:sessionId/execute_async\n */\n\n\ncommands.executeAsync = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      code = fargs.all[0],\n      args = fargs.all[1] || [];\n  code = codeToString(code);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/execute_async',\n    cb: callbackWithData(cb, this),\n    data: {\n      script: code,\n      args: args\n    }\n  });\n};\n/**\n * Safely execute async script within an eval block, always returning:\n * safeExecuteAsync(code, args, cb) -> cb(err, result)\n * safeExecuteAsync(code, cb) -> cb(err, result)\n * args: script argument array (optional)\n *\n * @jsonWire POST /session/:sessionId/execute_async\n */\n\n\ncommands.safeExecuteAsync = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      code = fargs.all[0],\n      args = fargs.all[1] || [];\n  code = codeToString(code);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/execute_async',\n    cb: callbackWithData(cb, this),\n    data: {\n      script: safeExecuteAsyncJsScript,\n      args: [code, args]\n    }\n  });\n};\n/**\n * Alternate strategy to get session capabilities from server session list:\n * altSessionCapabilities(cb) -> cb(err, capabilities)\n *\n * @jsonWire GET /sessions\n */\n\n\ncommands.altSessionCapabilities = function () {\n  var cb = findCallback(arguments);\n\n  var _this = this; // looking for the current session\n\n\n  commands.sessions.apply(this, [function (err, sessions) {\n    if (err) {\n      cb(err, sessions);\n    } else {\n      sessions = sessions.filter(function (session) {\n        return session.id === _this.sessionID;\n      });\n      cb(null, sessions[0] ? sessions[0].capabilities : 0);\n    }\n  }]);\n};\n/**\n * sessionCapabilities(cb) -> cb(err, capabilities)\n *\n * @jsonWire GET /session/:sessionId\n */\n\n\ncommands.sessionCapabilities = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET' // default url\n    ,\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * Opens a new window (using Javascript window.open):\n * newWindow(url, name, cb) -> cb(err)\n * newWindow(url, cb) -> cb(err)\n * name: optional window name\n * Window can later be accessed by name with the window method,\n * or by getting the last handle returned by the windowHandles method.\n */\n\n\ncommands.newWindow = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      url = fargs.all[0],\n      name = fargs.all[1];\n  commands.execute.apply(this, [\"var url=arguments[0], name=arguments[1]; window.open(url, name);\", [url, name], cb]);\n};\n/**\n * close(cb) -> cb(err)\n *\n * @jsonWire DELETE /session/:sessionId/window\n */\n\n\ncommands.close = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'DELETE',\n    relPath: '/window',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * currentContext(cb) -> cb(err)\n *\n * @jsonWire GET /session/:sessionId/context\n */\n\n\ncommands.currentContext = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/context',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * context(contextRef, cb) -> cb(err, context)\n *\n * @jsonWire POST /session/:sessionId/context\n */\n\n\ncommands.context = function (contextRef) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/context',\n    cb: simpleCallback(cb),\n    data: {\n      name: contextRef\n    }\n  });\n};\n/**\n * contexts(cb) -> cb(err, handle)\n *\n * @jsonWire GET /session/:sessionId/contexts\n */\n\n\ncommands.contexts = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/contexts',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * window(name, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/window\n */\n\n\ncommands.window = function (windowRef) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/window',\n    cb: simpleCallback(cb),\n    data: {\n      name: windowRef\n    }\n  });\n};\n/**\n * frame(frameRef, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/frame\n */\n\n\ncommands.frame = function (frameRef) {\n  var cb = findCallback(arguments); // avoid using this, Webdriver seems very buggy\n  // doesn't work at all with chromedriver\n\n  if (typeof frameRef === 'function') {\n    frameRef = null;\n  }\n\n  if (frameRef !== null && typeof frameRef.value !== \"undefined\") {\n    // we have an element object\n    frameRef = {\n      ELEMENT: frameRef.value\n    };\n    frameRef[utils.w3cElementKeyId] = frameRef.value;\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/frame',\n    cb: simpleCallback(cb),\n    data: {\n      id: frameRef\n    }\n  });\n};\n/**\n * windowName(cb) -> cb(err, name)\n */\n\n\ncommands.windowName = function () {\n  var cb = findCallback(arguments); // jshint evil: true\n\n  commands.eval.apply(this, [\"window.name\", cb]);\n};\n/**\n * windowHandle(cb) -> cb(err, handle)\n *\n * @jsonWire GET /session/:sessionId/window_handle\n */\n\n\ncommands.windowHandle = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/window_handle',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * windowHandles(cb) -> cb(err, arrayOfHandles)\n *\n * @jsonWire GET /session/:sessionId/window_handles\n */\n\n\ncommands.windowHandles = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/window_handles',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getGeoLocation(cb) -> cb(err, geoLocationObj)\n *\n * @jsonWire GET /session/:sessionId/location\n */\n\n\ncommands.getGeoLocation = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/location',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * setGeoLocation(lat, lon, alt, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/location\n */\n\n\ncommands.setGeoLocation = function (lat, lon, alt) {\n  var cb = findCallback(arguments);\n\n  if (typeof alt === 'function') {\n    alt = 0;\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/location',\n    cb: simpleCallback(cb),\n    data: {\n      location: {\n        latitude: lat,\n        longitude: lon,\n        altitude: alt\n      }\n    }\n  });\n};\n/**\n * scroll(xOffset, yOffset, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/touch/scroll\n */\n\n\ncommands.scroll = function (xOffset, yOffset) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/touch/scroll',\n    cb: simpleCallback(cb, this),\n    data: {\n      xoffset: xOffset,\n      yoffset: yOffset\n    }\n  });\n};\n/**\n * logTypes(cb) -> cb(err, arrayOfLogTypes)\n *\n * @jsonWire GET /session/:sessionId/log/types\n */\n\n\ncommands.logTypes = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/log/types',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * log(logType, cb) -> cb(err, arrayOfLogs)\n *\n * @jsonWire POST /session/:sessionId/log\n */\n\n\ncommands.log = function (logType) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/log',\n    cb: callbackWithData(cb, this),\n    data: {\n      type: logType\n    }\n  });\n};\n/**\n * quit(cb) -> cb(err)\n * Destroy the browser.\n *\n * @jsonWire DELETE /session/:sessionId\n */\n\n\ncommands.quit = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'DELETE' // default url\n    ,\n    emit: {\n      event: 'status',\n      message: '\\nEnding your web drivage..\\n'\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * get(url,cb) -> cb(err)\n * Get a new url.\n *\n * @jsonWire POST /session/:sessionId/url\n */\n\n\ncommands.get = function (_url) {\n  if (this._httpConfig.baseUrl) {\n    _url = url.resolve(this._httpConfig.baseUrl, _url);\n  }\n\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/url',\n    data: {\n      'url': _url\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * refresh(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/refresh\n */\n\n\ncommands.refresh = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/refresh',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n  * maximize(handle, cb) -> cb(err)\n  *\n  * @jsonWire POST /session/:sessionId/window/:windowHandle/maximize\n */\n\n\ncommands.maximize = function (win) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/window/' + win + '/maximize',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n  * windowSize(handle, width, height, cb) -> cb(err)\n  *\n  * @jsonWire POST /session/:sessionId/window/:windowHandle/size\n */\n\n\ncommands.windowSize = function (win, width, height) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/window/' + win + '/size',\n    data: {\n      'width': width,\n      'height': height\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n  * getWindowSize(handle, cb) -> cb(err, size)\n  * getWindowSize(cb) -> cb(err, size)\n  * handle: window handle to get size (optional, default: 'current')\n  *\n  * @jsonWire GET /session/:sessionId/window/:windowHandle/size\n */\n\n\ncommands.getWindowSize = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      win = fargs.all[0] || 'current';\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/window/' + win + '/size',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n  * setWindowSize(width, height, handle, cb) -> cb(err)\n  * setWindowSize(width, height, cb) -> cb(err)\n  * width: width in pixels to set size to\n  * height: height in pixels to set size to\n  * handle: window handle to set size for (optional, default: 'current')\n  * @jsonWire POST /session/:sessionId/window/:windowHandle/size\n */\n\n\ncommands.setWindowSize = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      width = fargs.all[0],\n      height = fargs.all[1],\n      win = fargs.all[2] || 'current';\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/window/' + win + '/size',\n    cb: simpleCallback(cb),\n    data: {\n      width: width,\n      height: height\n    }\n  });\n};\n/**\n  * getWindowPosition(handle, cb) -> cb(err, position)\n  * getWindowPosition(cb) -> cb(err, position)\n  * handle: window handle to get position (optional, default: 'current')\n  *\n  * @jsonWire GET /session/:sessionId/window/:windowHandle/position\n */\n\n\ncommands.getWindowPosition = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      win = fargs.all[0] || 'current';\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/window/' + win + '/position',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n  * setWindowPosition(x, y, handle, cb) -> cb(err)\n  * setWindowPosition(x, y, cb) -> cb(err)\n  * x: the x-coordinate in pixels to set the window position\n  * y: the y-coordinate in pixels to set the window position\n  * handle: window handle to set position for (optional, default: 'current')\n  * @jsonWire POST /session/:sessionId/window/:windowHandle/position\n */\n\n\ncommands.setWindowPosition = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      x = fargs.all[0],\n      y = fargs.all[1],\n      win = fargs.all[2] || 'current';\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/window/' + win + '/position',\n    cb: simpleCallback(cb),\n    data: {\n      x: x,\n      y: y\n    }\n  });\n};\n/**\n * forward(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/forward\n */\n\n\ncommands.forward = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/forward',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * back(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/back\n */\n\n\ncommands.back = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/back',\n    cb: simpleCallback(cb)\n  });\n};\n\ncommands.setHttpTimeout = function () {\n  deprecator.warn('setHttpTimeout', 'setHttpTimeout/setHTTPInactivityTimeout has been deprecated, use configureHttp instead.');\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      ms = fargs.all[0];\n  commands.configureHttp({\n    timeout: ms\n  }, cb);\n};\n\ncommands.setHTTPInactivityTimeout = commands.setHttpTimeout;\n/**\n * configureHttp(opts)\n *\n * opts example:\n * {timeout:60000, retries: 3, 'retryDelay': 15, baseUrl='http://example.com/'}\n * more info in README.\n *\n */\n\ncommands.configureHttp = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      opts = fargs.all[0];\n\n  config._configureHttp(this._httpConfig, opts);\n\n  if (cb) {\n    cb(null);\n  }\n};\n/**\n * setImplicitWaitTimeout(ms, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/timeouts/implicit_wait\n */\n\n\ncommands.setImplicitWaitTimeout = function (ms) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/timeouts/implicit_wait',\n    data: {\n      ms: ms\n    },\n    cb: simpleCallback(cb)\n  });\n}; // for backward compatibility\n\n\ncommands.setWaitTimeout = commands.setImplicitWaitTimeout;\n/**\n * setAsyncScriptTimeout(ms, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/timeouts/async_script\n */\n\ncommands.setAsyncScriptTimeout = function (ms) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/timeouts/async_script',\n    data: {\n      ms: ms\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * setPageLoadTimeout(ms, cb) -> cb(err)\n * (use setImplicitWaitTimeout and setAsyncScriptTimeout to set the other timeouts)\n *\n * @jsonWire POST /session/:sessionId/timeouts\n */\n\n\ncommands.setPageLoadTimeout = function (ms) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/timeouts',\n    data: {\n      type: 'page load',\n      ms: ms\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * setCommandTimeout(ms, cb) -> cb(err)\n * (this is for Appium only)\n * @jsonWire POST /session/:sessionId/timeouts\n */\n\n\ncommands.setCommandTimeout = function (ms) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/timeouts',\n    data: {\n      type: 'command',\n      ms: ms\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * element(using, value, cb) -> cb(err, element)\n *\n * @jsonWire POST /session/:sessionId/element\n */\n\n\ncommands.element = function (using, value) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/element',\n    data: {\n      using: using,\n      value: value\n    },\n    cb: elementCallback(cb, this)\n  });\n};\n/**\n * Retrieve an element avoiding not found exception and returning null instead:\n * elementOrNull(using, value, cb) -> cb(err, element)\n *\n * @jsonWire POST /session/:sessionId/elements\n * @docOrder 3\n */\n\n\ncommands.elementOrNull = function (using, value) {\n  var cb = findCallback(arguments);\n  commands.elements.apply(this, [using, value, function (err, elements) {\n    if (!err) {\n      if (elements.length > 0) {\n        cb(null, elements[0]);\n      } else {\n        cb(null, null);\n      }\n    } else {\n      cb(err);\n    }\n  }]);\n};\n/**\n * Retrieve an element avoiding not found exception and returning undefined instead:\n * elementIfExists(using, value, cb) -> cb(err, element)\n *\n * @jsonWire POST /session/:sessionId/elements\n * @docOrder 5\n */\n\n\ncommands.elementIfExists = function (using, value) {\n  var cb = findCallback(arguments);\n  commands.elements.apply(this, [using, value, function (err, elements) {\n    if (!err) {\n      if (elements.length > 0) {\n        cb(null, elements[0]);\n      } else {\n        cb(null);\n      }\n    } else {\n      cb(err);\n    }\n  }]);\n};\n/**\n * elements(using, value, cb) -> cb(err, elements)\n *\n * @jsonWire POST /session/:sessionId/elements\n * @docOrder 1\n */\n\n\ncommands.elements = function (using, value) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/elements',\n    data: {\n      using: using,\n      value: value\n    },\n    cb: elementsCallback(cb, this)\n  });\n};\n/**\n * Check if element exists:\n * hasElement(using, value, cb) -> cb(err, boolean)\n *\n * @jsonWire POST /session/:sessionId/elements\n * @docOrder 7\n */\n\n\ncommands.hasElement = function (using, value) {\n  var cb = findCallback(arguments);\n  commands.elements.apply(this, [using, value, function (err, elements) {\n    if (!err) {\n      cb(null, elements.length > 0);\n    } else {\n      cb(err);\n    }\n  }]);\n};\n/**\n * waitFor(asserter, timeout, pollFreq, cb) -> cb(err, return_value)\n * timeout and pollFreq are optional (default 1000ms/200ms)\n * waitFor(opts, cb) -> cb(err)\n * opts with the following fields: timeout, pollFreq, asserter.\n * asserter like: function(browser , cb) -> cb(err, satisfied, return_value)\n */\n\n\ncommands.waitFor = function () {\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var opts; // retrieving options\n\n  if (typeof fargs.all[0] === 'object' && !(fargs.all[0] instanceof Asserter)) {\n    opts = fargs.all[0];\n  } else {\n    opts = {\n      asserter: fargs.all[0],\n      timeout: fargs.all[1],\n      pollFreq: fargs.all[2]\n    };\n  } // default\n\n\n  opts.timeout = opts.timeout || 1000;\n  opts.pollFreq = opts.pollFreq || 200;\n\n  if (!opts.asserter) {\n    throw new Error('Missing asserter!');\n  }\n\n  var _this = this;\n\n  var endTime = Date.now() + opts.timeout;\n  var unpromisedAsserter = new Asserter(function (browser, cb) {\n    var promise = opts.asserter.assert(browser, cb);\n\n    if (promise && promise.then && typeof promise.then === 'function') {\n      promise.then(function (res) {\n        cb(null, true, res);\n      }, function (err) {\n        if (err.retriable) {\n          cb(null, false);\n        } else {\n          throw err;\n        }\n      });\n    }\n  });\n\n  function poll(isFinalCheck) {\n    unpromisedAsserter.assert(_this, function (err, satisfied, value) {\n      if (err && err.message.indexOf(\"timeout\") === -1) {\n        return cb(err);\n      }\n\n      if (satisfied) {\n        cb(null, value);\n      } else {\n        if (isFinalCheck) {\n          cb(err || new Error(\"Condition wasn't satisfied!\"));\n        } else if (Date.now() > endTime) {\n          // trying one more time for safety\n          setTimeout(poll.bind(null, true), opts.pollFreq);\n        } else {\n          setTimeout(poll, opts.pollFreq);\n        }\n      }\n    });\n  }\n\n  poll();\n};\n/**\n * waitForElement(using, value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n * waitForElement(using, value, timeout, pollFreq, cb) -> cb(err, el)\n * timeout and pollFreq are optional (default 1000ms/200ms)\n * waitForElement(using, value, opts, cb) -> cb(err, el)\n * opts with the following fields: timeout, pollFreq, asserter.\n * asserter like: function(element , cb) -> cb(err, satisfied, el)\n */\n\n\ncommands.waitForElement = function () {\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var using = fargs.all[0],\n      value = fargs.all[1];\n  var opts; // retrieving options\n\n  if (typeof fargs.all[2] === 'object' && !(fargs.all[2] instanceof Asserter)) {\n    opts = fargs.all[2];\n  } else if (fargs.all[2] instanceof Asserter) {\n    opts = {\n      asserter: fargs.all[2],\n      timeout: fargs.all[3],\n      pollFreq: fargs.all[4]\n    };\n  } else {\n    opts = {\n      timeout: fargs.all[2],\n      pollFreq: fargs.all[3]\n    };\n  } // default\n\n\n  opts.asserter = opts.asserter || new Asserter(function (el, cb) {\n    cb(null, true);\n  });\n  var unpromisedAsserter = new Asserter(function (el, cb) {\n    var promise = opts.asserter.assert(el, cb);\n\n    if (promise && promise.then && typeof promise.then === 'function') {\n      promise.then(function () {\n        cb(null, true);\n      }, function (err) {\n        if (err.retriable) {\n          cb(null, false);\n        } else {\n          throw err;\n        }\n      });\n    }\n  });\n  var wrappedAsserter = new Asserter(function (browser, cb) {\n    browser.elements(using, value, function (err, els) {\n      if (err) {\n        return cb(err);\n      }\n\n      var seq = [];\n      var satisfiedEl;\n\n      _(els).each(function (el) {\n        seq.push(function (cb) {\n          if (satisfiedEl) {\n            return cb();\n          }\n\n          unpromisedAsserter.assert(el, function (err, satisfied) {\n            if (err) {\n              return cb(err);\n            }\n\n            if (satisfied) {\n              satisfiedEl = el;\n            }\n\n            cb(err);\n          });\n        });\n      });\n\n      async.series(seq, function (err) {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(err, !_.isUndefined(satisfiedEl), satisfiedEl);\n      });\n    });\n  });\n  commands.waitFor.apply(this, [{\n    asserter: wrappedAsserter,\n    timeout: opts.timeout,\n    pollFreq: opts.pollFreq\n  }, function (err, value) {\n    if (err && err.message && err.message.match(/Condition/)) {\n      cb(new Error(\"Element condition wasn't satisfied!\"));\n    } else {\n      cb(err, value);\n    }\n  }]);\n};\n/**\n * waitForElements(using, value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n * waitForElements(using, value, timeout, pollFreq, cb) -> cb(err, els)\n * timeout and pollFreq are optional (default 1000ms/200ms)\n * waitForElements(using, value, opts, cb) -> cb(err, els)\n * opts with the following fields: timeout, pollFreq, asserter.\n * asserter like: function(element , cb) -> cb(err, satisfied, el)\n */\n\n\ncommands.waitForElements = function () {\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var using = fargs.all[0],\n      value = fargs.all[1];\n  var opts; // retrieving options\n\n  if (typeof fargs.all[2] === 'object' && !(fargs.all[2] instanceof Asserter)) {\n    opts = fargs.all[2];\n  } else if (fargs.all[2] instanceof Asserter) {\n    opts = {\n      asserter: fargs.all[2],\n      timeout: fargs.all[3],\n      pollFreq: fargs.all[4]\n    };\n  } else {\n    opts = {\n      timeout: fargs.all[2],\n      pollFreq: fargs.all[3]\n    };\n  } // default\n\n\n  opts.asserter = opts.asserter || new Asserter(function (el, cb) {\n    cb(null, true);\n  });\n  var unpromisedAsserter = new Asserter(function (el, cb) {\n    var promise = opts.asserter.assert(el, cb);\n\n    if (promise && promise.then && typeof promise.then === 'function') {\n      promise.then(function () {\n        cb(null, true);\n      }, function (err) {\n        if (err.retriable) {\n          cb(null, false);\n        } else {\n          throw err;\n        }\n      });\n    }\n  });\n  var wrappedAsserter = new Asserter(function (browser, cb) {\n    browser.elements(using, value, function (err, els) {\n      if (err) {\n        return cb(err);\n      }\n\n      var seq = [];\n      var satisfiedEls = [];\n\n      _(els).each(function (el) {\n        seq.push(function (cb) {\n          unpromisedAsserter.assert(el, function (err, satisfied) {\n            if (err) {\n              return cb(err);\n            }\n\n            if (satisfied) {\n              satisfiedEls.push(el);\n            }\n\n            cb(err);\n          });\n        });\n      });\n\n      async.series(seq, function (err) {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(err, satisfiedEls.length > 0, satisfiedEls);\n      });\n    });\n  });\n  commands.waitFor.apply(this, [{\n    asserter: wrappedAsserter,\n    timeout: opts.timeout,\n    pollFreq: opts.pollFreq\n  }, function (err, value) {\n    if (err && err.message && err.message.match(/Condition/)) {\n      cb(new Error(\"Element condition wasn't satisfied!\"));\n    } else {\n      cb(err, value);\n    }\n  }]);\n};\n\ncommands.waitForVisible = function (using, value, timeout, pollFreq) {\n  deprecator.warn('waitForVisible', 'waitForVisible has been deprecated, use waitForElement + isVisible asserter instead.');\n  var cb = findCallback(arguments);\n  commands.waitForElement.apply(this, [using, value, asserters.isVisible, timeout, pollFreq, function (err, isVisible) {\n    if (err && err.message && err.message.match(/Element condition wasn't satisfied!/)) {\n      cb(new Error(\"Element didn't become visible\"));\n    } else {\n      cb(err, isVisible);\n    }\n  }]);\n};\n/**\n * takeScreenshot(cb) -> cb(err, screenshot)\n *\n * @jsonWire GET /session/:sessionId/screenshot\n */\n\n\ncommands.takeScreenshot = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/screenshot',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * saveScreenshot(path, cb) -> cb(err, filePath)\n *\n * path maybe a full file path, a directory path (finishing with /),\n * the screenshot name, or left blank (will create a file in the system temp dir).\n */\n\n\ncommands.saveScreenshot = function () {\n  var _this = this;\n\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var _path = fargs.all[0];\n\n  function buildFilePath(_path, cb) {\n    if (!_path) {\n      _path = tmp.tmpdir + '/';\n    }\n\n    if (_path.match(/.*\\/$/)) {\n      tmp.tmpName({\n        template: 'screenshot-XXXXXX.png'\n      }, function (err, fileName) {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, path.join(_path, fileName));\n      });\n    } else {\n      if (path.extname(_path) === '') {\n        _path = _path + '.png';\n      }\n\n      cb(null, _path);\n    }\n  }\n\n  buildFilePath(_path, function (err, filePath) {\n    commands.takeScreenshot.apply(_this, [function (err, base64Data) {\n      if (err) {\n        return cb(err);\n      }\n\n      require(\"fs\").writeFile(filePath, base64Data, 'base64', function (err) {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, filePath);\n      });\n    }]);\n  });\n}; // adding all elementBy... , elementsBy... function\n\n\nvar addMethodsForSuffix = function addMethodsForSuffix(type, singular, plural) {\n  if (singular) {\n    /**\n     * elementByClassName(value, cb) -> cb(err, element)\n     * elementByCssSelector(value, cb) -> cb(err, element)\n     * elementById(value, cb) -> cb(err, element)\n     * elementByName(value, cb) -> cb(err, element)\n     * elementByLinkText(value, cb) -> cb(err, element)\n     * elementByPartialLinkText(value, cb) -> cb(err, element)\n     * elementByTagName(value, cb) -> cb(err, element)\n     * elementByXPath(value, cb) -> cb(err, element)\n     * elementByCss(value, cb) -> cb(err, element)\n     * elementByIosUIAutomation(value, cb) -> cb(err, element)\n     * elementByIosClassChain(value, cb) -> cb(err, element)\n     * elementByIosPredicateString(value, cb) -> cb(err, element)\n     * elementByAndroidUIAutomator(value, cb) -> cb(err, element)\n     * elementByAccessibilityId(value, cb) -> cb(err, element)\n     *\n     * @jsonWire POST /session/:sessionId/element\n     */\n    commands['element' + utils.elFuncSuffix(type)] = function () {\n      var args = __slice.call(arguments, 0);\n\n      args.unshift(utils.elFuncFullType(type));\n      commands.element.apply(this, args);\n    };\n    /**\n     * elementByClassNameOrNull(value, cb) -> cb(err, element)\n     * elementByCssSelectorOrNull(value, cb) -> cb(err, element)\n     * elementByIdOrNull(value, cb) -> cb(err, element)\n     * elementByNameOrNull(value, cb) -> cb(err, element)\n     * elementByLinkTextOrNull(value, cb) -> cb(err, element)\n     * elementByPartialLinkTextOrNull(value, cb) -> cb(err, element)\n     * elementByTagNameOrNull(value, cb) -> cb(err, element)\n     * elementByXPathOrNull(value, cb) -> cb(err, element)\n     * elementByCssOrNull(value, cb) -> cb(err, element)\n     * elementByIosUIAutomationOrNull(value, cb) -> cb(err, element)\n     * elementByIosClassChainOrNull(value, cb) -> cb(err, element)\n     * elementByIosPredicateStringOrNull(value, cb) -> cb(err, element)\n     * elementByAndroidUIAutomatorOrNull(value, cb) -> cb(err, element)\n     * elementByAccessibilityIdOrNull(value, cb) -> cb(err, element)\n     *\n     * @jsonWire POST /session/:sessionId/elements\n     * @docOrder 4\n     */\n\n\n    commands['element' + utils.elFuncSuffix(type) + 'OrNull'] = function () {\n      var fargs = utils.varargs(arguments);\n      var cb = fargs.callback;\n      var args = fargs.all;\n      args.unshift(utils.elFuncFullType(type));\n      args.push(function (err, elements) {\n        if (!err) {\n          if (elements.length > 0) {\n            cb(null, elements[0]);\n          } else {\n            cb(null, null);\n          }\n        } else {\n          cb(err);\n        }\n      });\n      commands.elements.apply(this, args);\n    };\n    /**\n     * elementByClassNameIfExists(value, cb) -> cb(err, element)\n     * elementByCssSelectorIfExists(value, cb) -> cb(err, element)\n     * elementByIdIfExists(value, cb) -> cb(err, element)\n     * elementByNameIfExists(value, cb) -> cb(err, element)\n     * elementByLinkTextIfExists(value, cb) -> cb(err, element)\n     * elementByPartialLinkTextIfExists(value, cb) -> cb(err, element)\n     * elementByTagNameIfExists(value, cb) -> cb(err, element)\n     * elementByXPathIfExists(value, cb) -> cb(err, element)\n     * elementByCssIfExists(value, cb) -> cb(err, element)\n     * elementByIosUIAutomationIfExists(value, cb) -> cb(err, element)\n     * elementByIosClassChainIfExists(value, cb) -> cb(err, element)\n     * elementByIosPredicateStringIfExists(value, cb) -> cb(err, element)\n     * elementByAndroidUIAutomatorIfExists(value, cb) -> cb(err, element)\n     * elementByAccessibilityIdIfExists(value, cb) -> cb(err, element)\n     *\n     * @jsonWire POST /session/:sessionId/elements\n     * @docOrder 6\n     */\n\n\n    commands['element' + utils.elFuncSuffix(type) + 'IfExists'] = function () {\n      var fargs = utils.varargs(arguments);\n      var cb = fargs.callback;\n      var args = fargs.all;\n      args.unshift(utils.elFuncFullType(type));\n      args.push(function (err, elements) {\n        if (!err) {\n          if (elements.length > 0) {\n            cb(null, elements[0]);\n          } else {\n            cb(null);\n          }\n        } else {\n          cb(err);\n        }\n      });\n      commands.elements.apply(this, args);\n    };\n    /**\n     * hasElementByClassName(value, cb) -> cb(err, boolean)\n     * hasElementByCssSelector(value, cb) -> cb(err, boolean)\n     * hasElementById(value, cb) -> cb(err, boolean)\n     * hasElementByName(value, cb) -> cb(err, boolean)\n     * hasElementByLinkText(value, cb) -> cb(err, boolean)\n     * hasElementByPartialLinkText(value, cb) -> cb(err, boolean)\n     * hasElementByTagName(value, cb) -> cb(err, boolean)\n     * hasElementByXPath(value, cb) -> cb(err, boolean)\n     * hasElementByCss(value, cb) -> cb(err, boolean)\n     * hasElementByIosUIAutomation(value, cb) -> cb(err, boolean)\n     * hasElementByIosClassChain(value, cb) -> cb(err, boolean)\n     * hasElementByIosPredicateString(value, cb) -> cb(err, boolean)\n     * hasElementByAndroidUIAutomator(value, cb) -> cb(err, boolean)\n     * hasElementByAccessibilityId(value, cb) -> cb(err, boolean)\n     *\n     * @jsonWire POST /session/:sessionId/elements\n     * @docOrder 8\n     */\n\n\n    commands['hasElement' + utils.elFuncSuffix(type)] = function () {\n      var args = __slice.call(arguments, 0);\n\n      args.unshift(utils.elFuncFullType(type));\n      commands.hasElement.apply(this, args);\n    };\n    /**\n     * waitForElementByClassName(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByCssSelector(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementById(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByName(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByLinkText(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByPartialLinkText(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByTagName(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByXPath(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByCss(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByIosUIAutomation(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByIosClassChain(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByIosPredicateString(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByAndroidUIAutomator(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByAccessibilityId(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * asserter, timeout, pollFreq are optional, opts may be passed instead,\n     * as in waitForElement.\n     */\n\n\n    commands['waitForElement' + utils.elFuncSuffix(type)] = function () {\n      var args = __slice.call(arguments, 0);\n\n      args.unshift(utils.elFuncFullType(type));\n      commands.waitForElement.apply(this, args);\n    };\n    /**\n     * waitForElementsByClassName(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByCssSelector(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsById(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByName(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByLinkText(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByPartialLinkText(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByTagName(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByXPath(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByCss(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByIosUIAutomation(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementsByIosClassChain(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementsByIosPredicateString(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementsByAndroidUIAutomator(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementsByAccessibilityId(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * asserter, timeout, pollFreq are optional, opts may be passed instead,\n     * as in waitForElements.\n     */\n\n\n    commands['waitForElements' + utils.elFuncSuffix(type)] = function () {\n      var args = __slice.call(arguments, 0);\n\n      args.unshift(utils.elFuncFullType(type));\n      commands.waitForElements.apply(this, args);\n    };\n\n    commands['waitForVisible' + utils.elFuncSuffix(type)] = function () {\n      var args = __slice.call(arguments, 0);\n\n      args.unshift(utils.elFuncFullType(type));\n      commands.waitForVisible.apply(this, args);\n    };\n    /**\n     * elementsByClassName(value, cb) -> cb(err, elements)\n     * elementsByCssSelector(value, cb) -> cb(err, elements)\n     * elementsById(value, cb) -> cb(err, elements)\n     * elementsByName(value, cb) -> cb(err, elements)\n     * elementsByLinkText(value, cb) -> cb(err, elements)\n     * elementsByPartialLinkText(value, cb) -> cb(err, elements)\n     * elementsByTagName(value, cb) -> cb(err, elements)\n     * elementsByXPath(value, cb) -> cb(err, elements)\n     * elementsByCss(value, cb) -> cb(err, elements)\n     * elementsByIosUIAutomation(value, cb) -> cb(err, elements)\n     * elementsByIosClassChain(value, cb) -> cb(err, elements)\n     * elementsByIosPredicateString(value, cb) -> cb(err, elements)\n     * elementsByAndroidUIAutomator(value, cb) -> cb(err, elements)\n     * elementsByAccessibilityId(value, cb) -> cb(err, elements)\n     *\n     * @jsonWire POST /session/:sessionId/elements\n     * @docOrder 2\n     */\n\n  }\n\n  if (plural) {\n    commands['elements' + utils.elFuncSuffix(type)] = function () {\n      var args = __slice.call(arguments, 0);\n\n      args.unshift(utils.elFuncFullType(type));\n      commands.elements.apply(this, args);\n    };\n  }\n};\n\n_.each(utils.elementFuncTypes, function (suffix) {\n  addMethodsForSuffix(suffix, true, true);\n});\n/**\n * getTagName(element, cb) -> cb(err, name)\n *\n * @jsonWire GET /session/:sessionId/element/:id/name\n */\n\n\ncommands.getTagName = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/name',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getAttribute(element, attrName, cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/attribute/:name\n * @docOrder 1\n */\n\n\ncommands.getAttribute = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      attrName = fargs.all[1];\n\n  if (!element) {\n    throw new Error('Missing element.');\n  }\n\n  if (!attrName) {\n    throw new Error('Missing attribute name.');\n  }\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/attribute/' + attrName,\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * isDisplayed(element, cb) -> cb(err, displayed)\n *\n * @jsonWire GET /session/:sessionId/element/:id/displayed\n */\n\n\ncommands.isDisplayed = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/displayed',\n    cb: callbackWithData(cb, this)\n  });\n};\n\ncommands.displayed = commands.isDisplayed;\n/**\n  * isEnabled(element, cb) -> cb(err, enabled)\n  *\n  * @jsonWire GET /session/:sessionId/element/:id/enabled\n  */\n\ncommands.isEnabled = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/enabled',\n    cb: callbackWithData(cb, this)\n  });\n};\n\ncommands.enabled = commands.isEnabled;\n/**\n * isSelected(element, cb) -> cb(err, selected)\n *\n * @jsonWire GET /session/:sessionId/element/:id/selected\n */\n\ncommands.isSelected = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/selected',\n    cb: callbackWithData(cb, this)\n  });\n}; // commands.selected = commands.isSelected;\n\n/**\n * Get element value (in value attribute):\n * getValue(element, cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/attribute/:name\n * @docOrder 3\n */\n\n\ncommands.getValue = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0];\n\n  if (!element) {\n    throw new Error('Missing element.');\n  }\n\n  commands.getAttribute.apply(this, [element, 'value', cb]);\n};\n/**\n * clickElement(element, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/element/:id/click\n */\n\n\ncommands.clickElement = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/element/' + element + '/click',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * getComputedCss(element, cssProperty , cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/css/:propertyName\n */\n\n\ncommands.getComputedCss = function (element, cssProperty) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/css/' + cssProperty,\n    cb: callbackWithData(cb, this)\n  });\n};\n\ncommands.getComputedCSS = commands.getComputedCss;\n/**\n * equalsElement(element, other , cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/equals/:other\n */\n\ncommands.equalsElement = function (element, other) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/equals/' + other,\n    cb: callbackWithData(cb, this)\n  });\n};\n\nvar _flick1 = function _flick1() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      xspeed = fargs.all[0],\n      yspeed = fargs.all[1],\n      swipe = fargs.all[2];\n  var data = {\n    xspeed: xspeed,\n    yspeed: yspeed\n  };\n\n  if (swipe) {\n    data.swipe = swipe;\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/touch/flick',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n\nvar _flick2 = function _flick2() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      xoffset = fargs.all[1],\n      yoffset = fargs.all[2],\n      speed = fargs.all[3];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/touch/flick',\n    data: {\n      element: element,\n      xoffset: xoffset,\n      yoffset: yoffset,\n      speed: speed\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * flick(xspeed, yspeed, swipe, cb) -> cb(err)\n * Flicks, starting anywhere on the screen.\n *\n * flick(element, xoffset, yoffset, speed, cb) -> cb(err)\n * Flicks, starting at element center.\n *\n * @jsonWire POST /session/:sessionId/touch/flick\n */\n\n\ncommands.flick = function () {\n  var args = __slice.call(arguments, 0);\n\n  if (args.length <= 4) {\n    _flick1.apply(this, args);\n  } else {\n    _flick2.apply(this, args);\n  }\n};\n/**\n * tapElement(element) -> cb(err)\n * Taps element\n *\n * @jsonWire POST /session/:sessionId/touch/click\n */\n\n\ncommands.tapElement = function (element, cb) {\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/touch/click',\n    data: {\n      element: element.value.toString()\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * performTouchAction(touchAction) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/touch/perform\n */\n\n\ncommands.performTouchAction = function () {\n  var _this = this;\n\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      touchAction = fargs.all[0];\n\n  try {\n    _this._jsonWireCall({\n      method: 'POST',\n      relPath: '/touch/perform',\n      data: {\n        actions: touchAction.toJSON()\n      },\n      cb: callbackWithData(cb, this)\n    });\n  } catch (err) {\n    return cb(err);\n  }\n};\n/**\n * performMultiAction(element, multiAction) -> cb(err, touchStateObjects)\n * performMultiAction(multiAction) -> cb(err, touchStateObjects)\n *\n * @jsonWire POST /session/:sessionId/touch/multi/perform\n */\n\n\ncommands.performMultiAction = function () {\n  var _this = this;\n\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      multiTouchAction = fargs.all[1];\n\n  if (!multiTouchAction) {\n    multiTouchAction = element;\n    element = null;\n  }\n\n  element = element || multiTouchAction.element;\n\n  try {\n    var data = multiTouchAction.toJSON(element);\n\n    if (element) {\n      data.elementId = element.value.toString();\n    }\n\n    _this._jsonWireCall({\n      method: 'POST',\n      relPath: '/touch/multi/perform',\n      data: data,\n      cb: callbackWithData(cb, this)\n    });\n  } catch (err) {\n    return cb(err);\n  }\n};\n/**\n * performW3CActions(actions) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/actions\n */\n\n\ncommands.performW3CActions = function () {\n  var _this = this;\n\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      actions = fargs.all[0];\n\n  try {\n    var data = actions.toJSON();\n\n    _this._jsonWireCall({\n      method: 'POST',\n      relPath: '/actions',\n      data: data,\n      cb: callbackWithData(cb, this)\n    });\n  } catch (err) {\n    return cb(err);\n  }\n};\n\ncommands.releaseW3CActions = function () {\n  var _this = this;\n\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n\n  try {\n    _this._jsonWireCall({\n      method: 'DELETE',\n      relPath: '/actions',\n      cb: callbackWithData(cb, this)\n    });\n  } catch (err) {\n    return cb(err);\n  }\n};\n/**\n * moveTo(element, xoffset, yoffset, cb) -> cb(err)\n * Move to element, element may be null, xoffset and y offset\n * are optional.\n *\n * @jsonWire POST /session/:sessionId/moveto\n */\n\n\ncommands.moveTo = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      xoffset = fargs.all[1],\n      yoffset = fargs.all[2];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/moveto',\n    data: {\n      element: element ? element.toString() : null,\n      xoffset: xoffset,\n      yoffset: yoffset\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * buttonDown(button ,cb) -> cb(err)\n * button is optional.\n * {LEFT = 0, MIDDLE = 1 , RIGHT = 2}.\n * LEFT if not specified.\n *\n * @jsonWire POST /session/:sessionId/buttondown\n */\n\n\ncommands.buttonDown = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      button = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/buttondown',\n    data: {\n      button: button\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * buttonUp(button, cb) -> cb(err)\n * button is optional.\n * {LEFT = 0, MIDDLE = 1 , RIGHT = 2}.\n * LEFT if not specified.\n *\n * @jsonWire POST /session/:sessionId/buttonup\n */\n\n\ncommands.buttonUp = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      button = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/buttonup',\n    data: {\n      button: button\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * click(button, cb) -> cb(err)\n * Click on current element.\n * Buttons: {left: 0, middle: 1 , right: 2}\n *\n * @jsonWire POST /session/:sessionId/click\n */\n\n\ncommands.click = function () {\n  // parsing args, button optional\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      button = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/click',\n    data: {\n      button: button\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * doubleclick(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/doubleclick\n */\n\n\ncommands.doubleclick = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/doubleclick',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * type(element, keys, cb) -> cb(err)\n * Type keys (all keys are up at the end of command).\n * special key map: wd.SPECIAL_KEYS (see lib/special-keys.js)\n *\n * @jsonWire POST /session/:sessionId/element/:id/value\n */\n\n\ncommands.type = function (element, keys) {\n  var cb = findCallback(arguments);\n\n  if (!Array.isArray(keys)) {\n    keys = [keys];\n  } // ensure all keystrokes are strings to conform to JSONWP\n\n\n  _.each(keys, function (key, idx) {\n    if (typeof key !== \"string\") {\n      keys[idx] = key.toString();\n    }\n  });\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/element/' + element + '/value',\n    data: {\n      value: keys,\n      text: keys.join('')\n    },\n    cb: simpleCallback(cb)\n  });\n};\n\ncommands.replace = function (element, keys) {\n  var cb = findCallback(arguments);\n\n  if (!Array.isArray(keys)) {\n    keys = [keys];\n  } // ensure all keystrokes are strings to conform to JSONWP\n\n\n  _.each(keys, function (key, idx) {\n    if (typeof key !== \"string\") {\n      keys[idx] = key.toString();\n    }\n  });\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/element/' + element + '/replace_value',\n    data: {\n      value: keys\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * submit(element, cb) -> cb(err)\n * Submit a `FORM` element.\n *\n * @jsonWire POST /session/:sessionId/element/:id/submit\n */\n\n\ncommands.submit = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/element/' + element + '/submit',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * keys(keys, cb) -> cb(err)\n * Press keys (keys may still be down at the end of command).\n * special key map: wd.SPECIAL_KEYS (see lib/special-keys.js)\n *\n * @jsonWire POST /session/:sessionId/keys\n */\n\n\ncommands.keys = function (keys) {\n  var cb = findCallback(arguments);\n\n  if (!Array.isArray(keys)) {\n    keys = [keys];\n  } // ensure all keystrokes are strings to conform to JSONWP\n\n\n  _.each(keys, function (key, idx) {\n    if (typeof key !== \"string\") {\n      keys[idx] = key.toString();\n    }\n  });\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/keys',\n    data: {\n      value: keys\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * clear(element, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/element/:id/clear\n */\n\n\ncommands.clear = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/element/' + element + '/clear',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * title(cb) -> cb(err, title)\n *\n * @jsonWire GET /session/:sessionId/title\n */\n\n\ncommands.title = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/title',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * source(cb) -> cb(err, source)\n *\n * @jsonWire GET /session/:sessionId/source\n */\n\n\ncommands.source = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/source',\n    cb: callbackWithData(cb, this)\n  });\n}; // element must be specified\n\n\nvar _rawText = function _rawText(element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/text',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * text(element, cb) -> cb(err, text)\n * element: specific element, 'body', or undefined\n *\n * @jsonWire GET /session/:sessionId/element/:id/text\n * @docOrder 1\n */\n\n\ncommands.text = function () {\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var element = fargs.all[0];\n\n  var _this = this;\n\n  if (!element || element === 'body') {\n    commands.element.apply(this, ['tag name', 'body', function (err, bodyEl) {\n      if (!err) {\n        _rawText.apply(_this, [bodyEl, cb]);\n      } else {\n        cb(err);\n      }\n    }]);\n  } else {\n    _rawText.apply(_this, [element, cb]);\n  }\n};\n/**\n * Check if text is present:\n * textPresent(searchText, element, cb) -> cb(err, boolean)\n * element: specific element, 'body', or undefined\n *\n * @jsonWire GET /session/:sessionId/element/:id/text\n * @docOrder 3\n */\n\n\ncommands.textPresent = function (searchText, element) {\n  var cb = findCallback(arguments);\n  commands.text.apply(this, [element, function (err, text) {\n    if (err) {\n      cb(err, null);\n    } else {\n      cb(err, text.indexOf(searchText) >= 0);\n    }\n  }]);\n};\n/**\n * alertText(cb) -> cb(err, text)\n *\n * @jsonWire GET /session/:sessionId/alert_text\n */\n\n\ncommands.alertText = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/alert_text',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * alertKeys(keys, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/alert_text\n */\n\n\ncommands.alertKeys = function (keys) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/alert_text',\n    data: {\n      text: keys\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * acceptAlert(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/accept_alert\n */\n\n\ncommands.acceptAlert = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/accept_alert',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * dismissAlert(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/dismiss_alert\n */\n\n\ncommands.dismissAlert = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/dismiss_alert',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * active(cb) -> cb(err, element)\n *\n * @jsonWire POST /session/:sessionId/element/active\n */\n\n\ncommands.active = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/element/active',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * url(cb) -> cb(err, url)\n *\n * @jsonWire GET /session/:sessionId/url\n */\n\n\ncommands.url = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/url',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * allCookies() -> cb(err, cookies)\n *\n * @jsonWire GET /session/:sessionId/cookie\n */\n\n\ncommands.allCookies = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/cookie',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * setCookie(cookie, cb) -> cb(err)\n * cookie example:\n *  {name:'fruit', value:'apple'}\n * Optional cookie fields:\n *  path, domain, secure, expiry\n *\n * @jsonWire POST /session/:sessionId/cookie\n */\n\n\ncommands.setCookie = function (cookie) {\n  var cb = findCallback(arguments); // setting secure otherwise selenium server throws\n\n  if (cookie) {\n    cookie.secure = cookie.secure || false;\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/cookie',\n    data: {\n      cookie: cookie\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * deleteAllCookies(cb) -> cb(err)\n *\n * @jsonWire DELETE /session/:sessionId/cookie\n */\n\n\ncommands.deleteAllCookies = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'DELETE',\n    relPath: '/cookie',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * deleteCookie(name, cb) -> cb(err)\n *\n * @jsonWire DELETE /session/:sessionId/cookie/:name\n */\n\n\ncommands.deleteCookie = function (name) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'DELETE',\n    relPath: '/cookie/' + encodeURIComponent(name),\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * getOrientation(cb) -> cb(err, orientation)\n *\n * @jsonWire GET /session/:sessionId/orientation\n */\n\n\ncommands.getOrientation = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/orientation',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * setOrientation(cb) -> cb(err, orientation)\n *\n * @jsonWire POST /session/:sessionId/orientation\n */\n\n\ncommands.setOrientation = function (orientation) {\n  orientation = orientation.toUpperCase();\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/orientation',\n    data: {\n      orientation: orientation\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * setLocalStorageKey(key, value, cb) -> cb(err)\n *\n * # uses safeExecute() due to localStorage bug in Selenium\n *\n * @jsonWire POST /session/:sessionId/local_storage\n */\n\n\ncommands.setLocalStorageKey = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      key = fargs.all[0],\n      value = fargs.all[1];\n  commands.safeExecute.apply(this, [\"localStorage.setItem(arguments[0], arguments[1])\", [key, value], cb]);\n};\n/**\n * getLocalStorageKey(key, cb) -> cb(err)\n *\n * # uses safeEval() due to localStorage bug in Selenium\n *\n * @jsonWire GET /session/:sessionId/local_storage/key/:key\n */\n\n\ncommands.getLocalStorageKey = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      key = fargs.all[0];\n  commands.safeEval.apply(this, [\"localStorage.getItem('\" + key + \"')\", cb]);\n};\n/**\n * removeLocalStorageKey(key, cb) -> cb(err)\n *\n * # uses safeExecute() due to localStorage bug in Selenium\n *\n * @jsonWire DELETE /session/:sessionId/local_storage/key/:key\n */\n\n\ncommands.removeLocalStorageKey = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      key = fargs.all[0];\n  commands.safeExecute.apply(this, [\"localStorage.removeItem(arguments[0])\", [key], cb]);\n};\n/**\n * clearLocalStorage(cb) -> cb(err)\n *\n * # uses safeExecute() due to localStorage bug in Selenium\n *\n * @jsonWire DELETE /session/:sessionId/local_storage\n */\n\n\ncommands.clearLocalStorage = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n  commands.safeExecute.apply(this, [\"localStorage.clear()\", cb]);\n}; // deprecated\n\n\nvar _isVisible1 = function _isVisible1(element) {\n  var cb = findCallback(arguments);\n  commands.getComputedCSS.apply(this, [element, \"display\", function (err, display) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, display !== \"none\");\n  }]);\n}; // deprecated\n\n\nvar _isVisible2 = function _isVisible2(queryType, querySelector) {\n  var cb = findCallback(arguments);\n  commands.elementIfExists.apply(this, [queryType, querySelector, function (err, element) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (element) {\n      element.isVisible(cb);\n    } else {\n      cb(null, false);\n    }\n  }]);\n}; // deprecated\n\n\ncommands.isVisible = function () {\n  deprecator.warn('isVisible', 'isVisible has been deprecated, use isDisplayed instead.');\n\n  var args = __slice.call(arguments, 0);\n\n  if (args.length <= 2) {\n    _isVisible1.apply(this, args);\n  } else {\n    _isVisible2.apply(this, args);\n  }\n};\n/**\n * Retrieves the pageIndex element (added for Appium):\n * getPageIndex(element, cb) -> cb(err, pageIndex)\n */\n\n\ncommands.getPageIndex = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/pageIndex',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getLocation(element, cb) -> cb(err, location)\n *\n * @jsonWire GET /session/:sessionId/element/:id/location\n */\n\n\ncommands.getLocation = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/location',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getLocationInView(element, cb) -> cb(err, location)\n *\n * @jsonWire GET /session/:sessionId/element/:id/location_in_view\n */\n\n\ncommands.getLocationInView = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/location_in_view',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getSize(element, cb) -> cb(err, size)\n *\n * @jsonWire GET /session/:sessionId/element/:id/size\n */\n\n\ncommands.getSize = function (element) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/element/' + element + '/size',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * Uploads a local file using undocumented\n * POST /session/:sessionId/file\n * uploadFile(filepath, cb) -> cb(err, filepath)\n */\n\n\ncommands.uploadFile = function (filepath) {\n  var cb = findCallback(arguments);\n\n  var _this = this;\n\n  var archiver = require('archiver');\n\n  var archive = archiver('zip');\n  var dataList = [];\n  archive.on('error', function (err) {\n    cb(err);\n  }).on('data', function (data) {\n    dataList.push(data);\n  }).on('end', function () {\n    _this._jsonWireCall({\n      method: 'POST',\n      relPath: '/file',\n      data: {\n        file: Buffer.concat(dataList).toString('base64')\n      },\n      cb: callbackWithData(cb, _this)\n    });\n  });\n  archive.append(fs.createReadStream(filepath), {\n    name: path.basename(filepath)\n  });\n  archive.finalize(function (err) {\n    if (err) {\n      cb(err);\n    }\n  });\n};\n\ncommands.waitForJsCondition = function () {\n  deprecator.warn('waitForJsCondition', 'waitForJsCondition has been deprecated, use waitFor + jsCondition asserter instead.');\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var jsConditionExpr = fargs.all[0],\n      timeout = fargs.all[1],\n      pollFreq = fargs.all[2];\n  commands.waitFor.apply(this, [{\n    asserter: asserters.jsCondition(jsConditionExpr, true),\n    timeout: timeout,\n    pollFreq: pollFreq\n  }, function (err, value) {\n    if (err && err.message && err.message.match(/Condition/)) {\n      cb(new Error(\"Element condition wasn't satisfied!\"));\n    } else {\n      cb(err, value);\n    }\n  }]);\n};\n\ncommands.waitForCondition = commands.waitForJsCondition;\n/**\n * Waits for JavaScript condition to be true (async script polling within browser):\n * waitForConditionInBrowser(conditionExpr, timeout, pollFreq, cb) -> cb(err, boolean)\n * conditionExpr: condition expression, should return a boolean\n * timeout and  pollFreq are optional, default: 1000/100.\n * return true if condition satisfied, error otherwise.\n */\n\ncommands.waitForConditionInBrowser = function () {\n  var _this = this; // parsing args\n\n\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      conditionExpr = fargs.all[0],\n      timeout = fargs.all[1] || 1000,\n      poll = fargs.all[2] || 100; // calling script\n\n  commands.safeExecuteAsync.apply(_this, [_waitForConditionInBrowserJsScript, [conditionExpr, timeout, poll], function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (res !== true) {\n      return cb(\"waitForConditionInBrowser failure for: \" + conditionExpr);\n    }\n\n    cb(null, res);\n  }]);\n};\n/**\n * sauceJobUpdate(jsonData, cb) -> cb(err)\n */\n\n\ncommands.sauceJobUpdate = function () {\n  var fargs = utils.varargs(arguments);\n\n  this._sauceJobUpdate.apply(this, fargs.array);\n};\n/**\n * sauceJobStatus(hasPassed, cb) -> cb(err)\n */\n\n\ncommands.sauceJobStatus = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      hasPassed = fargs.all[0];\n\n  this._sauceJobUpdate.apply(this, [{\n    passed: hasPassed\n  }, cb]);\n};\n/**\n * sleep(ms, cb) -> cb(err)\n */\n\n\ncommands.sleep = function (ms, cb) {\n  cb = cb || function () {};\n\n  setTimeout(cb, ms);\n};\n/**\n * noop(cb) -> cb(err)\n */\n\n\ncommands.noop = function (cb) {\n  if (cb) {\n    cb();\n  }\n};\n/**\n * shakeDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/shake\n */\n\n\ncommands.shakeDevice = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/shake',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * shake(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/shake\n */\n\n\ncommands.shake = commands.shakeDevice;\n/**\n * lockDevice(seconds, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/lock\n */\n\ncommands.lockDevice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      seconds = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/lock',\n    data: {\n      seconds: seconds\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * lock(seconds, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/lock\n */\n\n\ncommands.lock = commands.lockDevice;\n/**\n * unlockDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/lock\n */\n\ncommands.unlockDevice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/unlock',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * unlock(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/lock\n */\n\n\ncommands.unlock = commands.unlockDevice;\n/**\n * isLocked(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/is_locked\n */\n\ncommands.isLocked = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/is_locked',\n    cb: callbackWithData(cb)\n  });\n};\n/**\n * deviceKeyEvent(keycode, metastate, cb) -> cb(err)\n * metastate is optional. DEPRECATED: use pressKeycode instead\n *\n * @jsonWire POST /session/:sessionId/appium/device/keyevent\n */\n\n\ncommands.deviceKeyEvent = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      keycode = fargs.all[0],\n      metastate = fargs.all[1];\n  var data = {\n    keycode: keycode\n  };\n\n  if (metastate) {\n    data.metastate = metastate;\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/keyevent',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * pressDeviceKey(keycode, metastate, cb) -> cb(err)\n * metastate is optional. DEPRECATED: use pressKeycode instead\n *\n * @jsonWire POST /session/:sessionId/appium/device/keyevent\n */\n\n\ncommands.pressDeviceKey = commands.deviceKeyEvent;\n/**\n * pressKeycode(keycode, metastate, cb) -> cb(err)\n * metastate is optional.\n * flags is optional for native android flag. Can set multiple falsg as Array. Flags have `FLAG_` prefix in http://developer.android.com/reference/android/view/KeyEvent.html\n * e.g.: FLAG_CANCELED is `32` or `0x00000020`\n *\n * @jsonWire POST /session/:sessionId/appium/device/press_keycode\n */\n\ncommands.pressKeycode = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      keycode = fargs.all[0],\n      metastate = fargs.all[1],\n      flags = fargs.all[2];\n  var data = {\n    keycode: keycode\n  };\n\n  if (metastate) {\n    data.metastate = metastate;\n  }\n\n  if (flags) {\n    var f = 0;\n    flags.forEach(function (value) {\n      f = f | value;\n    });\n    data.flags = f;\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/press_keycode',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * longPressKeycode(keycode, metastate, cb) -> cb(err)\n * metastate is optional.\n * flags is optional for native android flag. Can set multiple falsg as Array. Flags have `FLAG_` prefix in http://developer.android.com/reference/android/view/KeyEvent.html\n * e.g.: FLAG_CANCELED is `32` or `0x00000020`\n *\n * @jsonWire POST /session/:sessionId/appium/device/long_press_keycode\n */\n\n\ncommands.longPressKeycode = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      keycode = fargs.all[0],\n      metastate = fargs.all[1],\n      flags = fargs.all[2];\n  var data = {\n    keycode: keycode\n  };\n\n  if (metastate) {\n    data.metastate = metastate;\n  }\n\n  if (flags) {\n    var f = 0;\n    flags.forEach(function (value) {\n      f = f | value;\n    });\n    data.flags = f;\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/long_press_keycode',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * rotateDevice(element, opts, cb) -> cb(err)\n * rotateDevice(opts, cb) -> cb(err)\n * opts is like the following:\n * {x: 114, y: 198, duration: 5, radius: 3, rotation: 220, touchCount: 2}\n *\n * @jsonWire POST /session/:sessionId/appium/device/rotate\n */\n\n\ncommands.rotateDevice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      opts = fargs.all[1];\n\n  if (!(element && element.value)) {\n    opts = element;\n    element = null;\n  }\n\n  var data = _.clone(opts);\n\n  if (element) {\n    data.element = element.value.toString();\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/rotate',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * rotate(element, opts, cb) -> cb(err)\n * rotate(opts, cb) -> cb(err)\n * opts is like the following:\n * {x: 114, y: 198, duration: 5, radius: 3, rotation: 220, touchCount: 2}\n *\n * @jsonWire POST /session/:sessionId/appium/device/rotate\n */\n\n\ncommands.rotate = commands.rotateDevice;\n/**\n * getCurrentDeviceActivity(cb) -> cb(err)\n *\n * @jsonWire GET /session/:sessionId/appium/device/current_activity\n */\n\ncommands.getCurrentDeviceActivity = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/appium/device/current_activity',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getCurrentActivity(cb) -> cb(err)\n *\n * @jsonWire GET /session/:sessionId/appium/device/current_activity\n */\n\n\ncommands.getCurrentActivity = commands.getCurrentDeviceActivity;\n/**\n * getCurrentPackage(cb) -> cb(err)\n *\n * @jsonWire GET /session/:sessionId/appium/device/current_package\n */\n\ncommands.getCurrentPackage = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/appium/device/current_package',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * installAppOnDevice(appPath, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/install_app\n */\n\n\ncommands.installAppOnDevice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      appPath = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/install_app',\n    data: {\n      appPath: appPath\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * installApp(appPath, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/install_app\n */\n\n\ncommands.installApp = commands.installAppOnDevice;\n/**\n * removeAppFromDevice(appId, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/remove_app\n */\n\ncommands.removeAppFromDevice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      appId = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/remove_app',\n    data: {\n      appId: appId\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * removeApp(appId, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/remove_app\n */\n\n\ncommands.removeApp = commands.removeAppFromDevice;\n/**\n * isAppInstalledOnDevice(bundleId, cb) -> cb(isInstalled, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/app_installed\n */\n\ncommands.isAppInstalledOnDevice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      bundleId = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/app_installed',\n    data: {\n      bundleId: bundleId\n    },\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * isAppInstalled(bundleId, cb) -> cb(isInstalled, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/app_installed\n */\n\n\ncommands.isAppInstalled = commands.isAppInstalledOnDevice;\n/**\n * isKeyboardShown() -> cb(err)\n *\n * @jsonWire GET /session/:sessionId/appium/device/is_keyboard_shown\n */\n\ncommands.isKeyboardShown = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/appium/device/is_keyboard_shown',\n    cb: callbackWithData(cb)\n  });\n};\n/**\n * hideKeyboard() -> cb(err)\n * hideKeyboard(keyName, cb) -> cb(err)\n * hideKeyboard({strategy: 'pressKey', key:'<key>'}) -> cb(err)\n * hideKeyboard({strategy: 'tapOutside'}) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/hide_keyboard\n */\n\n\ncommands.hideDeviceKeyboard = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n  var data = {};\n\n  switch (typeof fargs.all[0]) {\n    case 'string':\n      data = {\n        keyName: fargs.all[0]\n      };\n      break;\n\n    case 'object':\n      data = fargs.all[0];\n      break;\n\n    default:\n      data = null;\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/hide_keyboard',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n\ncommands.hideKeyboard = commands.hideDeviceKeyboard;\n/**\n * pushFileToDevice(pathOnDevice, base64Data, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/push_file\n */\n\ncommands.pushFileToDevice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      pathOnDevice = fargs.all[0],\n      base64Data = fargs.all[1];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/push_file',\n    data: {\n      path: pathOnDevice,\n      data: base64Data\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * pushFile(pathOnDevice, base64Data, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/push_file\n */\n\n\ncommands.pushFile = commands.pushFileToDevice;\n/**\n * pullFileFromDevice(pathOnDevice, cb) -> cb(base64EncodedData, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/pull_file\n */\n\ncommands.pullFileFromDevice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      pathOnDevice = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/pull_file',\n    data: {\n      path: pathOnDevice\n    },\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * pullFile(pathOnDevice, cb) -> cb(base64EncodedData, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/pull_file\n */\n\n\ncommands.pullFile = commands.pullFileFromDevice;\n/**\n * pullFolderFromDevice(pathOnDevice, cb) -> cb(base64EncodedData, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/pull_folder\n */\n\ncommands.pullFolderFromDevice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      pathOnDevice = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/pull_folder',\n    data: {\n      path: pathOnDevice\n    },\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * pullFolder(pathOnDevice, cb) -> cb(base64EncodedData, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/pull_folder\n */\n\n\ncommands.pullFolder = commands.pullFolderFromDevice;\n/**\n * toggleAirplaneModeOnDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_airplane_mode\n */\n\ncommands.toggleAirplaneModeOnDevice = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/toggle_airplane_mode',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * toggleAirplaneMode(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_airplane_mode\n */\n\n\ncommands.toggleAirplaneMode = commands.toggleAirplaneModeOnDevice;\n/**\n * toggleFlightMode(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_airplane_mode\n */\n\ncommands.toggleFlightMode = commands.toggleAirplaneModeOnDevice;\n/**\n * toggleWiFiOnDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_wifi\n */\n\ncommands.toggleWiFiOnDevice = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/toggle_wifi',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * toggleWiFi(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_wifi\n */\n\n\ncommands.toggleWiFi = commands.toggleWiFiOnDevice;\n/**\n * toggleLocationServicesOnDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_location_services\n */\n\ncommands.toggleLocationServicesOnDevice = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/toggle_location_services',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * toggleLocationServices(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_location_services\n */\n\n\ncommands.toggleLocationServices = commands.toggleLocationServicesOnDevice;\n/**\n * toggleDataOnDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_data\n */\n\ncommands.toggleDataOnDevice = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/toggle_data',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * toggleData(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_data\n */\n\n\ncommands.toggleData = commands.toggleDataOnDevice;\n/**\n * launchApp(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/launch\n */\n\ncommands.launchApp = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/app/launch',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * closeApp(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/close\n */\n\n\ncommands.closeApp = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/app/close',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * resetApp(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/reset\n */\n\n\ncommands.resetApp = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/app/reset',\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * backgroundApp(seconds, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/background\n */\n\n\ncommands.backgroundApp = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      seconds = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/app/background',\n    data: {\n      seconds: seconds\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * endTestCoverageForApp(intentToBroadcast, pathOnDevice) -> cb(base64Data,err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/end_test_coverage\n */\n\n\ncommands.endTestCoverageForApp = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      intent = fargs.all[0],\n      path = fargs.all[1];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/app/end_test_coverage',\n    data: {\n      intent: intent,\n      path: path\n    },\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * endTestCoverage(intentToBroadcast, pathOnDevice) -> cb(base64Data,err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/end_test_coverage\n */\n\n\ncommands.endTestCoverage = commands.endTestCoverageForApp;\n/**\n * endCoverage(intentToBroadcast, pathOnDevice) -> cb(base64Data,err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/end_test_coverage\n */\n\ncommands.endCoverage = commands.endTestCoverageForApp;\n/**\n * complexFindInApp(selector) -> cb(element(s))\n * Return a single element or an elements array depending on\n * selector\n *\n * @jsonWire POST /session/:sessionId/appium/app/complex_find\n */\n\ncommands.complexFindInApp = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      selector = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/app/complex_find',\n    data: {\n      selector: selector\n    },\n    cb: elementOrElementsCallback(cb, this)\n  });\n};\n/**\n * complexFind(selector) -> cb(element(s))\n * Return a single element or an elements array depending on\n * selector\n *\n * @jsonWire POST /session/:sessionId/appium/app/complex_find\n */\n\n\ncommands.complexFind = commands.complexFindInApp;\n/**\n * getAppStrings(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/strings\n */\n\ncommands.getAppStrings = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      language = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/app/strings',\n    data: {\n      language: language\n    },\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * setImmediateValueInApp(element, value, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/element/:elementId?/value\n */\n\n\ncommands.setImmediateValueInApp = function (element, value) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/element/' + element.value.toString() + '/value',\n    data: {\n      value: value\n    },\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * startActivity(options, cb) -> cb(err)\n * Start an arbitrary Android activity during a session. The 'options' parameter should\n * implement the interface {appPackage, appActivity, [appWaitPackage], [appWaitActivity]}.\n *\n * @jsonWire POST /session/:sessionId/appium/device/start_activity\n */\n\n\ncommands.startActivity = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      options = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/start_activity',\n    data: options,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * setImmediateValue(element, value, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/element/:elementId?/value\n */\n\n\ncommands.setImmediateValue = commands.setImmediateValueInApp;\n/**\n * setNetworkConnection(type, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/network_connection\n */\n\ncommands.setNetworkConnection = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/network_connection',\n    data: {\n      parameters: {\n        type: fargs.all[0]\n      }\n    },\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getNetworkConnection(cb) -> cb(err, networkConnectionInfo)\n *\n * @jsonWire GET /session/:sessionId/network_connection\n */\n\n\ncommands.getNetworkConnection = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/network_connection',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * openNotifications(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/open_notifications\n */\n\n\ncommands.openNotifications = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/open_notifications',\n    cb: simpleCallback(cb, this)\n  });\n};\n/**\n * settings(cb) -> cb(err, settingsObject)\n *\n * @jsonWire GET /session/:sessionId/appium/settings\n */\n\n\ncommands.settings = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/appium/settings',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * updateSettings(settingsObject, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/settings\n */\n\n\ncommands.updateSettings = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/settings',\n    data: {\n      settings: fargs.all[0]\n    },\n    cb: simpleCallback(cb, this)\n  });\n};\n/**\n * availableIMEEngines(cb) -> cb(err, engines)\n *\n * @jsonWire GET /session/:sessionId/ime/available_engines\n */\n\n\ncommands.availableIMEEngines = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/ime/available_engines',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * activateIMEEngine(cb, engine) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/ime/activate\n */\n\n\ncommands.activateIMEEngine = function (engine) {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/ime/activate',\n    data: {\n      engine: engine\n    },\n    cb: simpleCallback(cb, this)\n  });\n};\n/**\n * deactivateIMEEngine(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/ime/deactivate\n */\n\n\ncommands.deactivateIMEEngine = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/ime/deactivate',\n    cb: simpleCallback(cb, this)\n  });\n};\n/**\n * activatedIMEEngine(cb) -> cb(err, active)\n *\n * @jsonWire GET /session/:sessionId/ime/activated\n */\n\n\ncommands.isIMEActive = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/ime/activated',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * activeIMEEngine(cb) -> cb(err, activeEngine)\n *\n * @jsonWire GET /session/:sessionId/ime/active_engine\n */\n\n\ncommands.activeIMEEngine = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/ime/active_engine',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getDeviceTime(cb) -> cb(err, deviceTime)\n *\n * @jsonWire GET /session/:sessionId/appium/device/system_time\n */\n\n\ncommands.getDeviceTime = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'GET',\n    relPath: '/appium/device/system_time',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * touchId(cb) -> cb(err, touchId)\n *\n * @jsonWire POST /session/:sessionId/appium/simulator/touch_id\n */\n\n\ncommands.touchId = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      match = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/simulator/touch_id',\n    cb: callbackWithData(cb, this),\n    data: {\n      match: match\n    }\n  });\n};\n/**\n * touchId(cb) -> cb(err, touchId)\n *\n * @jsonWire POST /session/:sessionId/appium/simulator/touch_id\n */\n\n\ncommands.toggleTouchIdEnrollment = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/simulator/toggle_touch_id_enrollment',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * fingerprint(fingerprintId, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/finger_print\n */\n\n\ncommands.fingerprint = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      fingerprintId = fargs.all[0];\n  var data = {\n    fingerprintId: fingerprintId\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/finger_print',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * sendSms(phoneNumber, message, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/send_sms\n */\n\n\ncommands.sendSms = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      phoneNumber = fargs.all[0],\n      message = fargs.all[1];\n  var data = {\n    phoneNumber: phoneNumber,\n    message: message\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/send_sms',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * gsmCall(phoneNumber, action, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/gsm_call\n */\n\n\ncommands.gsmCall = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      phoneNumber = fargs.all[0],\n      action = fargs.all[1];\n  var data = {\n    phoneNumber: phoneNumber,\n    action: action\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/gsm_call',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * gsmSignal(signalStrength, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/gsm_signal\n */\n\n\ncommands.gsmSignal = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      signalStrength = fargs.all[0];\n  var data = {\n    signalStrength: signalStrength\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/gsm_signal',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n\ncommands.gsmSignalStrength = commands.gsmSignal;\n/**\n * gsmVoice(state, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/gsm_voice\n */\n\ncommands.gsmVoice = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      state = fargs.all[0];\n  var data = {\n    state: state\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/gsm_voice',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n\ncommands.gsmVoiceState = commands.gsmVoice;\n/**\n * powerCapacity(percent, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/power_capacity\n */\n\ncommands.powerCapacity = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      percent = fargs.all[0];\n  var data = {\n    percent: percent\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/power_capacity',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * powerAC(state, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/power_ac\n */\n\n\ncommands.powerAC = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      state = fargs.all[0];\n  var data = {\n    state: state\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/power_ac',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n\ncommands.powerChargerState = commands.powerAC;\n/**\n * networkSpeed(netspeed, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/network_speed\n */\n\ncommands.networkSpeed = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      netspeed = fargs.all[0];\n  var data = {\n    netspeed: netspeed\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/network_speed',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * getClipboard(contentType, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/get_clipboard\n */\n\n\ncommands.getClipboard = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      contentType = fargs.all[0];\n  var data = {\n    contentType: contentType\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/get_clipboard',\n    data: data,\n    cb: callbackWithData(cb)\n  });\n};\n/**\n * setClipboard(content, contentType, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/set_clipboard\n */\n\n\ncommands.setClipboard = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      content = fargs.all[0],\n      contentType = fargs.all[1];\n  var data = {\n    content: content,\n    contentType: contentType\n  };\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/device/set_clipboard',\n    data: data,\n    cb: simpleCallback(cb)\n  });\n};\n/**\n * getSupportedPerformanceDataTypes(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/performanceData/types\n */\n\n\ncommands.getSupportedPerformanceDataTypes = function () {\n  var cb = findCallback(arguments);\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/performanceData/types',\n    cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getPerformanceData(packageName, dataType, dataReadTimeout, cb) -> cb(err)\n * dataReadTimeout is optional.\n *\n * @jsonWire POST /session/:sessionId/appium/getPerformanceData\n */\n\n\ncommands.getPerformanceData = function () {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      packageName = fargs.all[0],\n      dataType = fargs.all[1],\n      dataReadTimeout = fargs.all[2];\n  var data = {\n    packageName: packageName,\n    dataType: dataType\n  };\n\n  if (dataReadTimeout) {\n    data.dataReadTimeout = dataReadTimeout;\n  }\n\n  this._jsonWireCall({\n    method: 'POST',\n    relPath: '/appium/getPerformanceData',\n    data: data,\n    cb: callbackWithData(cb, this)\n  });\n};\n\ncommands.elementsByImageFile = function () {\n  var fargs = utils.varargs(arguments);\n\n  var _this = this;\n\n  var cb = fargs.callback,\n      imgPath = fargs.all[0];\n\n  _this.elementByImageFile(imgPath, true, cb);\n};\n\ncommands.elementByImageFile = function () {\n  var fargs = utils.varargs(arguments);\n\n  var _this = this;\n\n  var cb = fargs.callback,\n      imgPath = fargs.all[0],\n      multiple = fargs.all[1] || false;\n  fs.readFile(imgPath, function (err, fileData) {\n    if (err) {\n      return cb(err);\n    }\n\n    var elFn = multiple ? 'elementsByImage' : 'elementByImage';\n\n    _this[elFn](fileData.toString('base64'), cb);\n  });\n};\n\nmodule.exports = commands;","map":null,"metadata":{},"sourceType":"script"}