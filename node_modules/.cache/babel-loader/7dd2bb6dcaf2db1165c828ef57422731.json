{"ast":null,"code":"'use strict';\n\nvar win32 = process && process.platform === 'win32';\n\nvar path = require('path');\n\nvar fileRe = require('filename-regex');\n\nvar utils = module.exports;\n/**\n * Module dependencies\n */\n\nutils.diff = require('arr-diff');\nutils.unique = require('array-unique');\nutils.braces = require('braces');\nutils.brackets = require('expand-brackets');\nutils.extglob = require('extglob');\nutils.isExtglob = require('is-extglob');\nutils.isGlob = require('is-glob');\nutils.typeOf = require('kind-of');\nutils.normalize = require('normalize-path');\nutils.omit = require('object.omit');\nutils.parseGlob = require('parse-glob');\nutils.cache = require('regex-cache');\n/**\n * Get the filename of a filepath\n *\n * @param {String} `string`\n * @return {String}\n */\n\nutils.filename = function filename(fp) {\n  var seg = fp.match(fileRe());\n  return seg && seg[0];\n};\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\n\nutils.isPath = function isPath(pattern, opts) {\n  opts = opts || {};\n  return function (fp) {\n    var unixified = utils.unixify(fp, opts);\n\n    if (opts.nocase) {\n      return pattern.toLowerCase() === unixified.toLowerCase();\n    }\n\n    return pattern === unixified;\n  };\n};\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\n\nutils.hasPath = function hasPath(pattern, opts) {\n  return function (fp) {\n    return utils.unixify(pattern, opts).indexOf(fp) !== -1;\n  };\n};\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\n\nutils.matchPath = function matchPath(pattern, opts) {\n  var fn = opts && opts.contains ? utils.hasPath(pattern, opts) : utils.isPath(pattern, opts);\n  return fn;\n};\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re`\n * @return {Boolean}\n */\n\n\nutils.hasFilename = function hasFilename(re) {\n  return function (fp) {\n    var name = utils.filename(fp);\n    return name && re.test(name);\n  };\n};\n/**\n * Coerce `val` to an array\n *\n * @param  {*} val\n * @return {Array}\n */\n\n\nutils.arrayify = function arrayify(val) {\n  return !Array.isArray(val) ? [val] : val;\n};\n/**\n * Normalize all slashes in a file path or glob pattern to\n * forward slashes.\n */\n\n\nutils.unixify = function unixify(fp, opts) {\n  if (opts && opts.unixify === false) return fp;\n\n  if (opts && opts.unixify === true || win32 || path.sep === '\\\\') {\n    return utils.normalize(fp, false);\n  }\n\n  if (opts && opts.unescape === true) {\n    return fp ? fp.toString().replace(/\\\\(\\w)/g, '$1') : '';\n  }\n\n  return fp;\n};\n/**\n * Escape/unescape utils\n */\n\n\nutils.escapePath = function escapePath(fp) {\n  return fp.replace(/[\\\\.]/g, '\\\\$&');\n};\n\nutils.unescapeGlob = function unescapeGlob(fp) {\n  return fp.replace(/[\\\\\"']/g, '');\n};\n\nutils.escapeRe = function escapeRe(str) {\n  return str.replace(/[-[\\\\$*+?.#^\\s{}(|)\\]]/g, '\\\\$&');\n};\n/**\n * Expose `utils`\n */\n\n\nmodule.exports = utils;","map":null,"metadata":{},"sourceType":"script"}