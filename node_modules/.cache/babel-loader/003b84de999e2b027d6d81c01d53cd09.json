{"ast":null,"code":"// builtin\nvar fs = require('fs');\n\nvar path = require('path'); // vendor\n\n\nvar resv = require('resolve'); // given a path, create an array of node_module paths for it\n// borrowed from substack/resolve\n\n\nfunction nodeModulesPaths(start, cb) {\n  var splitRe = process.platform === 'win32' ? /[\\/\\\\]/ : /\\/+/;\n  var parts = start.split(splitRe);\n  var dirs = [];\n\n  for (var i = parts.length - 1; i >= 0; i--) {\n    if (parts[i] === 'node_modules') continue;\n    var dir = path.join.apply(path, parts.slice(0, i + 1).concat(['node_modules']));\n\n    if (!parts[0].match(/([A-Za-z]:)/)) {\n      dir = '/' + dir;\n    }\n\n    dirs.push(dir);\n  }\n\n  return dirs;\n}\n\nfunction find_shims_in_package(pkgJson, cur_path, shims, browser) {\n  try {\n    var info = JSON.parse(pkgJson);\n  } catch (err) {\n    err.message = pkgJson + ' : ' + err.message;\n    throw err;\n  }\n\n  var replacements = getReplacements(info, browser); // no replacements, skip shims\n\n  if (!replacements) {\n    return;\n  } // if browser mapping is a string\n  // then it just replaces the main entry point\n\n\n  if (typeof replacements === 'string') {\n    var key = path.resolve(cur_path, info.main || 'index.js');\n    shims[key] = path.resolve(cur_path, replacements);\n    return;\n  } // http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\n\n\n  Object.keys(replacements).forEach(function (key) {\n    var val;\n\n    if (replacements[key] === false) {\n      val = path.normalize(__dirname + '/empty.js');\n    } else {\n      val = replacements[key]; // if target is a relative path, then resolve\n      // otherwise we assume target is a module\n\n      if (val[0] === '.') {\n        val = path.resolve(cur_path, val);\n      }\n    }\n\n    if (key[0] === '/' || key[0] === '.') {\n      // if begins with / ../ or ./ then we must resolve to a full path\n      key = path.resolve(cur_path, key);\n    }\n\n    shims[key] = val;\n  });\n  ['.js', '.json'].forEach(function (ext) {\n    Object.keys(shims).forEach(function (key) {\n      if (!shims[key + ext]) {\n        shims[key + ext] = shims[key];\n      }\n    });\n  });\n} // paths is mutated\n// load shims from first package.json file found\n\n\nfunction load_shims(paths, browser, cb) {\n  // identify if our file should be replaced per the browser field\n  // original filename|id -> replacement\n  var shims = Object.create(null);\n\n  (function next() {\n    var cur_path = paths.shift();\n\n    if (!cur_path) {\n      return cb(null, shims);\n    }\n\n    var pkg_path = path.join(cur_path, 'package.json');\n    fs.readFile(pkg_path, 'utf8', function (err, data) {\n      if (err) {\n        // ignore paths we can't open\n        // avoids an exists check\n        if (err.code === 'ENOENT') {\n          return next();\n        }\n\n        return cb(err);\n      }\n\n      try {\n        find_shims_in_package(data, cur_path, shims, browser);\n        return cb(null, shims);\n      } catch (err) {\n        return cb(err);\n      }\n    });\n  })();\n}\n\n; // paths is mutated\n// synchronously load shims from first package.json file found\n\nfunction load_shims_sync(paths, browser) {\n  // identify if our file should be replaced per the browser field\n  // original filename|id -> replacement\n  var shims = Object.create(null);\n  var cur_path;\n\n  while (cur_path = paths.shift()) {\n    var pkg_path = path.join(cur_path, 'package.json');\n\n    try {\n      var data = fs.readFileSync(pkg_path, 'utf8');\n      find_shims_in_package(data, cur_path, shims, browser);\n      return shims;\n    } catch (err) {\n      // ignore paths we can't open\n      // avoids an exists check\n      if (err.code === 'ENOENT') {\n        continue;\n      }\n\n      throw err;\n    }\n  }\n\n  return shims;\n}\n\nfunction build_resolve_opts(opts, base) {\n  var packageFilter = opts.packageFilter;\n  var browser = normalizeBrowserFieldName(opts.browser);\n  opts.basedir = base;\n\n  opts.packageFilter = function (info, pkgdir) {\n    if (packageFilter) info = packageFilter(info, pkgdir);\n    var replacements = getReplacements(info, browser); // no browser field, keep info unchanged\n\n    if (!replacements) {\n      return info;\n    }\n\n    info[browser] = replacements; // replace main\n\n    if (typeof replacements === 'string') {\n      info.main = replacements;\n      return info;\n    }\n\n    var replace_main = replacements[info.main || './index.js'] || replacements['./' + info.main || './index.js'];\n    info.main = replace_main || info.main;\n    return info;\n  };\n\n  var pathFilter = opts.pathFilter;\n\n  opts.pathFilter = function (info, resvPath, relativePath) {\n    if (relativePath[0] != '.') {\n      relativePath = './' + relativePath;\n    }\n\n    var mappedPath;\n\n    if (pathFilter) {\n      mappedPath = pathFilter.apply(this, arguments);\n    }\n\n    if (mappedPath) {\n      return mappedPath;\n    }\n\n    var replacements = info[browser];\n\n    if (!replacements) {\n      return;\n    }\n\n    mappedPath = replacements[relativePath];\n\n    if (!mappedPath && path.extname(relativePath) === '') {\n      mappedPath = replacements[relativePath + '.js'];\n\n      if (!mappedPath) {\n        mappedPath = replacements[relativePath + '.json'];\n      }\n    }\n\n    return mappedPath;\n  };\n\n  return opts;\n}\n\nfunction resolve(id, opts, cb) {\n  // opts.filename\n  // opts.paths\n  // opts.modules\n  // opts.packageFilter\n  opts = opts || {};\n  opts.filename = opts.filename || '';\n  var base = path.dirname(opts.filename);\n\n  if (opts.basedir) {\n    base = opts.basedir;\n  }\n\n  var paths = nodeModulesPaths(base);\n\n  if (opts.paths) {\n    paths.push.apply(paths, opts.paths);\n  }\n\n  paths = paths.map(function (p) {\n    return path.dirname(p);\n  }); // we must always load shims because the browser field could shim out a module\n\n  load_shims(paths, opts.browser, function (err, shims) {\n    if (err) {\n      return cb(err);\n    }\n\n    var resid = path.resolve(opts.basedir || path.dirname(opts.filename), id);\n\n    if (shims[id] || shims[resid]) {\n      var xid = shims[id] ? id : resid; // if the shim was is an absolute path, it was fully resolved\n\n      if (shims[xid][0] === '/') {\n        return resv(shims[xid], build_resolve_opts(opts, base), function (err, full, pkg) {\n          cb(null, full, pkg);\n        });\n      } // module -> alt-module shims\n\n\n      id = shims[xid];\n    }\n\n    var modules = opts.modules || Object.create(null);\n    var shim_path = modules[id];\n\n    if (shim_path) {\n      return cb(null, shim_path);\n    } // our browser field resolver\n    // if browser field is an object tho?\n\n\n    var full = resv(id, build_resolve_opts(opts, base), function (err, full, pkg) {\n      if (err) {\n        return cb(err);\n      }\n\n      var resolved = shims ? shims[full] || full : full;\n      cb(null, resolved, pkg);\n    });\n  });\n}\n\n;\n\nresolve.sync = function (id, opts) {\n  // opts.filename\n  // opts.paths\n  // opts.modules\n  // opts.packageFilter\n  opts = opts || {};\n  opts.filename = opts.filename || '';\n  var base = path.dirname(opts.filename);\n\n  if (opts.basedir) {\n    base = opts.basedir;\n  }\n\n  var paths = nodeModulesPaths(base);\n\n  if (opts.paths) {\n    paths.push.apply(paths, opts.paths);\n  }\n\n  paths = paths.map(function (p) {\n    return path.dirname(p);\n  }); // we must always load shims because the browser field could shim out a module\n\n  var shims = load_shims_sync(paths, opts.browser);\n  var resid = path.resolve(opts.basedir || path.dirname(opts.filename), id);\n\n  if (shims[id] || shims[resid]) {\n    var xid = shims[id] ? id : resid; // if the shim was is an absolute path, it was fully resolved\n\n    if (shims[xid][0] === '/') {\n      return resv.sync(shims[xid], build_resolve_opts(opts, base));\n    } // module -> alt-module shims\n\n\n    id = shims[xid];\n  }\n\n  var modules = opts.modules || Object.create(null);\n  var shim_path = modules[id];\n\n  if (shim_path) {\n    return shim_path;\n  } // our browser field resolver\n  // if browser field is an object tho?\n\n\n  var full = resv.sync(id, build_resolve_opts(opts, base));\n  return shims ? shims[full] || full : full;\n};\n\nfunction normalizeBrowserFieldName(browser) {\n  return browser || 'browser';\n}\n\nfunction getReplacements(info, browser) {\n  browser = normalizeBrowserFieldName(browser);\n  var replacements = info[browser] || info.browser; // support legacy browserify field for easier migration from legacy\n  // many packages used this field historically\n\n  if (typeof info.browserify === 'string' && !replacements) {\n    replacements = info.browserify;\n  }\n\n  return replacements;\n}\n\nmodule.exports = resolve;","map":null,"metadata":{},"sourceType":"script"}