{"ast":null,"code":"/**\r\n * node-compress-commons\r\n *\r\n * Copyright (c) 2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT\r\n */\nvar inherits = require('util').inherits;\n\nvar crc32 = require('buffer-crc32');\n\nvar CRC32Stream = require('crc32-stream');\n\nvar DeflateCRC32Stream = CRC32Stream.DeflateCRC32Stream;\n\nvar ArchiveOutputStream = require('../archive-output-stream');\n\nvar ZipArchiveEntry = require('./zip-archive-entry');\n\nvar GeneralPurposeBit = require('./general-purpose-bit');\n\nvar constants = require('./constants');\n\nvar util = require('../../util');\n\nvar zipUtil = require('./util');\n\nvar ZipArchiveOutputStream = module.exports = function (options) {\n  if (!(this instanceof ZipArchiveOutputStream)) {\n    return new ZipArchiveOutputStream(options);\n  }\n\n  options = this.options = this._defaults(options);\n  ArchiveOutputStream.call(this, options);\n  this._entry = null;\n  this._entries = [];\n  this._archive = {\n    centralLength: 0,\n    centralOffset: 0,\n    comment: '',\n    finish: false,\n    finished: false,\n    processing: false,\n    forceZip64: options.forceZip64,\n    forceLocalTime: options.forceLocalTime\n  };\n};\n\ninherits(ZipArchiveOutputStream, ArchiveOutputStream);\n\nZipArchiveOutputStream.prototype._afterAppend = function (ae) {\n  this._entries.push(ae);\n\n  if (ae.getGeneralPurposeBit().usesDataDescriptor()) {\n    this._writeDataDescriptor(ae);\n  }\n\n  this._archive.processing = false;\n  this._entry = null;\n\n  if (this._archive.finish && !this._archive.finished) {\n    this._finish();\n  }\n};\n\nZipArchiveOutputStream.prototype._appendBuffer = function (ae, source, callback) {\n  if (source.length === 0) {\n    ae.setMethod(constants.METHOD_STORED);\n  }\n\n  var method = ae.getMethod();\n\n  if (method === constants.METHOD_STORED) {\n    ae.setSize(source.length);\n    ae.setCompressedSize(source.length);\n    ae.setCrc(crc32.unsigned(source));\n  }\n\n  this._writeLocalFileHeader(ae);\n\n  if (method === constants.METHOD_STORED) {\n    this.write(source);\n\n    this._afterAppend(ae);\n\n    callback(null, ae);\n    return;\n  } else if (method === constants.METHOD_DEFLATED) {\n    this._smartStream(ae, callback).end(source);\n\n    return;\n  } else {\n    callback(new Error('compression method ' + method + ' not implemented'));\n    return;\n  }\n};\n\nZipArchiveOutputStream.prototype._appendStream = function (ae, source, callback) {\n  ae.getGeneralPurposeBit().useDataDescriptor(true);\n  ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);\n\n  this._writeLocalFileHeader(ae);\n\n  var smart = this._smartStream(ae, callback);\n\n  source.once('error', function (err) {\n    smart.emit('error', err);\n    smart.end();\n  });\n  source.pipe(smart);\n};\n\nZipArchiveOutputStream.prototype._defaults = function (o) {\n  if (typeof o !== 'object') {\n    o = {};\n  }\n\n  if (typeof o.zlib !== 'object') {\n    o.zlib = {};\n  }\n\n  if (typeof o.zlib.level !== 'number') {\n    o.zlib.level = constants.ZLIB_BEST_SPEED;\n  }\n\n  o.forceZip64 = !!o.forceZip64;\n  o.forceLocalTime = !!o.forceLocalTime;\n  return o;\n};\n\nZipArchiveOutputStream.prototype._finish = function () {\n  this._archive.centralOffset = this.offset;\n\n  this._entries.forEach(function (ae) {\n    this._writeCentralFileHeader(ae);\n  }.bind(this));\n\n  this._archive.centralLength = this.offset - this._archive.centralOffset;\n\n  if (this.isZip64()) {\n    this._writeCentralDirectoryZip64();\n  }\n\n  this._writeCentralDirectoryEnd();\n\n  this._archive.processing = false;\n  this._archive.finish = true;\n  this._archive.finished = true;\n  this.end();\n};\n\nZipArchiveOutputStream.prototype._normalizeEntry = function (ae) {\n  if (ae.getMethod() === -1) {\n    ae.setMethod(constants.METHOD_DEFLATED);\n  }\n\n  if (ae.getMethod() === constants.METHOD_DEFLATED) {\n    ae.getGeneralPurposeBit().useDataDescriptor(true);\n    ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);\n  }\n\n  if (ae.getTime() === -1) {\n    ae.setTime(new Date(), this._archive.forceLocalTime);\n  }\n\n  ae._offsets = {\n    file: 0,\n    data: 0,\n    contents: 0\n  };\n};\n\nZipArchiveOutputStream.prototype._smartStream = function (ae, callback) {\n  var deflate = ae.getMethod() === constants.METHOD_DEFLATED;\n  var process = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream();\n  var error = null;\n\n  function handleStuff() {\n    var digest = process.digest().readUInt32BE(0);\n    ae.setCrc(digest);\n    ae.setSize(process.size());\n    ae.setCompressedSize(process.size(true));\n\n    this._afterAppend(ae);\n\n    callback(error, ae);\n  }\n\n  process.once('end', handleStuff.bind(this));\n  process.once('error', function (err) {\n    error = err;\n  });\n  process.pipe(this, {\n    end: false\n  });\n  return process;\n};\n\nZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function () {\n  var records = this._entries.length;\n  var size = this._archive.centralLength;\n  var offset = this._archive.centralOffset;\n\n  if (this.isZip64()) {\n    records = constants.ZIP64_MAGIC_SHORT;\n    size = constants.ZIP64_MAGIC;\n    offset = constants.ZIP64_MAGIC;\n  } // signature\n\n\n  this.write(zipUtil.getLongBytes(constants.SIG_EOCD)); // disk numbers\n\n  this.write(constants.SHORT_ZERO);\n  this.write(constants.SHORT_ZERO); // number of entries\n\n  this.write(zipUtil.getShortBytes(records));\n  this.write(zipUtil.getShortBytes(records)); // length and location of CD\n\n  this.write(zipUtil.getLongBytes(size));\n  this.write(zipUtil.getLongBytes(offset)); // archive comment\n\n  var comment = this.getComment();\n  var commentLength = Buffer.byteLength(comment);\n  this.write(zipUtil.getShortBytes(commentLength));\n  this.write(comment);\n};\n\nZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function () {\n  // signature\n  this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD)); // size of the ZIP64 EOCD record\n\n  this.write(zipUtil.getEightBytes(44)); // version made by\n\n  this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64)); // version to extract\n\n  this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64)); // disk numbers\n\n  this.write(constants.LONG_ZERO);\n  this.write(constants.LONG_ZERO); // number of entries\n\n  this.write(zipUtil.getEightBytes(this._entries.length));\n  this.write(zipUtil.getEightBytes(this._entries.length)); // length and location of CD\n\n  this.write(zipUtil.getEightBytes(this._archive.centralLength));\n  this.write(zipUtil.getEightBytes(this._archive.centralOffset)); // extensible data sector\n  // not implemented at this time\n  // end of central directory locator\n\n  this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC)); // disk number holding the ZIP64 EOCD record\n\n  this.write(constants.LONG_ZERO); // relative offset of the ZIP64 EOCD record\n\n  this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength)); // total number of disks\n\n  this.write(zipUtil.getLongBytes(1));\n};\n\nZipArchiveOutputStream.prototype._writeCentralFileHeader = function (ae) {\n  var gpb = ae.getGeneralPurposeBit();\n  var method = ae.getMethod();\n  var offsets = ae._offsets;\n  var size = ae.getSize();\n  var compressedSize = ae.getCompressedSize();\n\n  if (ae.isZip64() || offsets.file > constants.ZIP64_MAGIC) {\n    size = constants.ZIP64_MAGIC;\n    compressedSize = constants.ZIP64_MAGIC;\n    ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);\n    var extraBuf = Buffer.concat([zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID), zipUtil.getShortBytes(24), zipUtil.getEightBytes(ae.getSize()), zipUtil.getEightBytes(ae.getCompressedSize()), zipUtil.getEightBytes(offsets.file)], 28);\n    ae.setExtra(extraBuf);\n  } // signature\n\n\n  this.write(zipUtil.getLongBytes(constants.SIG_CFH)); // version made by\n\n  this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY)); // version to extract and general bit flag\n\n  this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));\n  this.write(gpb.encode()); // compression method\n\n  this.write(zipUtil.getShortBytes(method)); // datetime\n\n  this.write(zipUtil.getLongBytes(ae.getTimeDos())); // crc32 checksum\n\n  this.write(zipUtil.getLongBytes(ae.getCrc())); // sizes\n\n  this.write(zipUtil.getLongBytes(compressedSize));\n  this.write(zipUtil.getLongBytes(size));\n  var name = ae.getName();\n  var comment = ae.getComment();\n  var extra = ae.getCentralDirectoryExtra();\n\n  if (gpb.usesUTF8ForNames()) {\n    name = new Buffer(name);\n    comment = new Buffer(comment);\n  } // name length\n\n\n  this.write(zipUtil.getShortBytes(name.length)); // extra length\n\n  this.write(zipUtil.getShortBytes(extra.length)); // comments length\n\n  this.write(zipUtil.getShortBytes(comment.length)); // disk number start\n\n  this.write(constants.SHORT_ZERO); // internal attributes\n\n  this.write(zipUtil.getShortBytes(ae.getInternalAttributes())); // external attributes\n\n  this.write(zipUtil.getLongBytes(ae.getExternalAttributes())); // relative offset of LFH\n\n  if (offsets.file > constants.ZIP64_MAGIC) {\n    this.write(zipUtil.getLongBytes(constants.ZIP64_MAGIC));\n  } else {\n    this.write(zipUtil.getLongBytes(offsets.file));\n  } // name\n\n\n  this.write(name); // extra\n\n  this.write(extra); // comment\n\n  this.write(comment);\n};\n\nZipArchiveOutputStream.prototype._writeDataDescriptor = function (ae) {\n  // signature\n  this.write(zipUtil.getLongBytes(constants.SIG_DD)); // crc32 checksum\n\n  this.write(zipUtil.getLongBytes(ae.getCrc())); // sizes\n\n  if (ae.isZip64()) {\n    this.write(zipUtil.getEightBytes(ae.getCompressedSize()));\n    this.write(zipUtil.getEightBytes(ae.getSize()));\n  } else {\n    this.write(zipUtil.getLongBytes(ae.getCompressedSize()));\n    this.write(zipUtil.getLongBytes(ae.getSize()));\n  }\n};\n\nZipArchiveOutputStream.prototype._writeLocalFileHeader = function (ae) {\n  var gpb = ae.getGeneralPurposeBit();\n  var method = ae.getMethod();\n  var name = ae.getName();\n  var extra = ae.getLocalFileDataExtra();\n\n  if (ae.isZip64()) {\n    gpb.useDataDescriptor(true);\n    ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);\n  }\n\n  if (gpb.usesUTF8ForNames()) {\n    name = new Buffer(name);\n  }\n\n  ae._offsets.file = this.offset; // signature\n\n  this.write(zipUtil.getLongBytes(constants.SIG_LFH)); // version to extract and general bit flag\n\n  this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));\n  this.write(gpb.encode()); // compression method\n\n  this.write(zipUtil.getShortBytes(method)); // datetime\n\n  this.write(zipUtil.getLongBytes(ae.getTimeDos()));\n  ae._offsets.data = this.offset; // crc32 checksum and sizes\n\n  if (gpb.usesDataDescriptor()) {\n    this.write(constants.LONG_ZERO);\n    this.write(constants.LONG_ZERO);\n    this.write(constants.LONG_ZERO);\n  } else {\n    this.write(zipUtil.getLongBytes(ae.getCrc()));\n    this.write(zipUtil.getLongBytes(ae.getCompressedSize()));\n    this.write(zipUtil.getLongBytes(ae.getSize()));\n  } // name length\n\n\n  this.write(zipUtil.getShortBytes(name.length)); // extra length\n\n  this.write(zipUtil.getShortBytes(extra.length)); // name\n\n  this.write(name); // extra\n\n  this.write(extra);\n  ae._offsets.contents = this.offset;\n};\n\nZipArchiveOutputStream.prototype.getComment = function (comment) {\n  return this._archive.comment !== null ? this._archive.comment : '';\n};\n\nZipArchiveOutputStream.prototype.isZip64 = function () {\n  return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;\n};\n\nZipArchiveOutputStream.prototype.setComment = function (comment) {\n  this._archive.comment = comment;\n};","map":null,"metadata":{},"sourceType":"script"}