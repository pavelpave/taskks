{"ast":null,"code":"'use strict';\n\nvar stream = require('readable-stream');\n\nvar util = require('util');\n\nvar Readable = stream.Readable;\nmodule.exports = ReaddirpReadable;\nutil.inherits(ReaddirpReadable, Readable);\n\nfunction ReaddirpReadable(opts) {\n  if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);\n  opts = opts || {};\n  opts.objectMode = true;\n  Readable.call(this, opts); // backpressure not implemented at this point\n\n  this.highWaterMark = Infinity;\n  this._destroyed = false;\n  this._paused = false;\n  this._warnings = [];\n  this._errors = [];\n\n  this._pauseResumeErrors();\n}\n\nvar proto = ReaddirpReadable.prototype;\n\nproto._pauseResumeErrors = function () {\n  var self = this;\n  self.on('pause', function () {\n    self._paused = true;\n  });\n  self.on('resume', function () {\n    if (self._destroyed) return;\n    self._paused = false;\n\n    self._warnings.forEach(function (err) {\n      self.emit('warn', err);\n    });\n\n    self._warnings.length = 0;\n\n    self._errors.forEach(function (err) {\n      self.emit('error', err);\n    });\n\n    self._errors.length = 0;\n  });\n}; // called for each entry\n\n\nproto._processEntry = function (entry) {\n  if (this._destroyed) return;\n  this.push(entry);\n};\n\nproto._read = function () {};\n\nproto.destroy = function () {\n  // when stream is destroyed it will emit nothing further, not even errors or warnings\n  this.push(null);\n  this.readable = false;\n  this._destroyed = true;\n  this.emit('close');\n};\n\nproto._done = function () {\n  this.push(null);\n}; // we emit errors and warnings async since we may handle errors like invalid args\n// within the initial event loop before any event listeners subscribed\n\n\nproto._handleError = function (err) {\n  var self = this;\n  setImmediate(function () {\n    if (self._paused) return self._warnings.push(err);\n    if (!self._destroyed) self.emit('warn', err);\n  });\n};\n\nproto._handleFatalError = function (err) {\n  var self = this;\n  setImmediate(function () {\n    if (self._paused) return self._errors.push(err);\n    if (!self._destroyed) self.emit('error', err);\n  });\n};\n\nfunction createStreamAPI() {\n  var stream = new ReaddirpReadable();\n  return {\n    stream: stream,\n    processEntry: stream._processEntry.bind(stream),\n    done: stream._done.bind(stream),\n    handleError: stream._handleError.bind(stream),\n    handleFatalError: stream._handleFatalError.bind(stream)\n  };\n}\n\nmodule.exports = createStreamAPI;","map":null,"metadata":{},"sourceType":"script"}