{"ast":null,"code":"/**\r\n * node-compress-commons\r\n *\r\n * Copyright (c) 2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT\r\n */\nvar inherits = require('util').inherits;\n\nvar Transform = require('readable-stream').Transform;\n\nvar ArchiveEntry = require('./archive-entry');\n\nvar util = require('../util');\n\nvar ArchiveOutputStream = module.exports = function (options) {\n  if (!(this instanceof ArchiveOutputStream)) {\n    return new ArchiveOutputStream(options);\n  }\n\n  Transform.call(this, options);\n  this.offset = 0;\n  this._archive = {\n    finish: false,\n    finished: false,\n    processing: false\n  };\n};\n\ninherits(ArchiveOutputStream, Transform);\n\nArchiveOutputStream.prototype._appendBuffer = function (zae, source, callback) {// scaffold only\n};\n\nArchiveOutputStream.prototype._appendStream = function (zae, source, callback) {// scaffold only\n};\n\nArchiveOutputStream.prototype._emitErrorCallback = function (err) {\n  if (err) {\n    this.emit('error', err);\n  }\n};\n\nArchiveOutputStream.prototype._finish = function (ae) {// scaffold only\n};\n\nArchiveOutputStream.prototype._normalizeEntry = function (ae) {// scaffold only\n};\n\nArchiveOutputStream.prototype._transform = function (chunk, encoding, callback) {\n  callback(null, chunk);\n};\n\nArchiveOutputStream.prototype.entry = function (ae, source, callback) {\n  source = source || null;\n\n  if (typeof callback !== 'function') {\n    callback = this._emitErrorCallback.bind(this);\n  }\n\n  if (!(ae instanceof ArchiveEntry)) {\n    callback(new Error('not a valid instance of ArchiveEntry'));\n    return;\n  }\n\n  if (this._archive.finish || this._archive.finished) {\n    callback(new Error('unacceptable entry after finish'));\n    return;\n  }\n\n  if (this._archive.processing) {\n    callback(new Error('already processing an entry'));\n    return;\n  }\n\n  this._archive.processing = true;\n\n  this._normalizeEntry(ae);\n\n  this._entry = ae;\n  source = util.normalizeInputSource(source);\n\n  if (Buffer.isBuffer(source)) {\n    this._appendBuffer(ae, source, callback);\n  } else if (util.isStream(source)) {\n    this._appendStream(ae, source, callback);\n  } else {\n    this._archive.processing = false;\n    callback(new Error('input source must be valid Stream or Buffer instance'));\n    return;\n  }\n\n  return this;\n};\n\nArchiveOutputStream.prototype.finish = function () {\n  if (this._archive.processing) {\n    this._archive.finish = true;\n    return;\n  }\n\n  this._finish();\n};\n\nArchiveOutputStream.prototype.getBytesWritten = function () {\n  return this.offset;\n};\n\nArchiveOutputStream.prototype.write = function (chunk, cb) {\n  if (chunk) {\n    this.offset += chunk.length;\n  }\n\n  return Transform.prototype.write.call(this, chunk, cb);\n};","map":null,"metadata":{},"sourceType":"script"}