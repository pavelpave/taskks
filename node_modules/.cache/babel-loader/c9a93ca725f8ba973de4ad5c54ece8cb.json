{"ast":null,"code":"'use strict';\n\nvar emitterify = require('./emitterify'),\n    keys = require('./keys'),\n    key = require('./key'),\n    deep = key,\n    rsplit = /([^\\.\\[]*)/;\n\nmodule.exports = once;\n\nfunction once(nodes, enter, exit) {\n  var n = c.nodes = Array === nodes.constructor ? nodes : 'string' === typeof nodes ? document.querySelectorAll(nodes) : [nodes];\n  var p = n.length;\n\n  while (p-- > 0) {\n    if (!n[p].on) event(n[p], p);\n  }\n\n  c.node = function () {\n    return n[0];\n  };\n\n  c.enter = function () {\n    return once(enter);\n  };\n\n  c.exit = function () {\n    return once(exit);\n  };\n\n  c.size = function () {\n    return n.length;\n  };\n\n  c.text = function (value) {\n    var fn = 'function' === typeof value;\n    return arguments.length === 0 ? n[0].textContent : (this.each(function (n, d, i) {\n      var r = '' + (fn ? value.call(this, d, i) : value),\n          t;\n      if (this.textContent !== r) !(t = this.firstChild) ? this.appendChild(document.createTextNode(r)) : t.nodeName === '#text' ? t.nodeValue = r : this.textContent = r;\n    }), this);\n  };\n\n  c.html = function (value) {\n    var fn = 'function' === typeof value;\n    return arguments.length === 0 ? n[0].innerHTML : (this.each(function (n, d, i) {\n      var r = '' + (fn ? value.call(this, d, i) : value),\n          t;\n      if (this.innerHTML !== r) this.innerHTML = r;\n    }), this);\n  };\n\n  c.attr = function (key, value) {\n    var fn = 'function' === typeof value;\n    return arguments.length === 1 ? n[0].getAttribute(key) : (this.each(function (n, d, i) {\n      var r = fn ? value.call(this, d, i) : value;\n      if (!r && this.hasAttribute(key)) this.removeAttribute(key);else if (r && this.getAttribute(key) !== r) this.setAttribute(key, r);\n    }), this);\n  };\n\n  c.classed = function (key, value) {\n    var fn = 'function' === typeof value;\n    return arguments.length === 1 ? n[0].classList.contains(key) : (this.each(function (n, d, i) {\n      var r = fn ? value.call(this, d, i) : value;\n      if (r && !this.classList.contains(key)) this.classList.add(key);else if (!r && this.classList.contains(key)) this.classList.remove(key);\n    }), this);\n  };\n\n  c.property = function (key, value) {\n    var fn = 'function' === typeof value;\n    return arguments.length === 1 ? deep(key)(n[0]) : (this.each(function (n, d, i) {\n      var r = fn ? value.call(this, d, i) : value;\n      if (r !== undefined && deep(key)(this) !== r) deep(key, function () {\n        return r;\n      })(this);\n    }), this);\n  };\n\n  c.each = function (fn) {\n    p = -1;\n\n    while (n[++p]) {\n      fn.call(n[p], n[p], n[p].state, p);\n    }\n\n    return this;\n  };\n\n  c.remove = function () {\n    this.each(function () {\n      var el = this.host && this.host.nodeName ? this.host : this;\n      el.parentNode.removeChild(el);\n    });\n    return this;\n  };\n\n  c.closest = function (tag) {\n    return once(n.map(function (d) {\n      return d.closest(tag);\n    }).filter(Boolean));\n  };\n\n  c.draw = proxy('draw', c);\n  c.once = proxy('once', c);\n  c.emit = proxy('emit', c);\n  c.on = proxy('on', c);\n  return c;\n\n  function c(s, d, k, b) {\n    var selector,\n        data,\n        tnodes = [],\n        tenter = [],\n        texit = [],\n        j = -1,\n        p = -1,\n        l = -1,\n        t = -1; // reselect\n\n    if (arguments.length === 1) {\n      if ('string' !== typeof s) return once(s);\n\n      while (n[++p]) {\n        tnodes = tnodes.concat(Array.prototype.slice.call(n[p].querySelectorAll(s), 0));\n      }\n\n      return once(tnodes);\n    } // shortcut\n\n\n    if (d === 1 && arguments.length == 2) {\n      while (n[++p]) {\n        j = n[p].children.length;\n        selector = s.call ? s(n[p].state || 1, 0) : s;\n\n        while (n[p].children[--j]) {\n          if (n[p].children[j].matches(selector)) {\n            (tnodes[++t] = n[p].children[j]).state = n[p].state || 1;\n            break;\n          }\n        }\n\n        if (j < 0) n[p].appendChild(tnodes[++t] = tenter[tenter.length] = create(selector, [n[p].state || 1], 0));\n        if ('function' === typeof tnodes[t].draw) tnodes[t].draw();\n      }\n\n      return once(tnodes, tenter, texit);\n    } // main loop\n\n\n    while (n[++p]) {\n      selector = 'function' === typeof s ? s(n[p].state) : s;\n      data = 'function' === typeof d ? d(n[p].state) : d;\n      if (d === 1) data = n[p].state || [1];\n      if ('string' === typeof data) data = [data];\n      if (!data) data = [];\n      if (data.constructor !== Array) data = [data];\n\n      if (k) {\n        byKey(selector, data, k, b, n[p], tnodes, tenter, texit);\n        continue;\n      }\n\n      l = -1;\n      j = -1;\n\n      while (n[p].children[++j]) {\n        if (!n[p].children[j].matches(selector)) continue;\n\n        if (++l >= data.length) {\n          // exit\n          n[p].removeChild(texit[texit.length] = n[p].children[j]), --j;\n          continue;\n        }\n\n        (tnodes[++t] = n[p].children[j]).state = data[l]; // update\n\n        if ('function' === typeof n[p].children[j].draw) n[p].children[j].draw();\n      } // enter\n\n\n      if (typeof selector === 'string') {\n        n[p].templates = n[p].templates || {};\n        n[p].templates[selector] = n[p].templates[selector] || create(selector, [], 0);\n\n        while (++l < data.length) {\n          (b ? n[p].insertBefore(tnodes[++t] = tenter[tenter.length] = n[p].templates[selector].cloneNode(false), n[p].querySelector(b)) : n[p].appendChild(tnodes[++t] = tenter[tenter.length] = n[p].templates[selector].cloneNode(false))).state = data[l];\n          if ('function' === typeof tnodes[t].draw) tnodes[t].draw();\n        }\n      } else {\n        while (++l < data.length) {\n          b ? n[p].insertBefore(tnodes[++t] = tenter[tenter.length] = create(selector, data, l), n[p].querySelector(b)) : n[p].appendChild(tnodes[++t] = tenter[tenter.length] = create(selector, data, l));\n          if ('function' === typeof tnodes[t].draw) tnodes[t].draw();\n        }\n      }\n    }\n\n    return once(tnodes, tenter, texit);\n  }\n} // TODO: factor out - need to fix nbuild / non-./deps\n\n\nfunction event(node) {\n  // node = node.host && node.host.nodeName ? node.host : node\n  if (node.on) return;\n  node.listeners = {};\n\n  var on = function on(o) {\n    var type = o.type.split('.').shift();\n    if (!node.listeners[type]) node.addEventListener(type, node.listeners[type] = function (event) {\n      return !event.detail || !event.detail.emitted ? emit(type, [event, node.state, node]) : 0;\n    });\n  };\n\n  var off = function off(o) {\n    if (!node.on[o.type].length) {\n      node.removeEventListener(o.type, node.listeners[o.type]);\n      delete node.listeners[o.type];\n    }\n  };\n\n  emitterify(node, {\n    on: on,\n    off: off\n  });\n  var emit = node.emit;\n\n  node.emit = function (type, params) {\n    var detail = {\n      params: params,\n      emitted: true\n    },\n        event = new CustomEvent(type, {\n      detail: detail,\n      bubbles: false,\n      cancelable: true\n    });\n    node.dispatchEvent(event);\n    return emit(type, event);\n  };\n}\n\nfunction proxy(fn, c) {\n  return function () {\n    var args = arguments;\n    c.each(function () {\n      var node = this.host && this.host.nodeName ? this.host : this;\n      node[fn] && node[fn].apply(node, args);\n    });\n    return c;\n  };\n}\n\nfunction create(s, d, j) {\n  var i = 0,\n      attrs = [],\n      css = [],\n      sel = s.call ? s(d[j], j) : s,\n      tag = rsplit.exec(sel)[1] || 'div',\n      node = document.createElement(tag);\n  (s.call ? s.toString() : s).replace(/\\[(.+?)=\"(.*?)\"\\]/g, function ($1, $2, $3) {\n    return attrs[attrs.length] = [$2, $3], '';\n  }).replace(/\\.([^.]+)/g, function ($1, $2) {\n    return css[css.length] = $2, '';\n  });\n\n  for (i = 0; i < attrs.length; i++) {\n    node.setAttribute(attrs[i][0], attrs[i][1]);\n  }\n\n  for (i = 0; i < css.length; i++) {\n    node.classList.add(css[i]);\n  }\n\n  node.state = d[j] || 1;\n  return node;\n}\n\nfunction byKey(selector, data, key, b, parent, tnodes, tenter, texit) {\n  var c = -1,\n      d = data.length,\n      k,\n      indexNodes = {},\n      child,\n      next;\n\n  while (parent.children[++c]) {\n    if (!parent.children[c].matches(selector)) continue;else indexNodes[key(parent.children[c].state)] = parent.children[c];\n  }\n\n  next = b ? parent.querySelector(b) : null;\n\n  while (d--) {\n    if (child = indexNodes[k = key(data[d])]) {\n      if (child === true) continue;else child.state = data[d];\n    } else tenter.unshift(child = create(selector, data, d));\n    indexNodes[k] = true;\n    if (d == data.length - 1 || next !== child.nextSibling) parent.insertBefore(child, next);\n    tnodes.unshift(next = child);\n    if ('function' === typeof child.draw) child.draw();\n  }\n\n  for (c in indexNodes) {\n    if (indexNodes[c] !== true) texit.unshift(parent.removeChild(indexNodes[c]));\n  }\n}","map":null,"metadata":{},"sourceType":"script"}