{"ast":null,"code":"var undeclaredIdentifiers = require('undeclared-identifiers');\n\nvar through = require('through2');\n\nvar merge = require('xtend');\n\nvar parse = require('acorn-node').parse;\n\nvar path = require('path');\n\nvar isAbsolute = path.isAbsolute || require('path-is-absolute');\n\nvar processPath = require.resolve('process/browser.js');\n\nvar isbufferPath = require.resolve('is-buffer');\n\nvar combineSourceMap = require('combine-source-map');\n\nfunction getRelativeRequirePath(fullPath, fromPath) {\n  var relpath = path.relative(path.dirname(fromPath), fullPath); // If fullPath is in the same directory or a subdirectory of fromPath,\n  // relpath will result in something like \"index.js\", \"src/abc.js\".\n  // require() needs \"./\" prepended to these paths.\n\n  if (!/^\\./.test(relpath) && !isAbsolute(relpath)) {\n    relpath = \"./\" + relpath;\n  } // On Windows: Convert path separators to what require() expects\n\n\n  if (path.sep === '\\\\') {\n    relpath = relpath.replace(/\\\\/g, '/');\n  }\n\n  return relpath;\n}\n\nvar defaultVars = {\n  process: function process(file) {\n    var relpath = getRelativeRequirePath(processPath, file);\n    return 'require(' + JSON.stringify(relpath) + ')';\n  },\n  global: function global() {\n    return 'typeof global !== \"undefined\" ? global : ' + 'typeof self !== \"undefined\" ? self : ' + 'typeof window !== \"undefined\" ? window : {}';\n  },\n  'Buffer.isBuffer': function BufferIsBuffer(file) {\n    var relpath = getRelativeRequirePath(isbufferPath, file);\n    return 'require(' + JSON.stringify(relpath) + ')';\n  },\n  Buffer: function Buffer() {\n    return 'require(\"buffer\").Buffer';\n  },\n  setImmediate: function setImmediate() {\n    return 'require(\"timers\").setImmediate';\n  },\n  clearImmediate: function clearImmediate() {\n    return 'require(\"timers\").clearImmediate';\n  },\n  __filename: function __filename(file, basedir) {\n    var relpath = path.relative(basedir, file); // standardize path separators, use slash in Windows too\n\n    if (path.sep === '\\\\') {\n      relpath = relpath.replace(/\\\\/g, '/');\n    }\n\n    var filename = '/' + relpath;\n    return JSON.stringify(filename);\n  },\n  __dirname: function __dirname(file, basedir) {\n    var relpath = path.relative(basedir, file); // standardize path separators, use slash in Windows too\n\n    if (path.sep === '\\\\') {\n      relpath = relpath.replace(/\\\\/g, '/');\n    }\n\n    var dir = path.dirname('/' + relpath);\n    return JSON.stringify(dir);\n  }\n};\n\nmodule.exports = function (file, opts) {\n  if (/\\.json$/i.test(file)) return through();\n  if (!opts) opts = {};\n  var basedir = opts.basedir || '/';\n  var vars = merge(defaultVars, opts.vars);\n  var varNames = Object.keys(vars).filter(function (name) {\n    return typeof vars[name] === 'function';\n  });\n  var quick = RegExp(varNames.map(function (name) {\n    return '\\\\b' + name + '\\\\b';\n  }).join('|'));\n  var chunks = [];\n  return through(write, end);\n\n  function write(chunk, enc, next) {\n    chunks.push(chunk);\n    next();\n  }\n\n  function end() {\n    var self = this;\n    var source = Buffer.isBuffer(chunks[0]) ? Buffer.concat(chunks).toString('utf8') : chunks.join('');\n    source = source.replace(/^\\ufeff/, '').replace(/^#![^\\n]*\\n/, '\\n');\n\n    if (opts.always !== true && !quick.test(source)) {\n      this.push(source);\n      this.push(null);\n      return;\n    }\n\n    try {\n      var undeclared = opts.always ? {\n        identifiers: varNames,\n        properties: []\n      } : undeclaredIdentifiers(parse(source), {\n        wildcard: true\n      });\n    } catch (err) {\n      var e = new SyntaxError((err.message || err) + ' while parsing ' + file);\n      e.type = 'syntax';\n      e.filename = file;\n      return this.emit('error', e);\n    }\n\n    var globals = {};\n    varNames.forEach(function (name) {\n      if (!/\\./.test(name)) return;\n      var parts = name.split('.');\n      var prop = undeclared.properties.indexOf(name);\n      if (prop === -1 || countprops(undeclared.properties, parts[0]) > 1) return;\n      var value = vars[name](file, basedir);\n      if (!value) return;\n      globals[parts[0]] = '{' + JSON.stringify(parts[1]) + ':' + value + '}';\n      self.emit('global', name);\n    });\n    varNames.forEach(function (name) {\n      if (/\\./.test(name)) return;\n      if (globals[name]) return;\n      if (undeclared.identifiers.indexOf(name) < 0) return;\n      var value = vars[name](file, basedir);\n      if (!value) return;\n      globals[name] = value;\n      self.emit('global', name);\n    });\n    this.push(closeOver(globals, source, file, opts));\n    this.push(null);\n  }\n};\n\nmodule.exports.vars = defaultVars;\n\nfunction closeOver(globals, src, file, opts) {\n  var keys = Object.keys(globals);\n  if (keys.length === 0) return src;\n  var values = keys.map(function (key) {\n    return globals[key];\n  });\n  var wrappedSource;\n\n  if (keys.length <= 3) {\n    wrappedSource = '(function (' + keys.join(',') + '){\\n' + src + '\\n}).call(this,' + values.join(',') + ')';\n  } else {\n    // necessary to make arguments[3..6] still work for workerify etc\n    // a,b,c,arguments[3..6],d,e,f...\n    var extra = ['__argument0', '__argument1', '__argument2', '__argument3'];\n    var names = keys.slice(0, 3).concat(extra).concat(keys.slice(3));\n    values.splice(3, 0, 'arguments[3]', 'arguments[4]', 'arguments[5]', 'arguments[6]');\n    wrappedSource = '(function (' + names.join(',') + '){\\n' + src + '\\n}).call(this,' + values.join(',') + ')';\n  } // Generate source maps if wanted. Including the right offset for\n  // the wrapped source.\n\n\n  if (!opts.debug) {\n    return wrappedSource;\n  }\n\n  var sourceFile = path.relative(opts.basedir, file).replace(/\\\\/g, '/');\n  var sourceMap = combineSourceMap.create().addFile({\n    sourceFile: sourceFile,\n    source: src\n  }, {\n    line: 1\n  });\n  return combineSourceMap.removeComments(wrappedSource) + \"\\n\" + sourceMap.comment();\n}\n\nfunction countprops(props, name) {\n  return props.filter(function (prop) {\n    return prop.slice(0, name.length + 1) === name + '.';\n  }).length;\n}","map":null,"metadata":{},"sourceType":"script"}