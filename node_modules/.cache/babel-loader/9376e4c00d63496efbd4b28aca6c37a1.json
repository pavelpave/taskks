{"ast":null,"code":"/**\r\n * JSON + Object references wrapper\r\n *\r\n * @author Hunter Loftis <hunter@skookum.com>\r\n * @license The MIT license.\r\n * @copyright Copyright (c) 2010 Skookum, skookum.com\r\n */\n;\n\n(function () {\n  var CONTAINER_TYPES = 'object array date function'.split(' ');\n  var REFERENCE_FLAG = '_CRYO_REF_';\n  var INFINITY_FLAG = '_CRYO_INFINITY_';\n  var FUNCTION_FLAG = '_CRYO_FUNCTION_';\n  var UNDEFINED_FLAG = '_CRYO_UNDEFINED_';\n  var DATE_FLAG = '_CRYO_DATE_';\n  var OBJECT_FLAG = '_CRYO_OBJECT_';\n  var ARRAY_FLAG = '_CRYO_ARRAY_';\n\n  function typeOf(item) {\n    if (typeof item === 'object') {\n      if (item === null) return 'null';\n      if (item && item.nodeType === 1) return 'dom';\n      if (item instanceof Array) return 'array';\n      if (item instanceof Date) return 'date';\n      return 'object';\n    }\n\n    return typeof item;\n  } // Same as and copied from _.defaults\n\n\n  function defaults(obj) {\n    var length = arguments.length;\n    if (length < 2 || obj == null) return obj;\n\n    for (var index = 1; index < length; index++) {\n      var source = arguments[index],\n          keys = Object.keys(source),\n          l = keys.length;\n\n      for (var i = 0; i < l; i++) {\n        var key = keys[i];\n        if (obj[key] === void 0) obj[key] = source[key];\n      }\n    }\n\n    return obj;\n  }\n\n  ;\n\n  function stringify(item, options) {\n    var references = []; // Backward compatibility with 0.0.6 that exepects `options` to be a callback.\n\n    options = typeof options === 'function' ? {\n      prepare: options\n    } : options;\n    options = defaults(options || {}, {\n      prepare: null,\n      isSerializable: function isSerializable(item, key) {\n        return item.hasOwnProperty(key);\n      }\n    });\n    var root = cloneWithReferences(item, references, options);\n    return JSON.stringify({\n      root: root,\n      references: references\n    });\n  }\n\n  function cloneWithReferences(item, references, options, savedItems) {\n    // invoke callback before any operations related to serializing the item\n    if (options.prepare) {\n      options.prepare(item);\n    }\n\n    savedItems = savedItems || [];\n    var type = typeOf(item); // can this object contain its own properties?\n\n    if (CONTAINER_TYPES.indexOf(type) !== -1) {\n      var referenceIndex = savedItems.indexOf(item); // do we need to store a new reference to this object?\n\n      if (referenceIndex === -1) {\n        var clone = {};\n        referenceIndex = references.push({\n          contents: clone,\n          value: wrapConstructor(item)\n        }) - 1;\n        savedItems[referenceIndex] = item;\n\n        for (var key in item) {\n          if (options.isSerializable(item, key)) {\n            clone[key] = cloneWithReferences(item[key], references, options, savedItems);\n          }\n        }\n      } // return something like _CRYO_REF_22\n\n\n      return REFERENCE_FLAG + referenceIndex;\n    } // return a non-container object\n\n\n    return wrap(item);\n  }\n\n  function parse(string, options) {\n    var json = JSON.parse(string); // Backward compatibility with 0.0.6 that exepects `options` to be a callback.\n\n    options = typeof options === 'function' ? {\n      finalize: options\n    } : options;\n    options = defaults(options || {}, {\n      finalize: null\n    });\n    return rebuildFromReferences(json.root, json.references, options);\n  }\n\n  function rebuildFromReferences(item, references, options, restoredItems) {\n    restoredItems = restoredItems || [];\n\n    if (starts(item, REFERENCE_FLAG)) {\n      var referenceIndex = parseInt(item.slice(REFERENCE_FLAG.length), 10);\n\n      if (!restoredItems.hasOwnProperty(referenceIndex)) {\n        var ref = references[referenceIndex];\n        var container = unwrapConstructor(ref.value);\n        var contents = ref.contents;\n        restoredItems[referenceIndex] = container;\n\n        for (var key in contents) {\n          container[key] = rebuildFromReferences(contents[key], references, options, restoredItems);\n        }\n      } // invoke callback after all operations related to serializing the item\n\n\n      if (options.finalize) {\n        options.finalize(restoredItems[referenceIndex]);\n      }\n\n      return restoredItems[referenceIndex];\n    } // invoke callback after all operations related to serializing the item\n\n\n    if (options.finalize) {\n      options.finalize(item);\n    }\n\n    return unwrap(item);\n  }\n\n  function wrap(item) {\n    var type = typeOf(item);\n    if (type === 'undefined') return UNDEFINED_FLAG;\n    if (type === 'function') return FUNCTION_FLAG + item.toString();\n    if (type === 'date') return DATE_FLAG + item.getTime();\n    if (item === Infinity) return INFINITY_FLAG;\n    if (type === 'dom') return undefined;\n    return item;\n  }\n\n  function wrapConstructor(item) {\n    var type = typeOf(item);\n    if (type === 'function' || type === 'date') return wrap(item);\n    if (type === 'object') return OBJECT_FLAG;\n    if (type === 'array') return ARRAY_FLAG;\n    return item;\n  }\n\n  function unwrapConstructor(val) {\n    if (typeOf(val) === 'string') {\n      if (val === UNDEFINED_FLAG) return undefined;\n\n      if (starts(val, FUNCTION_FLAG)) {\n        return new Function(\"return \" + val.slice(FUNCTION_FLAG.length))();\n      }\n\n      if (starts(val, DATE_FLAG)) {\n        var dateNum = parseInt(val.slice(DATE_FLAG.length), 10);\n        return new Date(dateNum);\n      }\n\n      if (starts(val, OBJECT_FLAG)) {\n        return {};\n      }\n\n      if (starts(val, ARRAY_FLAG)) {\n        return [];\n      }\n\n      if (val === INFINITY_FLAG) return Infinity;\n    }\n\n    return val;\n  }\n\n  function unwrap(val) {\n    if (typeOf(val) === 'string') {\n      if (val === UNDEFINED_FLAG) return undefined;\n\n      if (starts(val, FUNCTION_FLAG)) {\n        var fn = val.slice(FUNCTION_FLAG.length);\n        var argStart = fn.indexOf('(') + 1;\n        var argEnd = fn.indexOf(')', argStart);\n        var args = fn.slice(argStart, argEnd);\n        var bodyStart = fn.indexOf('{') + 1;\n        var bodyEnd = fn.lastIndexOf('}') - 1;\n        var body = fn.slice(bodyStart, bodyEnd);\n        return new Function(args, body);\n      }\n\n      if (starts(val, DATE_FLAG)) {\n        var dateNum = parseInt(val.slice(DATE_FLAG.length), 10);\n        return new Date(dateNum);\n      }\n\n      if (val === INFINITY_FLAG) return Infinity;\n    }\n\n    return val;\n  }\n\n  function starts(string, prefix) {\n    return typeOf(string) === 'string' && string.slice(0, prefix.length) === prefix;\n  }\n\n  function isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  } // Exported object\n\n\n  var Cryo = {\n    stringify: stringify,\n    parse: parse\n  }; // global on server, window in browser\n\n  var root = this; // AMD / RequireJS\n\n  if (typeof define !== 'undefined' && define.amd) {\n    define('Cryo', [], function () {\n      return Cryo;\n    });\n  } // node.js\n  else if (typeof module !== 'undefined' && module.exports) {\n      module.exports = Cryo;\n    } // included directly via <script> tag\n    else {\n        root.Cryo = Cryo;\n      }\n})();","map":null,"metadata":{},"sourceType":"script"}