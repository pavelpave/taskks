{"ast":null,"code":"/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\r\n */\nvar fs = require('graceful-fs');\n\nvar path = require('path');\n\nvar _ = require('lodash');\n\nvar glob = require('glob');\n\nvar file = module.exports = {};\nvar pathSeparatorRe = /[\\/\\\\]/g; // Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\n\nvar processPatterns = function processPatterns(patterns, fn) {\n  // Filepaths to return.\n  var result = []; // Iterate over flattened patterns array.\n\n  _.flatten(patterns).forEach(function (pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0; // If the pattern is an exclusion, remove the !\n\n    if (exclusion) {\n      pattern = pattern.slice(1);\n    } // Find all matching files for this pattern.\n\n\n    var matches = fn(pattern);\n\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = _.difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = _.union(result, matches);\n    }\n  });\n\n  return result;\n}; // True if the file path exists.\n\n\nfile.exists = function () {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n}; // Return an array of all file paths that match the given wildcard patterns.\n\n\nfile.expand = function () {\n  var args = _.toArray(arguments); // If the first argument is an options object, save those options to pass\n  // into the File.prototype.glob.sync method.\n\n\n  var options = _.isPlainObject(args[0]) ? args.shift() : {}; // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n\n  var patterns = Array.isArray(args[0]) ? args[0] : args; // Return empty set if there are no patterns or filepaths.\n\n  if (patterns.length === 0) {\n    return [];\n  } // Return all matching filepaths.\n\n\n  var matches = processPatterns(patterns, function (pattern) {\n    // Find all matching files for this pattern.\n    return glob.sync(pattern, options);\n  }); // Filter result set?\n\n  if (options.filter) {\n    matches = matches.filter(function (filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch (e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n\n  return matches;\n}; // Build a multi task \"files\" object dynamically.\n\n\nfile.expandMapping = function (patterns, destBase, options) {\n  options = _.defaults({}, options, {\n    rename: function rename(destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  });\n  var files = [];\n  var fileByDest = {}; // Find all files matching pattern, using passed-in options.\n\n  file.expand(options, patterns).forEach(function (src) {\n    var destPath = src; // Flatten?\n\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    } // Change the extension?\n\n\n    if (options.ext) {\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\n    } // Generate destination filename.\n\n\n    var dest = options.rename(destBase, destPath, options); // Prepend cwd to src path if necessary.\n\n    if (options.cwd) {\n      src = path.join(options.cwd, src);\n    } // Normalize filepaths to be unix-style.\n\n\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/'); // Map correct src path to dest path.\n\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest\n      }); // And store a reference for later use.\n\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n}; // reusing bits of grunt's multi-task source normalization\n\n\nfile.normalizeFilesArray = function (data) {\n  var files = [];\n  data.forEach(function (obj) {\n    var prop;\n\n    if ('src' in obj || 'dest' in obj) {\n      files.push(obj);\n    }\n  });\n\n  if (files.length === 0) {\n    return [];\n  }\n\n  files = _(files).chain().forEach(function (obj) {\n    if (!('src' in obj) || !obj.src) {\n      return;\n    } // Normalize .src properties to flattened array.\n\n\n    if (Array.isArray(obj.src)) {\n      obj.src = _.flatten(obj.src);\n    } else {\n      obj.src = [obj.src];\n    }\n  }).map(function (obj) {\n    // Build options object, removing unwanted properties.\n    var expandOptions = _.extend({}, obj);\n\n    delete expandOptions.src;\n    delete expandOptions.dest; // Expand file mappings.\n\n    if (obj.expand) {\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function (mapObj) {\n        // Copy obj properties to result.\n        var result = _.extend({}, obj); // Make a clone of the orig obj available.\n\n\n        result.orig = _.extend({}, obj); // Set .src and .dest, processing both as templates.\n\n        result.src = mapObj.src;\n        result.dest = mapObj.dest; // Remove unwanted properties.\n\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function (prop) {\n          delete result[prop];\n        });\n        return result;\n      });\n    } // Copy obj properties to result, adding an .orig property.\n\n\n    var result = _.extend({}, obj); // Make a clone of the orig obj available.\n\n\n    result.orig = _.extend({}, obj);\n\n    if ('src' in result) {\n      // Expose an expand-on-demand getter method as .src.\n      Object.defineProperty(result, 'src', {\n        enumerable: true,\n        get: function fn() {\n          var src;\n\n          if (!('result' in fn)) {\n            src = obj.src; // If src is an array, flatten it. Otherwise, make it into an array.\n\n            src = Array.isArray(src) ? _.flatten(src) : [src]; // Expand src files, memoizing result.\n\n            fn.result = file.expand(expandOptions, src);\n          }\n\n          return fn.result;\n        }\n      });\n    }\n\n    if ('dest' in result) {\n      result.dest = obj.dest;\n    }\n\n    return result;\n  }).flatten().value();\n  return files;\n};","map":null,"metadata":{},"sourceType":"script"}